{"ast":null,"code":"//    abc_parse.js: parses a string representing ABC Music Notation into a usable internal structure.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*global window */\nvar parseCommon = require('./abc_common');\n\nvar parseDirective = require('./abc_parse_directive');\n\nvar ParseHeader = require('./abc_parse_header');\n\nvar parseKeyVoice = require('./abc_parse_key_voice');\n\nvar Tokenizer = require('./abc_tokenizer');\n\nvar transpose = require('./abc_transpose');\n\nvar Tune = require('../data/abc_tune');\n\nvar Parse = function () {\n  \"use strict\";\n\n  var tune = new Tune();\n  var tokenizer = new Tokenizer();\n\n  this.getTune = function () {\n    return tune;\n  };\n\n  function addPositioning(el, type, value) {\n    if (!el.positioning) el.positioning = {};\n    el.positioning[type] = value;\n  }\n\n  function addFont(el, type, value) {\n    if (!el.fonts) el.fonts = {};\n    el.fonts[type] = value;\n  }\n\n  var multilineVars = {\n    reset: function () {\n      for (var property in this) {\n        if (this.hasOwnProperty(property) && typeof this[property] !== \"function\") {\n          delete this[property];\n        }\n      }\n\n      this.iChar = 0;\n      this.key = {\n        accidentals: [],\n        root: 'none',\n        acc: '',\n        mode: ''\n      };\n      this.meter = null; // if no meter is specified, free meter is assumed\n\n      this.origMeter = null; // this is for new voices that are created after we set the meter.\n\n      this.hasMainTitle = false;\n      this.default_length = 0.125;\n      this.clef = {\n        type: 'treble',\n        verticalPos: 0\n      };\n      this.next_note_duration = 0;\n      this.start_new_line = true;\n      this.is_in_header = true;\n      this.is_in_history = false;\n      this.partForNextLine = \"\";\n      this.havent_set_length = true;\n      this.voices = {};\n      this.staves = [];\n      this.macros = {};\n      this.currBarNumber = 1;\n      this.inTextBlock = false;\n      this.inPsBlock = false;\n      this.ignoredDecorations = [];\n      this.textBlock = \"\";\n      this.score_is_present = false; // Can't have original V: lines when there is the score directive\n\n      this.inEnding = false;\n      this.inTie = false;\n      this.inTieChord = {};\n      this.vocalPosition = \"auto\";\n      this.dynamicPosition = \"auto\";\n      this.chordPosition = \"auto\";\n      this.ornamentPosition = \"auto\";\n      this.volumePosition = \"auto\";\n      this.openSlurs = [];\n    },\n    differentFont: function (type, defaultFonts) {\n      if (this[type].decoration !== defaultFonts[type].decoration) return true;\n      if (this[type].face !== defaultFonts[type].face) return true;\n      if (this[type].size !== defaultFonts[type].size) return true;\n      if (this[type].style !== defaultFonts[type].style) return true;\n      if (this[type].weight !== defaultFonts[type].weight) return true;\n      return false;\n    },\n    addFormattingOptions: function (el, defaultFonts, elType) {\n      if (elType === 'note') {\n        if (this.vocalPosition !== 'auto') addPositioning(el, 'vocalPosition', this.vocalPosition);\n        if (this.dynamicPosition !== 'auto') addPositioning(el, 'dynamicPosition', this.dynamicPosition);\n        if (this.chordPosition !== 'auto') addPositioning(el, 'chordPosition', this.chordPosition);\n        if (this.ornamentPosition !== 'auto') addPositioning(el, 'ornamentPosition', this.ornamentPosition);\n        if (this.volumePosition !== 'auto') addPositioning(el, 'volumePosition', this.volumePosition);\n        if (this.differentFont(\"annotationfont\", defaultFonts)) addFont(el, 'annotationfont', this.annotationfont);\n        if (this.differentFont(\"gchordfont\", defaultFonts)) addFont(el, 'gchordfont', this.gchordfont);\n        if (this.differentFont(\"vocalfont\", defaultFonts)) addFont(el, 'vocalfont', this.vocalfont);\n      } else if (elType === 'bar') {\n        if (this.dynamicPosition !== 'auto') addPositioning(el, 'dynamicPosition', this.dynamicPosition);\n        if (this.chordPosition !== 'auto') addPositioning(el, 'chordPosition', this.chordPosition);\n        if (this.ornamentPosition !== 'auto') addPositioning(el, 'ornamentPosition', this.ornamentPosition);\n        if (this.volumePosition !== 'auto') addPositioning(el, 'volumePosition', this.volumePosition);\n        if (this.differentFont(\"measurefont\", defaultFonts)) addFont(el, 'measurefont', this.measurefont);\n        if (this.differentFont(\"repeatfont\", defaultFonts)) addFont(el, 'repeatfont', this.repeatfont);\n      }\n    }\n  };\n\n  var addWarning = function (str) {\n    if (!multilineVars.warnings) multilineVars.warnings = [];\n    multilineVars.warnings.push(str);\n  };\n\n  var addWarningObject = function (warningObject) {\n    if (!multilineVars.warningObjects) multilineVars.warningObjects = [];\n    multilineVars.warningObjects.push(warningObject);\n  };\n\n  var encode = function (str) {\n    var ret = parseCommon.gsub(str, '\\x12', ' ');\n    ret = parseCommon.gsub(ret, '&', '&amp;');\n    ret = parseCommon.gsub(ret, '<', '&lt;');\n    return parseCommon.gsub(ret, '>', '&gt;');\n  };\n\n  var warn = function (str, line, col_num) {\n    if (!line) line = \" \";\n    var bad_char = line.charAt(col_num);\n    if (bad_char === ' ') bad_char = \"SPACE\";\n    var clean_line = encode(line.substring(0, col_num)) + '<span style=\"text-decoration:underline;font-size:1.3em;font-weight:bold;\">' + bad_char + '</span>' + encode(line.substring(col_num + 1));\n    addWarning(\"Music Line:\" + tune.getNumLines() + \":\" + (col_num + 1) + ': ' + str + \":  \" + clean_line);\n    addWarningObject({\n      message: str,\n      line: line,\n      startChar: multilineVars.iChar + col_num,\n      column: col_num\n    });\n  };\n\n  var header = new ParseHeader(tokenizer, warn, multilineVars, tune);\n\n  this.getWarnings = function () {\n    return multilineVars.warnings;\n  };\n\n  this.getWarningObjects = function () {\n    return multilineVars.warningObjects;\n  };\n\n  var letter_to_chord = function (line, i) {\n    if (line.charAt(i) === '\"') {\n      var chord = tokenizer.getBrackettedSubstring(line, i, 5);\n      if (!chord[2]) warn(\"Missing the closing quote while parsing the chord symbol\", line, i); // If it starts with ^, then the chord appears above.\n      // If it starts with _ then the chord appears below.\n      // (note that the 2.0 draft standard defines them as not chords, but annotations and also defines @.)\n\n      if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '^') {\n        chord[1] = chord[1].substring(1);\n        chord[2] = 'above';\n      } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '_') {\n        chord[1] = chord[1].substring(1);\n        chord[2] = 'below';\n      } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '<') {\n        chord[1] = chord[1].substring(1);\n        chord[2] = 'left';\n      } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '>') {\n        chord[1] = chord[1].substring(1);\n        chord[2] = 'right';\n      } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '@') {\n        // @-15,5.7\n        chord[1] = chord[1].substring(1);\n        var x = tokenizer.getFloat(chord[1]);\n        if (x.digits === 0) warn(\"Missing first position in absolutely positioned annotation.\", line, i);\n        chord[1] = chord[1].substring(x.digits);\n        if (chord[1][0] !== ',') warn(\"Missing comma absolutely positioned annotation.\", line, i);\n        chord[1] = chord[1].substring(1);\n        var y = tokenizer.getFloat(chord[1]);\n        if (y.digits === 0) warn(\"Missing second position in absolutely positioned annotation.\", line, i);\n        chord[1] = chord[1].substring(y.digits);\n        var ws = tokenizer.skipWhiteSpace(chord[1]);\n        chord[1] = chord[1].substring(ws);\n        chord[2] = null;\n        chord[3] = {\n          x: x.value,\n          y: y.value\n        };\n      } else {\n        chord[1] = chord[1].replace(/([ABCDEFG])b/g, \"$1♭\");\n        chord[1] = chord[1].replace(/([ABCDEFG])#/g, \"$1♯\");\n        chord[2] = 'default';\n        chord[1] = transpose.chordName(multilineVars, chord[1]);\n      }\n\n      return chord;\n    }\n\n    return [0, \"\"];\n  };\n\n  var legalAccents = [\"trill\", \"lowermordent\", \"uppermordent\", \"mordent\", \"pralltriller\", \"accent\", \"fermata\", \"invertedfermata\", \"tenuto\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"+\", \"wedge\", \"open\", \"thumb\", \"snap\", \"turn\", \"roll\", \"breath\", \"shortphrase\", \"mediumphrase\", \"longphrase\", \"segno\", \"coda\", \"D.S.\", \"D.C.\", \"fine\", \"slide\", \"^\", \"marcato\", \"upbow\", \"downbow\", \"/\", \"//\", \"///\", \"////\", \"trem1\", \"trem2\", \"trem3\", \"trem4\", \"turnx\", \"invertedturn\", \"invertedturnx\", \"trill(\", \"trill)\", \"arpeggio\", \"xstem\", \"mark\", \"umarcato\", \"style=normal\", \"style=harmonic\", \"style=rhythm\", \"style=x\"];\n  var volumeDecorations = [\"p\", \"pp\", \"f\", \"ff\", \"mf\", \"mp\", \"ppp\", \"pppp\", \"fff\", \"ffff\", \"sfz\"];\n  var dynamicDecorations = [\"crescendo(\", \"crescendo)\", \"diminuendo(\", \"diminuendo)\"];\n  var accentPseudonyms = [[\"<\", \"accent\"], [\">\", \"accent\"], [\"tr\", \"trill\"], [\"plus\", \"+\"], [\"emphasis\", \"accent\"], [\"^\", \"umarcato\"], [\"marcato\", \"umarcato\"]];\n  var accentDynamicPseudonyms = [[\"<(\", \"crescendo(\"], [\"<)\", \"crescendo)\"], [\">(\", \"diminuendo(\"], [\">)\", \"diminuendo)\"]];\n\n  var letter_to_accent = function (line, i) {\n    var macro = multilineVars.macros[line.charAt(i)];\n\n    if (macro !== undefined) {\n      if (macro.charAt(0) === '!' || macro.charAt(0) === '+') macro = macro.substring(1);\n      if (macro.charAt(macro.length - 1) === '!' || macro.charAt(macro.length - 1) === '+') macro = macro.substring(0, macro.length - 1);\n      if (parseCommon.detect(legalAccents, function (acc) {\n        return macro === acc;\n      })) return [1, macro];else if (parseCommon.detect(volumeDecorations, function (acc) {\n        return macro === acc;\n      })) {\n        if (multilineVars.volumePosition === 'hidden') macro = \"\";\n        return [1, macro];\n      } else if (parseCommon.detect(dynamicDecorations, function (acc) {\n        if (multilineVars.dynamicPosition === 'hidden') macro = \"\";\n        return macro === acc;\n      })) {\n        return [1, macro];\n      } else {\n        if (!parseCommon.detect(multilineVars.ignoredDecorations, function (dec) {\n          return macro === dec;\n        })) warn(\"Unknown macro: \" + macro, line, i);\n        return [1, ''];\n      }\n    }\n\n    switch (line.charAt(i)) {\n      case '.':\n        return [1, 'staccato'];\n\n      case 'u':\n        return [1, 'upbow'];\n\n      case 'v':\n        return [1, 'downbow'];\n\n      case '~':\n        return [1, 'irishroll'];\n\n      case '!':\n      case '+':\n        var ret = tokenizer.getBrackettedSubstring(line, i, 5); // Be sure that the accent is recognizable.\n\n        if (ret[1].length > 0 && (ret[1].charAt(0) === '^' || ret[1].charAt(0) === '_')) ret[1] = ret[1].substring(1); // TODO-PER: The test files have indicators forcing the ornament to the top or bottom, but that isn't in the standard. We'll just ignore them.\n\n        if (parseCommon.detect(legalAccents, function (acc) {\n          return ret[1] === acc;\n        })) return ret;\n\n        if (parseCommon.detect(volumeDecorations, function (acc) {\n          return ret[1] === acc;\n        })) {\n          if (multilineVars.volumePosition === 'hidden') ret[1] = '';\n          return ret;\n        }\n\n        if (parseCommon.detect(dynamicDecorations, function (acc) {\n          return ret[1] === acc;\n        })) {\n          if (multilineVars.dynamicPosition === 'hidden') ret[1] = '';\n          return ret;\n        }\n\n        if (parseCommon.detect(accentPseudonyms, function (acc) {\n          if (ret[1] === acc[0]) {\n            ret[1] = acc[1];\n            return true;\n          } else return false;\n        })) return ret;\n\n        if (parseCommon.detect(accentDynamicPseudonyms, function (acc) {\n          if (ret[1] === acc[0]) {\n            ret[1] = acc[1];\n            return true;\n          } else return false;\n        })) {\n          if (multilineVars.dynamicPosition === 'hidden') ret[1] = '';\n          return ret;\n        } // We didn't find the accent in the list, so consume the space, but don't return an accent.\n        // Although it is possible that ! was used as a line break, so accept that.\n\n\n        if (line.charAt(i) === '!' && (ret[0] === 1 || line.charAt(i + ret[0] - 1) !== '!')) return [1, null];\n        warn(\"Unknown decoration: \" + ret[1], line, i);\n        ret[1] = \"\";\n        return ret;\n\n      case 'H':\n        return [1, 'fermata'];\n\n      case 'J':\n        return [1, 'slide'];\n\n      case 'L':\n        return [1, 'accent'];\n\n      case 'M':\n        return [1, 'mordent'];\n\n      case 'O':\n        return [1, 'coda'];\n\n      case 'P':\n        return [1, 'pralltriller'];\n\n      case 'R':\n        return [1, 'roll'];\n\n      case 'S':\n        return [1, 'segno'];\n\n      case 'T':\n        return [1, 'trill'];\n    }\n\n    return [0, 0];\n  };\n\n  var letter_to_spacer = function (line, i) {\n    var start = i;\n\n    while (tokenizer.isWhiteSpace(line.charAt(i))) i++;\n\n    return [i - start];\n  }; // returns the class of the bar line\n  // the number of the repeat\n  // and the number of characters used up\n  // if 0 is returned, then the next element was not a bar line\n\n\n  var letter_to_bar = function (line, curr_pos) {\n    var ret = tokenizer.getBarLine(line, curr_pos);\n    if (ret.len === 0) return [0, \"\"];\n\n    if (ret.warn) {\n      warn(ret.warn, line, curr_pos);\n      return [ret.len, \"\"];\n    } // Now see if this is a repeated ending\n    // A repeated ending is all of the characters 1,2,3,4,5,6,7,8,9,0,-, and comma\n    // It can also optionally start with '[', which is ignored.\n    // Also, it can have white space before the '['.\n\n\n    for (var ws = 0; ws < line.length; ws++) if (line.charAt(curr_pos + ret.len + ws) !== ' ') break;\n\n    var orig_bar_len = ret.len;\n\n    if (line.charAt(curr_pos + ret.len + ws) === '[') {\n      ret.len += ws + 1;\n    } // It can also be a quoted string. It is unclear whether that construct requires '[', but it seems like it would. otherwise it would be confused with a regular chord.\n\n\n    if (line.charAt(curr_pos + ret.len) === '\"' && line.charAt(curr_pos + ret.len - 1) === '[') {\n      var ending = tokenizer.getBrackettedSubstring(line, curr_pos + ret.len, 5);\n      return [ret.len + ending[0], ret.token, ending[1]];\n    }\n\n    var retRep = tokenizer.getTokenOf(line.substring(curr_pos + ret.len), \"1234567890-,\");\n    if (retRep.len === 0 || retRep.token[0] === '-') return [orig_bar_len, ret.token];\n    return [ret.len + retRep.len, ret.token, retRep.token];\n  };\n\n  var tripletQ = {\n    2: 3,\n    3: 2,\n    4: 3,\n    5: 2,\n    // TODO-PER: not handling 6/8 rhythm yet\n    6: 2,\n    7: 2,\n    // TODO-PER: not handling 6/8 rhythm yet\n    8: 3,\n    9: 2 // TODO-PER: not handling 6/8 rhythm yet\n\n  };\n\n  var letter_to_open_slurs_and_triplets = function (line, i) {\n    // consume spaces, and look for all the open parens. If there is a number after the open paren,\n    // that is a triplet. Otherwise that is a slur. Collect all the slurs and the first triplet.\n    var ret = {};\n    var start = i;\n\n    while (line.charAt(i) === '(' || tokenizer.isWhiteSpace(line.charAt(i))) {\n      if (line.charAt(i) === '(') {\n        if (i + 1 < line.length && line.charAt(i + 1) >= '2' && line.charAt(i + 1) <= '9') {\n          if (ret.triplet !== undefined) warn(\"Can't nest triplets\", line, i);else {\n            ret.triplet = line.charAt(i + 1) - '0';\n            ret.tripletQ = tripletQ[ret.triplet];\n            ret.num_notes = ret.triplet;\n\n            if (i + 2 < line.length && line.charAt(i + 2) === ':') {\n              // We are expecting \"(p:q:r\" or \"(p:q\" or \"(p::r\"\n              // That is: \"put p notes into the time of q for the next r notes\"\n              // if r is missing, then it is equal to p.\n              // if q is missing, it is determined from this table:\n              // (2 notes in the time of 3\n              // (3 notes in the time of 2\n              // (4 notes in the time of 3\n              // (5 notes in the time of n | if time sig is (6/8, 9/8, 12/8), n=3, else n=2\n              // (6 notes in the time of 2\n              // (7 notes in the time of n\n              // (8 notes in the time of 3\n              // (9 notes in the time of n\n              if (i + 3 < line.length && line.charAt(i + 3) === ':') {\n                // The second number, 'q', is not present.\n                if (i + 4 < line.length && line.charAt(i + 4) >= '1' && line.charAt(i + 4) <= '9') {\n                  ret.num_notes = line.charAt(i + 4) - '0';\n                  i += 3;\n                } else warn(\"expected number after the two colons after the triplet to mark the duration\", line, i);\n              } else if (i + 3 < line.length && line.charAt(i + 3) >= '1' && line.charAt(i + 3) <= '9') {\n                ret.tripletQ = line.charAt(i + 3) - '0';\n\n                if (i + 4 < line.length && line.charAt(i + 4) === ':') {\n                  if (i + 5 < line.length && line.charAt(i + 5) >= '1' && line.charAt(i + 5) <= '9') {\n                    ret.num_notes = line.charAt(i + 5) - '0';\n                    i += 4;\n                  }\n                } else {\n                  i += 2;\n                }\n              } else warn(\"expected number after the triplet to mark the duration\", line, i);\n            }\n          }\n          i++;\n        } else {\n          if (ret.startSlur === undefined) ret.startSlur = 1;else ret.startSlur++;\n        }\n      }\n\n      i++;\n    }\n\n    ret.consumed = i - start;\n    return ret;\n  };\n\n  var addWords = function (line, words) {\n    if (!line) {\n      warn(\"Can't add words before the first line of music\", line, 0);\n      return;\n    }\n\n    words = parseCommon.strip(words);\n    if (words.charAt(words.length - 1) !== '-') words = words + ' '; // Just makes it easier to parse below, since every word has a divider after it.\n\n    var word_list = []; // first make a list of words from the string we are passed. A word is divided on either a space or dash.\n\n    var last_divider = 0;\n    var replace = false;\n\n    var addWord = function (i) {\n      var word = parseCommon.strip(words.substring(last_divider, i));\n      last_divider = i + 1;\n\n      if (word.length > 0) {\n        if (replace) word = parseCommon.gsub(word, '~', ' ');\n        var div = words.charAt(i);\n        if (div !== '_' && div !== '-') div = ' ';\n        word_list.push({\n          syllable: tokenizer.translateString(word),\n          divider: div\n        });\n        replace = false;\n        return true;\n      }\n\n      return false;\n    };\n\n    for (var i = 0; i < words.length; i++) {\n      switch (words.charAt(i)) {\n        case ' ':\n        case '\\x12':\n          addWord(i);\n          break;\n\n        case '-':\n          if (!addWord(i) && word_list.length > 0) {\n            parseCommon.last(word_list).divider = '-';\n            word_list.push({\n              skip: true,\n              to: 'next'\n            });\n          }\n\n          break;\n\n        case '_':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'slur'\n          });\n          break;\n\n        case '*':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'next'\n          });\n          break;\n\n        case '|':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'bar'\n          });\n          break;\n\n        case '~':\n          replace = true;\n          break;\n      }\n    }\n\n    var inSlur = false;\n    parseCommon.each(line, function (el) {\n      if (word_list.length !== 0) {\n        if (word_list[0].skip) {\n          switch (word_list[0].to) {\n            case 'next':\n              if (el.el_type === 'note' && el.pitches !== null && !inSlur) word_list.shift();\n              break;\n\n            case 'slur':\n              if (el.el_type === 'note' && el.pitches !== null) word_list.shift();\n              break;\n\n            case 'bar':\n              if (el.el_type === 'bar') word_list.shift();\n              break;\n          }\n\n          if (el.el_type !== 'bar') {\n            if (el.lyric === undefined) el.lyric = [{\n              syllable: \"\",\n              divider: \" \"\n            }];else el.lyric.push({\n              syllable: \"\",\n              divider: \" \"\n            });\n          }\n        } else {\n          if (el.el_type === 'note' && el.rest === undefined && !inSlur) {\n            var lyric = word_list.shift();\n            if (lyric.syllable) lyric.syllable = lyric.syllable.replace(/ +/g, '\\xA0');\n            if (el.lyric === undefined) el.lyric = [lyric];else el.lyric.push(lyric);\n          }\n        }\n      }\n    });\n  };\n\n  var addSymbols = function (line, words) {\n    // TODO-PER: Currently copied from w: line. This needs to be read as symbols instead.\n    if (!line) {\n      warn(\"Can't add symbols before the first line of music\", line, 0);\n      return;\n    }\n\n    words = parseCommon.strip(words);\n    if (words.charAt(words.length - 1) !== '-') words = words + ' '; // Just makes it easier to parse below, since every word has a divider after it.\n\n    var word_list = []; // first make a list of words from the string we are passed. A word is divided on either a space or dash.\n\n    var last_divider = 0;\n    var replace = false;\n\n    var addWord = function (i) {\n      var word = parseCommon.strip(words.substring(last_divider, i));\n      last_divider = i + 1;\n\n      if (word.length > 0) {\n        if (replace) word = parseCommon.gsub(word, '~', ' ');\n        var div = words.charAt(i);\n        if (div !== '_' && div !== '-') div = ' ';\n        word_list.push({\n          syllable: tokenizer.translateString(word),\n          divider: div\n        });\n        replace = false;\n        return true;\n      }\n\n      return false;\n    };\n\n    for (var i = 0; i < words.length; i++) {\n      switch (words.charAt(i)) {\n        case ' ':\n        case '\\x12':\n          addWord(i);\n          break;\n\n        case '-':\n          if (!addWord(i) && word_list.length > 0) {\n            parseCommon.last(word_list).divider = '-';\n            word_list.push({\n              skip: true,\n              to: 'next'\n            });\n          }\n\n          break;\n\n        case '_':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'slur'\n          });\n          break;\n\n        case '*':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'next'\n          });\n          break;\n\n        case '|':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'bar'\n          });\n          break;\n\n        case '~':\n          replace = true;\n          break;\n      }\n    }\n\n    var inSlur = false;\n    parseCommon.each(line, function (el) {\n      if (word_list.length !== 0) {\n        if (word_list[0].skip) {\n          switch (word_list[0].to) {\n            case 'next':\n              if (el.el_type === 'note' && el.pitches !== null && !inSlur) word_list.shift();\n              break;\n\n            case 'slur':\n              if (el.el_type === 'note' && el.pitches !== null) word_list.shift();\n              break;\n\n            case 'bar':\n              if (el.el_type === 'bar') word_list.shift();\n              break;\n          }\n        } else {\n          if (el.el_type === 'note' && el.rest === undefined && !inSlur) {\n            var lyric = word_list.shift();\n            if (el.lyric === undefined) el.lyric = [lyric];else el.lyric.push(lyric);\n          }\n        }\n      }\n    });\n  };\n\n  var getBrokenRhythm = function (line, index) {\n    switch (line.charAt(index)) {\n      case '>':\n        if (index < line.length - 1 && line.charAt(index + 1) === '>') // double >>\n          return [2, 1.75, 0.25];else return [1, 1.5, 0.5];\n        break;\n\n      case '<':\n        if (index < line.length - 1 && line.charAt(index + 1) === '<') // double <<\n          return [2, 0.25, 1.75];else return [1, 0.5, 1.5];\n        break;\n    }\n\n    return null;\n  }; // TODO-PER: make this a method in el.\n\n\n  var addEndBeam = function (el) {\n    if (el.duration !== undefined && el.duration < 0.25) el.end_beam = true;\n    return el;\n  };\n\n  var pitches = {\n    A: 5,\n    B: 6,\n    C: 0,\n    D: 1,\n    E: 2,\n    F: 3,\n    G: 4,\n    a: 12,\n    b: 13,\n    c: 7,\n    d: 8,\n    e: 9,\n    f: 10,\n    g: 11\n  };\n  var rests = {\n    x: 'invisible',\n    y: 'spacer',\n    z: 'rest',\n    Z: 'multimeasure'\n  };\n\n  var getCoreNote = function (line, index, el, canHaveBrokenRhythm) {\n    //var el = { startChar: index };\n    var isComplete = function (state) {\n      return state === 'octave' || state === 'duration' || state === 'Zduration' || state === 'broken_rhythm' || state === 'end_slur';\n    };\n\n    var state = 'startSlur';\n    var durationSetByPreviousNote = false;\n\n    while (1) {\n      switch (line.charAt(index)) {\n        case '(':\n          if (state === 'startSlur') {\n            if (el.startSlur === undefined) el.startSlur = 1;else el.startSlur++;\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case ')':\n          if (isComplete(state)) {\n            if (el.endSlur === undefined) el.endSlur = 1;else el.endSlur++;\n          } else return null;\n\n          break;\n\n        case '^':\n          if (state === 'startSlur') {\n            el.accidental = 'sharp';\n            state = 'sharp2';\n          } else if (state === 'sharp2') {\n            el.accidental = 'dblsharp';\n            state = 'pitch';\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case '_':\n          if (state === 'startSlur') {\n            el.accidental = 'flat';\n            state = 'flat2';\n          } else if (state === 'flat2') {\n            el.accidental = 'dblflat';\n            state = 'pitch';\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case '=':\n          if (state === 'startSlur') {\n            el.accidental = 'natural';\n            state = 'pitch';\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case 'A':\n        case 'B':\n        case 'C':\n        case 'D':\n        case 'E':\n        case 'F':\n        case 'G':\n        case 'a':\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'e':\n        case 'f':\n        case 'g':\n          if (state === 'startSlur' || state === 'sharp2' || state === 'flat2' || state === 'pitch') {\n            el.pitch = pitches[line.charAt(index)];\n            transpose.note(multilineVars, el);\n            state = 'octave'; // At this point we have a valid note. The rest is optional. Set the duration in case we don't get one below\n\n            if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {\n              el.duration = multilineVars.default_length * multilineVars.next_note_duration;\n              multilineVars.next_note_duration = 0;\n              durationSetByPreviousNote = true;\n            } else el.duration = multilineVars.default_length; // If the clef is percussion, there is probably some translation of the pitch to a particular drum kit item.\n\n\n            if (multilineVars.clef && multilineVars.clef.type === \"perc\" || multilineVars.currentVoice && multilineVars.currentVoice.clef === \"perc\") {\n              var key = line.charAt(index);\n\n              if (el.accidental) {\n                var accMap = {\n                  'dblflat': '__',\n                  'flat': '_',\n                  'natural': '=',\n                  'sharp': '^',\n                  'dblsharp': '^^'\n                };\n                key = accMap[el.accidental] + key;\n              }\n\n              if (tune.formatting && tune.formatting.midi && tune.formatting.midi.drummap) el.midipitch = tune.formatting.midi.drummap[key];\n            }\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case ',':\n          if (state === 'octave') {\n            el.pitch -= 7;\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case '\\'':\n          if (state === 'octave') {\n            el.pitch += 7;\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case 'x':\n        case 'y':\n        case 'z':\n        case 'Z':\n          if (state === 'startSlur') {\n            el.rest = {\n              type: rests[line.charAt(index)]\n            }; // There shouldn't be some of the properties that notes have. If some sneak in due to bad syntax in the abc file,\n            // just nix them here.\n\n            delete el.accidental;\n            delete el.startSlur;\n            delete el.startTie;\n            delete el.endSlur;\n            delete el.endTie;\n            delete el.end_beam;\n            delete el.grace_notes; // At this point we have a valid note. The rest is optional. Set the duration in case we don't get one below\n\n            if (el.rest.type === 'multimeasure') {\n              el.duration = 1;\n              state = 'Zduration';\n            } else {\n              if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {\n                el.duration = multilineVars.default_length * multilineVars.next_note_duration;\n                multilineVars.next_note_duration = 0;\n                durationSetByPreviousNote = true;\n              } else el.duration = multilineVars.default_length;\n\n              state = 'duration';\n            }\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n        case '0':\n        case '/':\n          if (state === 'octave' || state === 'duration') {\n            var fraction = tokenizer.getFraction(line, index); //if (!durationSetByPreviousNote)\n\n            el.duration = el.duration * fraction.value; // TODO-PER: We can test the returned duration here and give a warning if it isn't the one expected.\n\n            el.endChar = fraction.index;\n\n            while (fraction.index < line.length && (tokenizer.isWhiteSpace(line.charAt(fraction.index)) || line.charAt(fraction.index) === '-')) {\n              if (line.charAt(fraction.index) === '-') el.startTie = {};else el = addEndBeam(el);\n              fraction.index++;\n            }\n\n            index = fraction.index - 1;\n            state = 'broken_rhythm';\n          } else if (state === 'sharp2') {\n            el.accidental = 'quartersharp';\n            state = 'pitch';\n          } else if (state === 'flat2') {\n            el.accidental = 'quarterflat';\n            state = 'pitch';\n          } else if (state === 'Zduration') {\n            var num = tokenizer.getNumber(line, index);\n            el.duration = num.num;\n            el.endChar = num.index;\n            return el;\n          } else return null;\n\n          break;\n\n        case '-':\n          if (state === 'startSlur') {\n            // This is the first character, so it must have been meant for the previous note. Correct that here.\n            tune.addTieToLastNote();\n            el.endTie = true;\n          } else if (state === 'octave' || state === 'duration' || state === 'end_slur') {\n            el.startTie = {};\n            if (!durationSetByPreviousNote && canHaveBrokenRhythm) state = 'broken_rhythm';else {\n              // Peek ahead to the next character. If it is a space, then we have an end beam.\n              if (tokenizer.isWhiteSpace(line.charAt(index + 1))) addEndBeam(el);\n              el.endChar = index + 1;\n              return el;\n            }\n          } else if (state === 'broken_rhythm') {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case ' ':\n        case '\\t':\n          if (isComplete(state)) {\n            el.end_beam = true; // look ahead to see if there is a tie\n\n            do {\n              if (line.charAt(index) === '-') el.startTie = {};\n              index++;\n            } while (index < line.length && (tokenizer.isWhiteSpace(line.charAt(index)) || line.charAt(index) === '-'));\n\n            el.endChar = index;\n\n            if (!durationSetByPreviousNote && canHaveBrokenRhythm && (line.charAt(index) === '<' || line.charAt(index) === '>')) {\n              // TODO-PER: Don't need the test for < and >, but that makes the endChar work out for the regression test.\n              index--;\n              state = 'broken_rhythm';\n            } else return el;\n          } else return null;\n\n          break;\n\n        case '>':\n        case '<':\n          if (isComplete(state)) {\n            if (canHaveBrokenRhythm) {\n              var br2 = getBrokenRhythm(line, index);\n              index += br2[0] - 1; // index gets incremented below, so we'll let that happen\n\n              multilineVars.next_note_duration = br2[2];\n              el.duration = br2[1] * el.duration;\n              state = 'end_slur';\n            } else {\n              el.endChar = index;\n              return el;\n            }\n          } else return null;\n\n          break;\n\n        default:\n          if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          }\n\n          return null;\n      }\n\n      index++;\n\n      if (index === line.length) {\n        if (isComplete(state)) {\n          el.endChar = index;\n          return el;\n        } else return null;\n      }\n    }\n\n    return null;\n  };\n\n  function startNewLine() {\n    var params = {\n      startChar: -1,\n      endChar: -1\n    };\n    if (multilineVars.partForNextLine.length) params.part = multilineVars.partForNextLine;\n    params.clef = multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].clef !== undefined ? parseCommon.clone(multilineVars.staves[multilineVars.currentVoice.staffNum].clef) : parseCommon.clone(multilineVars.clef);\n    var scoreTranspose = multilineVars.currentVoice ? multilineVars.currentVoice.scoreTranspose : 0;\n    params.key = parseKeyVoice.standardKey(multilineVars.key.root + multilineVars.key.acc + multilineVars.key.mode, multilineVars.key.root, multilineVars.key.acc, scoreTranspose);\n    params.key.mode = multilineVars.key.mode;\n    if (multilineVars.key.impliedNaturals) params.key.impliedNaturals = multilineVars.key.impliedNaturals;\n\n    if (multilineVars.key.explicitAccidentals) {\n      for (var i = 0; i < multilineVars.key.explicitAccidentals.length; i++) {\n        var found = false;\n\n        for (var j = 0; j < params.key.accidentals.length; j++) {\n          if (params.key.accidentals[j].note === multilineVars.key.explicitAccidentals[i].note) {\n            // If the note is already in the list, override it with the new value\n            params.key.accidentals[j].acc = multilineVars.key.explicitAccidentals[i].acc;\n            found = true;\n          }\n        }\n\n        if (!found) params.key.accidentals.push(multilineVars.key.explicitAccidentals[i]);\n      }\n    }\n\n    if (params.key.explicitAccidentals) delete params.key.explicitAccidentals;\n    parseKeyVoice.addPosToKey(params.clef, params.key);\n\n    if (multilineVars.meter !== null) {\n      if (multilineVars.currentVoice) {\n        parseCommon.each(multilineVars.staves, function (st) {\n          st.meter = multilineVars.meter;\n        });\n        params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;\n        multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;\n      } else params.meter = multilineVars.meter;\n\n      multilineVars.meter = null;\n    } else if (multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].meter) {\n      // Make sure that each voice gets the meter marking.\n      params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;\n      multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;\n    }\n\n    if (multilineVars.currentVoice && multilineVars.currentVoice.name) params.name = multilineVars.currentVoice.name;\n    if (multilineVars.vocalfont) params.vocalfont = multilineVars.vocalfont;\n    if (multilineVars.style) params.style = multilineVars.style;\n\n    if (multilineVars.currentVoice) {\n      var staff = multilineVars.staves[multilineVars.currentVoice.staffNum];\n      if (staff.brace) params.brace = staff.brace;\n      if (staff.bracket) params.bracket = staff.bracket;\n      if (staff.connectBarLines) params.connectBarLines = staff.connectBarLines;\n      if (staff.name) params.name = staff.name[multilineVars.currentVoice.index];\n      if (staff.subname) params.subname = staff.subname[multilineVars.currentVoice.index];\n      if (multilineVars.currentVoice.stem) params.stem = multilineVars.currentVoice.stem;\n      if (multilineVars.currentVoice.stafflines) params.stafflines = multilineVars.currentVoice.stafflines;\n      if (multilineVars.currentVoice.staffscale) params.staffscale = multilineVars.currentVoice.staffscale;\n      if (multilineVars.currentVoice.scale) params.scale = multilineVars.currentVoice.scale;\n      if (multilineVars.currentVoice.style) params.style = multilineVars.currentVoice.style;\n      if (multilineVars.currentVoice.transpose) params.clef.transpose = multilineVars.currentVoice.transpose;\n    }\n\n    var isFirstVoice = multilineVars.currentVoice === undefined || multilineVars.currentVoice.staffNum === 0 && multilineVars.currentVoice.index === 0;\n    if (multilineVars.barNumbers === 0 && isFirstVoice && multilineVars.currBarNumber !== 1) params.barNumber = multilineVars.currBarNumber;\n    tune.startNewLine(params);\n    if (multilineVars.key.impliedNaturals) delete multilineVars.key.impliedNaturals;\n    multilineVars.partForNextLine = \"\";\n  }\n\n  var letter_to_grace = function (line, i) {\n    // Grace notes are an array of: startslur, note, endslur, space; where note is accidental, pitch, duration\n    if (line.charAt(i) === '{') {\n      // fetch the gracenotes string and consume that into the array\n      var gra = tokenizer.getBrackettedSubstring(line, i, 1, '}');\n      if (!gra[2]) warn(\"Missing the closing '}' while parsing grace note\", line, i); // If there is a slur after the grace construction, then move it to the last note inside the grace construction\n\n      if (line[i + gra[0]] === ')') {\n        gra[0]++;\n        gra[1] += ')';\n      }\n\n      var gracenotes = [];\n      var ii = 0;\n      var inTie = false;\n\n      while (ii < gra[1].length) {\n        var acciaccatura = false;\n\n        if (gra[1].charAt(ii) === '/') {\n          acciaccatura = true;\n          ii++;\n        }\n\n        var note = getCoreNote(gra[1], ii, {}, false);\n\n        if (note !== null) {\n          // The grace note durations should not be affected by the default length: they should be based on 1/16, so if that isn't the default, then multiply here.\n          note.duration = note.duration / (multilineVars.default_length * 8);\n          if (acciaccatura) note.acciaccatura = true;\n          gracenotes.push(note);\n\n          if (inTie) {\n            note.endTie = true;\n            inTie = false;\n          }\n\n          if (note.startTie) inTie = true;\n          ii = note.endChar;\n          delete note.endChar;\n        } else {\n          // We shouldn't get anything but notes or a space here, so report an error\n          if (gra[1].charAt(ii) === ' ') {\n            if (gracenotes.length > 0) gracenotes[gracenotes.length - 1].end_beam = true;\n          } else warn(\"Unknown character '\" + gra[1].charAt(ii) + \"' while parsing grace note\", line, i);\n\n          ii++;\n        }\n      }\n\n      if (gracenotes.length) return [gra[0], gracenotes];\n    }\n\n    return [0];\n  };\n\n  function letter_to_overlay(line, i) {\n    if (line.charAt(i) === '&') {\n      var start = i;\n\n      while (line.charAt(i) && line.charAt(i) !== ':' && line.charAt(i) !== '|') i++;\n\n      return [i - start, line.substring(start + 1, i)];\n    }\n\n    return [0];\n  }\n\n  function durationOfMeasure(multilineVars) {\n    // TODO-PER: This could be more complicated if one of the unusual measures is used.\n    var meter = multilineVars.origMeter;\n    if (!meter || meter.type !== 'specified') return 1;\n    if (!meter.value || meter.value.length === 0) return 1;\n    return parseInt(meter.value[0].num, 10) / parseInt(meter.value[0].den, 10);\n  } //\n  // Parse line of music\n  //\n  // This is a stream of <(bar-marking|header|note-group)...> in any order, with optional spaces between each element\n  // core-note is <open-slur, accidental, pitch:required, octave, duration, close-slur&|tie> with no spaces within that\n  // chord is <open-bracket:required, core-note:required... close-bracket:required duration> with no spaces within that\n  // grace-notes is <open-brace:required, (open-slur|core-note:required|close-slur)..., close-brace:required> spaces are allowed\n  // note-group is <grace-notes, chord symbols&|decorations..., grace-notes, slur&|triplet, chord|core-note, end-slur|tie> spaces are allowed between items\n  // bar-marking is <ampersand> or <chord symbols&|decorations..., bar:required> spaces allowed\n  // header is <open-bracket:required, K|M|L|V:required, colon:required, field:required, close-bracket:required> spaces can occur between the colon, in the field, and before the close bracket\n  // header can also be the only thing on a line. This is true even if it is a continuation line. In this case the brackets are not required.\n  // a space is a back-tick, a space, or a tab. If it is a back-tick, then there is no end-beam.\n  // Line preprocessing: anything after a % is ignored (the double %% should have been taken care of before this)\n  // Then, all leading and trailing spaces are ignored.\n  // If there was a line continuation, the \\n was replaced by a \\r and the \\ was replaced by a space. This allows the construct\n  // of having a header mid-line conceptually, but actually be at the start of the line. This is equivolent to putting the header in [ ].\n  // TODO-PER: How to handle ! for line break?\n  // TODO-PER: dots before bar, dots before slur\n  // TODO-PER: U: redefinable symbols.\n  // Ambiguous symbols:\n  // \"[\" can be the start of a chord, the start of a header element or part of a bar line.\n  // --- if it is immediately followed by \"|\", it is a bar line\n  // --- if it is immediately followed by K: L: M: V: it is a header (note: there are other headers mentioned in the standard, but I'm not sure how they would be used.)\n  // --- otherwise it is the beginning of a chord\n  // \"(\" can be the start of a slur or a triplet\n  // --- if it is followed by a number from 2-9, then it is a triplet\n  // --- otherwise it is a slur\n  // \"]\"\n  // --- if there is a chord open, then this is the close\n  // --- if it is after a [|, then it is an invisible bar line\n  // --- otherwise, it is par of a bar\n  // \".\" can be a bar modifier or a slur modifier, or a decoration\n  // --- if it comes immediately before a bar, it is a bar modifier\n  // --- if it comes immediately before a slur, it is a slur modifier\n  // --- otherwise it is a decoration for the next note.\n  // number:\n  // --- if it is after a bar, with no space, it is an ending marker\n  // --- if it is after a ( with no space, it is a triplet count\n  // --- if it is after a pitch or octave or slash, then it is a duration\n  // Unambiguous symbols (except inside quoted strings):\n  // vertical-bar, colon: part of a bar\n  // ABCDEFGabcdefg: pitch\n  // xyzZ: rest\n  // comma, prime: octave\n  // close-paren: end-slur\n  // hyphen: tie\n  // tilde, v, u, bang, plus, THLMPSO: decoration\n  // carat, underscore, equal: accidental\n  // ampersand: time reset\n  // open-curly, close-curly: grace notes\n  // double-quote: chord symbol\n  // less-than, greater-than, slash: duration\n  // back-tick, space, tab: space\n\n\n  var nonDecorations = \"ABCDEFGabcdefgxyzZ[]|^_{\"; // use this to prescreen so we don't have to look for a decoration at every note.\n\n  var parseRegularMusicLine = function (line) {\n    header.resolveTempo(); //multilineVars.havent_set_length = false;\t// To late to set this now.\n\n    multilineVars.is_in_header = false; // We should have gotten a key header by now, but just in case, this is definitely out of the header.\n\n    var i = 0;\n    var startOfLine = multilineVars.iChar; // see if there is nothing but a comment on this line. If so, just ignore it. A full line comment is optional white space followed by %\n\n    while (tokenizer.isWhiteSpace(line.charAt(i)) && i < line.length) i++;\n\n    if (i === line.length || line.charAt(i) === '%') return; // Start with the standard staff, clef and key symbols on each line\n\n    var delayStartNewLine = multilineVars.start_new_line;\n    if (multilineVars.continueall === undefined) multilineVars.start_new_line = true;else multilineVars.start_new_line = false;\n    var tripletNotesLeft = 0; // See if the line starts with a header field\n\n    var retHeader = header.letter_to_body_header(line, i);\n\n    if (retHeader[0] > 0) {\n      i += retHeader[0];\n      if (retHeader[1] === 'V') delayStartNewLine = true; // fixes bug on this: c[V:2]d\n      // TODO-PER: Handle inline headers\n    }\n\n    var el = {};\n\n    while (i < line.length) {\n      var startI = i;\n      if (line.charAt(i) === '%') break;\n      var retInlineHeader = header.letter_to_inline_header(line, i);\n\n      if (retInlineHeader[0] > 0) {\n        i += retInlineHeader[0];\n        if (retInlineHeader[1] === 'V') delayStartNewLine = true; // fixes bug on this: c[V:2]d\n        // TODO-PER: Handle inline headers\n        //multilineVars.start_new_line = false;\n      } else {\n        // Wait until here to actually start the line because we know we're past the inline statements.\n        if (delayStartNewLine) {\n          startNewLine();\n          delayStartNewLine = false;\n        } // We need to decide if the following characters are a bar-marking or a note-group.\n        // Unfortunately, that is ambiguous. Both can contain chord symbols and decorations.\n        // If there is a grace note either before or after the chord symbols and decorations, then it is definitely a note-group.\n        // If there is a bar marker, it is definitely a bar-marking.\n        // If there is either a core-note or chord, it is definitely a note-group.\n        // So, loop while we find grace-notes, chords-symbols, or decorations. [It is an error to have more than one grace-note group in a row; the others can be multiple]\n        // Then, if there is a grace-note, we know where to go.\n        // Else see if we have a chord, core-note, slur, triplet, or bar.\n\n\n        var ret;\n\n        while (1) {\n          ret = tokenizer.eatWhiteSpace(line, i);\n\n          if (ret > 0) {\n            i += ret;\n          }\n\n          if (i > 0 && line.charAt(i - 1) === '\\x12') {\n            // there is one case where a line continuation isn't the same as being on the same line, and that is if the next character after it is a header.\n            ret = header.letter_to_body_header(line, i);\n\n            if (ret[0] > 0) {\n              if (ret[1] === 'V') startNewLine(); // fixes bug on this: c\\\\nV:2]\\\\nd\n              // TODO: insert header here\n\n              i = ret[0];\n              multilineVars.start_new_line = false;\n            }\n          } // gather all the grace notes, chord symbols and decorations\n\n\n          ret = letter_to_spacer(line, i);\n\n          if (ret[0] > 0) {\n            i += ret[0];\n          }\n\n          ret = letter_to_overlay(line, i);\n\n          if (ret[0] > 0) {\n            tune.appendElement('overlay', startOfLine, startOfLine + 1, {});\n            i += 1;\n          }\n\n          ret = letter_to_chord(line, i);\n\n          if (ret[0] > 0) {\n            // There could be more than one chord here if they have different positions.\n            // If two chords have the same position, then connect them with newline.\n            if (!el.chord) el.chord = [];\n            var chordName = tokenizer.translateString(ret[1]);\n            chordName = chordName.replace(/;/g, \"\\n\");\n            var addedChord = false;\n\n            for (var ci = 0; ci < el.chord.length; ci++) {\n              if (el.chord[ci].position === ret[2]) {\n                addedChord = true;\n                el.chord[ci].name += \"\\n\" + chordName;\n              }\n            }\n\n            if (addedChord === false) {\n              if (ret[2] === null && ret[3]) el.chord.push({\n                name: chordName,\n                rel_position: ret[3]\n              });else el.chord.push({\n                name: chordName,\n                position: ret[2]\n              });\n            }\n\n            i += ret[0];\n            var ii = tokenizer.skipWhiteSpace(line.substring(i));\n            if (ii > 0) el.force_end_beam_last = true;\n            i += ii;\n          } else {\n            if (nonDecorations.indexOf(line.charAt(i)) === -1) ret = letter_to_accent(line, i);else ret = [0];\n\n            if (ret[0] > 0) {\n              if (ret[1] === null) {\n                if (i + 1 < line.length) startNewLine(); // There was a ! in the middle of the line. Start a new line if there is anything after it.\n              } else if (ret[1].length > 0) {\n                if (ret[1].indexOf(\"style=\") === 0) {\n                  el.style = ret[1].substr(6);\n                } else {\n                  if (el.decoration === undefined) el.decoration = [];\n                  el.decoration.push(ret[1]);\n                }\n              }\n\n              i += ret[0];\n            } else {\n              ret = letter_to_grace(line, i); // TODO-PER: Be sure there aren't already grace notes defined. That is an error.\n\n              if (ret[0] > 0) {\n                el.gracenotes = ret[1];\n                i += ret[0];\n              } else break;\n            }\n          }\n        }\n\n        ret = letter_to_bar(line, i);\n\n        if (ret[0] > 0) {\n          // This is definitely a bar\n          if (el.gracenotes !== undefined) {\n            // Attach the grace note to an invisible note\n            el.rest = {\n              type: 'spacer'\n            };\n            el.duration = 0.125; // TODO-PER: I don't think the duration of this matters much, but figure out if it does.\n\n            multilineVars.addFormattingOptions(el, tune.formatting, 'note');\n            tune.appendElement('note', startOfLine + i, startOfLine + i + ret[0], el);\n            multilineVars.measureNotEmpty = true;\n            el = {};\n          }\n\n          var bar = {\n            type: ret[1]\n          };\n          if (bar.type.length === 0) warn(\"Unknown bar type\", line, i);else {\n            if (multilineVars.inEnding && bar.type !== 'bar_thin') {\n              bar.endEnding = true;\n              multilineVars.inEnding = false;\n            }\n\n            if (ret[2]) {\n              bar.startEnding = ret[2];\n              if (multilineVars.inEnding) bar.endEnding = true;\n              multilineVars.inEnding = true;\n            }\n\n            if (el.decoration !== undefined) bar.decoration = el.decoration;\n            if (el.chord !== undefined) bar.chord = el.chord;\n            if (bar.startEnding && multilineVars.barFirstEndingNum === undefined) multilineVars.barFirstEndingNum = multilineVars.currBarNumber;else if (bar.startEnding && bar.endEnding && multilineVars.barFirstEndingNum) multilineVars.currBarNumber = multilineVars.barFirstEndingNum;else if (bar.endEnding) multilineVars.barFirstEndingNum = undefined;\n\n            if (bar.type !== 'bar_invisible' && multilineVars.measureNotEmpty) {\n              var isFirstVoice = multilineVars.currentVoice === undefined || multilineVars.currentVoice.staffNum === 0 && multilineVars.currentVoice.index === 0;\n\n              if (isFirstVoice) {\n                multilineVars.currBarNumber++;\n                if (multilineVars.barNumbers && multilineVars.currBarNumber % multilineVars.barNumbers === 0) bar.barNumber = multilineVars.currBarNumber;\n              }\n            }\n\n            multilineVars.addFormattingOptions(el, tune.formatting, 'bar');\n            tune.appendElement('bar', startOfLine + i, startOfLine + i + ret[0], bar);\n            multilineVars.measureNotEmpty = false;\n            el = {};\n          }\n          i += ret[0];\n        } else if (line[i] === '&') {\n          // backtrack to beginning of measure\n          warn(\"Overlay not yet supported\", line, i);\n          i++;\n        } else {\n          // This is definitely a note group\n          //\n          // Look for as many open slurs and triplets as there are. (Note: only the first triplet is valid.)\n          ret = letter_to_open_slurs_and_triplets(line, i);\n\n          if (ret.consumed > 0) {\n            if (ret.startSlur !== undefined) el.startSlur = ret.startSlur;\n\n            if (ret.triplet !== undefined) {\n              if (tripletNotesLeft > 0) warn(\"Can't nest triplets\", line, i);else {\n                el.startTriplet = ret.triplet;\n                el.tripletMultiplier = ret.tripletQ / ret.triplet;\n                tripletNotesLeft = ret.num_notes === undefined ? ret.triplet : ret.num_notes;\n              }\n            }\n\n            i += ret.consumed;\n          } // handle chords.\n\n\n          if (line.charAt(i) === '[') {\n            var chordStartChar = i;\n            i++;\n            var chordDuration = null;\n            var rememberEndBeam = false;\n            var done = false;\n\n            while (!done) {\n              var accent = letter_to_accent(line, i);\n\n              if (accent[0] > 0) {\n                i += accent[0];\n              }\n\n              var chordNote = getCoreNote(line, i, {}, false);\n\n              if (chordNote !== null) {\n                if (accent[0] > 0) {\n                  // If we found a decoration above, it modifies the entire chord. \"style\" is handled below.\n                  if (accent[1].indexOf(\"style=\") !== 0) {\n                    if (el.decoration === undefined) el.decoration = [];\n                    el.decoration.push(accent[1]);\n                  }\n                }\n\n                if (chordNote.end_beam) {\n                  el.end_beam = true;\n                  delete chordNote.end_beam;\n                }\n\n                if (el.pitches === undefined) {\n                  el.duration = chordNote.duration;\n                  el.pitches = [chordNote];\n                } else // Just ignore the note lengths of all but the first note. The standard isn't clear here, but this seems less confusing.\n                  el.pitches.push(chordNote);\n\n                delete chordNote.duration;\n\n                if (accent[0] > 0) {\n                  // If we found a style above, it modifies the individual pitch, not the entire chord.\n                  if (accent[1].indexOf(\"style=\") === 0) {\n                    el.pitches[el.pitches.length - 1].style = accent[1].substr(6);\n                  }\n                }\n\n                if (multilineVars.inTieChord[el.pitches.length]) {\n                  chordNote.endTie = true;\n                  multilineVars.inTieChord[el.pitches.length] = undefined;\n                }\n\n                if (chordNote.startTie) multilineVars.inTieChord[el.pitches.length] = true;\n                i = chordNote.endChar;\n                delete chordNote.endChar;\n              } else if (line.charAt(i) === ' ') {\n                // Spaces are not allowed in chords, but we can recover from it by ignoring it.\n                warn(\"Spaces are not allowed in chords\", line, i);\n                i++;\n              } else {\n                if (i < line.length && line.charAt(i) === ']') {\n                  // consume the close bracket\n                  i++;\n\n                  if (multilineVars.next_note_duration !== 0) {\n                    el.duration = el.duration * multilineVars.next_note_duration;\n                    multilineVars.next_note_duration = 0;\n                  }\n\n                  if (multilineVars.inTie) {\n                    parseCommon.each(el.pitches, function (pitch) {\n                      pitch.endTie = true;\n                    });\n                    multilineVars.inTie = false;\n                  }\n\n                  if (tripletNotesLeft > 0) {\n                    tripletNotesLeft--;\n\n                    if (tripletNotesLeft === 0) {\n                      el.endTriplet = true;\n                    }\n                  }\n\n                  var postChordDone = false;\n\n                  while (i < line.length && !postChordDone) {\n                    switch (line.charAt(i)) {\n                      case ' ':\n                      case '\\t':\n                        addEndBeam(el);\n                        break;\n\n                      case ')':\n                        if (el.endSlur === undefined) el.endSlur = 1;else el.endSlur++;\n                        break;\n\n                      case '-':\n                        parseCommon.each(el.pitches, function (pitch) {\n                          pitch.startTie = {};\n                        });\n                        multilineVars.inTie = true;\n                        break;\n\n                      case '>':\n                      case '<':\n                        var br2 = getBrokenRhythm(line, i);\n                        i += br2[0] - 1; // index gets incremented below, so we'll let that happen\n\n                        multilineVars.next_note_duration = br2[2];\n                        if (chordDuration) chordDuration = chordDuration * br2[1];else chordDuration = br2[1];\n                        break;\n\n                      case '1':\n                      case '2':\n                      case '3':\n                      case '4':\n                      case '5':\n                      case '6':\n                      case '7':\n                      case '8':\n                      case '9':\n                      case '/':\n                        var fraction = tokenizer.getFraction(line, i);\n                        chordDuration = fraction.value;\n                        i = fraction.index;\n                        if (line.charAt(i) === ' ') rememberEndBeam = true;\n                        if (line.charAt(i) === '-' || line.charAt(i) === ')' || line.charAt(i) === ' ' || line.charAt(i) === '<' || line.charAt(i) === '>') i--; // Subtracting one because one is automatically added below\n                        else postChordDone = true;\n                        break;\n\n                      default:\n                        postChordDone = true;\n                        break;\n                    }\n\n                    if (!postChordDone) {\n                      i++;\n                    }\n                  }\n                } else warn(\"Expected ']' to end the chords\", line, i);\n\n                if (el.pitches !== undefined) {\n                  if (chordDuration !== null) {\n                    el.duration = el.duration * chordDuration;\n                    if (rememberEndBeam) addEndBeam(el);\n                  }\n\n                  multilineVars.addFormattingOptions(el, tune.formatting, 'note');\n                  tune.appendElement('note', startOfLine + chordStartChar, startOfLine + i, el);\n                  multilineVars.measureNotEmpty = true;\n                  el = {};\n                }\n\n                done = true;\n              }\n            }\n          } else {\n            // Single pitch\n            var el2 = {};\n            var core = getCoreNote(line, i, el2, true);\n            if (el2.endTie !== undefined) multilineVars.inTie = true;\n\n            if (core !== null) {\n              if (core.pitch !== undefined) {\n                el.pitches = [{}]; // TODO-PER: straighten this out so there is not so much copying: getCoreNote shouldn't change e'\n\n                if (core.accidental !== undefined) el.pitches[0].accidental = core.accidental;\n                el.pitches[0].pitch = core.pitch;\n                if (core.midipitch) el.pitches[0].midipitch = core.midipitch;\n                if (core.endSlur !== undefined) el.pitches[0].endSlur = core.endSlur;\n                if (core.endTie !== undefined) el.pitches[0].endTie = core.endTie;\n                if (core.startSlur !== undefined) el.pitches[0].startSlur = core.startSlur;\n                if (el.startSlur !== undefined) el.pitches[0].startSlur = el.startSlur;\n                if (core.startTie !== undefined) el.pitches[0].startTie = core.startTie;\n                if (el.startTie !== undefined) el.pitches[0].startTie = el.startTie;\n              } else {\n                el.rest = core.rest;\n                if (core.endSlur !== undefined) el.endSlur = core.endSlur;\n                if (core.endTie !== undefined) el.rest.endTie = core.endTie;\n                if (core.startSlur !== undefined) el.startSlur = core.startSlur;\n                if (core.startTie !== undefined) el.rest.startTie = core.startTie;\n                if (el.startTie !== undefined) el.rest.startTie = el.startTie;\n              }\n\n              if (core.chord !== undefined) el.chord = core.chord;\n              if (core.duration !== undefined) el.duration = core.duration;\n              if (core.decoration !== undefined) el.decoration = core.decoration;\n              if (core.graceNotes !== undefined) el.graceNotes = core.graceNotes;\n              delete el.startSlur;\n\n              if (multilineVars.inTie) {\n                if (el.pitches !== undefined) {\n                  el.pitches[0].endTie = true;\n                  multilineVars.inTie = false;\n                } else if (el.rest.type !== 'spacer') {\n                  el.rest.endTie = true;\n                  multilineVars.inTie = false;\n                }\n              }\n\n              if (core.startTie || el.startTie) multilineVars.inTie = true;\n              i = core.endChar;\n\n              if (tripletNotesLeft > 0) {\n                tripletNotesLeft--;\n\n                if (tripletNotesLeft === 0) {\n                  el.endTriplet = true;\n                }\n              }\n\n              if (core.end_beam) addEndBeam(el); // If there is a whole rest, then it should be the duration of the measure, not it's own duration. We need to special case it.\n\n              if (el.rest && el.rest.type === 'rest' && el.duration === 1) {\n                el.rest.type = 'whole';\n                el.duration = durationOfMeasure(multilineVars);\n              }\n\n              multilineVars.addFormattingOptions(el, tune.formatting, 'note');\n              tune.appendElement('note', startOfLine + startI, startOfLine + i, el);\n              multilineVars.measureNotEmpty = true;\n              el = {};\n            }\n          }\n\n          if (i === startI) {\n            // don't know what this is, so ignore it.\n            if (line.charAt(i) !== ' ' && line.charAt(i) !== '`') warn(\"Unknown character ignored\", line, i);\n            i++;\n          }\n        }\n      }\n    }\n  };\n\n  var parseLine = function (line) {\n    var ret = header.parseHeader(line);\n    if (ret.regular) parseRegularMusicLine(ret.str);\n    if (ret.newline && multilineVars.continueall === undefined) startNewLine();\n    if (ret.words) addWords(tune.getCurrentVoice(), line.substring(2));\n    if (ret.symbols) addSymbols(tune.getCurrentVoice(), line.substring(2));\n    if (ret.recurse) parseLine(ret.str);\n  };\n\n  function appendLastMeasure(voice, nextVoice) {\n    voice.push({\n      el_type: 'hint'\n    });\n\n    for (var i = 0; i < nextVoice.length; i++) {\n      var element = nextVoice[i];\n      var hint = parseCommon.clone(element);\n      voice.push(hint);\n      if (element.el_type === 'bar') return;\n    }\n  }\n\n  function addHintMeasure(staff, nextStaff) {\n    for (var i = 0; i < staff.length; i++) {\n      var stave = staff[i];\n      var nextStave = nextStaff[i];\n\n      if (nextStave) {\n        // Be sure there is the same number of staves on the next line.\n        for (var j = 0; j < nextStave.voices.length; j++) {\n          var nextVoice = nextStave.voices[j];\n          var voice = stave.voices[j];\n\n          if (voice) {\n            // Be sure there are the same number of voices on the previous line.\n            appendLastMeasure(voice, nextVoice);\n          }\n        }\n      }\n    }\n  }\n\n  function addHintMeasures() {\n    for (var i = 0; i < tune.lines.length; i++) {\n      var line = tune.lines[i].staff;\n\n      if (line) {\n        var j = i + 1;\n\n        while (j < tune.lines.length && tune.lines[j].staff === undefined) j++;\n\n        if (j < tune.lines.length) {\n          var nextLine = tune.lines[j].staff;\n          addHintMeasure(line, nextLine);\n        }\n      }\n    }\n  }\n\n  this.parse = function (strTune, switches) {\n    // the switches are optional and cause a difference in the way the tune is parsed.\n    // switches.header_only : stop parsing when the header is finished\n    // switches.stop_on_warning : stop at the first warning encountered.\n    // switches.print: format for the page instead of the browser.\n    // switches.format: a hash of the desired formatting commands.\n    // switches.hint_measures: put the next measure at the end of the current line.\n    // switches.transpose: change the key signature, chords, and notes by a number of half-steps.\n    if (!switches) switches = {};\n    tune.reset();\n    if (switches.print) tune.media = 'print';\n    multilineVars.reset();\n\n    if (switches.visualTranspose) {\n      multilineVars.globalTranspose = parseInt(switches.visualTranspose);\n      if (multilineVars.globalTranspose === 0) multilineVars.globalTranspose = undefined;\n    } else multilineVars.globalTranspose = undefined;\n\n    header.reset(tokenizer, warn, multilineVars, tune); // Take care of whatever line endings come our way\n\n    strTune = parseCommon.gsub(strTune, '\\r\\n', '\\n');\n    strTune = parseCommon.gsub(strTune, '\\r', '\\n');\n    strTune += '\\n'; // Tacked on temporarily to make the last line continuation work\n\n    strTune = strTune.replace(/\\n\\\\.*\\n/g, \"\\n\"); // get rid of latex commands.\n\n    var continuationReplacement = function (all, backslash, comment) {\n      var spaces = \"                                                                                                                                                                                                     \";\n      var padding = comment ? spaces.substring(0, comment.length) : \"\";\n      return backslash + \" \\x12\" + padding;\n    };\n\n    strTune = strTune.replace(/\\\\([ \\t]*)(%.*)*\\n/g, continuationReplacement); // take care of line continuations right away, but keep the same number of characters\n\n    var lines = strTune.split('\\n');\n    if (parseCommon.last(lines).length === 0) // remove the blank line we added above.\n      lines.pop();\n\n    try {\n      if (switches.format) {\n        parseDirective.globalFormatting(switches.format);\n      }\n\n      parseCommon.each(lines, function (line) {\n        if (switches.header_only && multilineVars.is_in_header === false) throw \"normal_abort\";\n        if (switches.stop_on_warning && multilineVars.warnings) throw \"normal_abort\";\n\n        if (multilineVars.is_in_history) {\n          if (line.charAt(1) === ':') {\n            multilineVars.is_in_history = false;\n            parseLine(line);\n          } else tune.addMetaText(\"history\", tokenizer.translateString(tokenizer.stripComment(line)));\n        } else if (multilineVars.inTextBlock) {\n          if (parseCommon.startsWith(line, \"%%endtext\")) {\n            //tune.addMetaText(\"textBlock\", multilineVars.textBlock);\n            tune.addText(multilineVars.textBlock);\n            multilineVars.inTextBlock = false;\n          } else {\n            if (parseCommon.startsWith(line, \"%%\")) multilineVars.textBlock += ' ' + line.substring(2);else multilineVars.textBlock += ' ' + line;\n          }\n        } else if (multilineVars.inPsBlock) {\n          if (parseCommon.startsWith(line, \"%%endps\")) {\n            // Just ignore postscript\n            multilineVars.inPsBlock = false;\n          } else multilineVars.textBlock += ' ' + line;\n        } else parseLine(line);\n\n        multilineVars.iChar += line.length + 1;\n      });\n      var ph = 11 * 72;\n      var pl = 8.5 * 72;\n\n      switch (multilineVars.papersize) {\n        //case \"letter\": ph = 11*72; pl = 8.5*72; break;\n        case \"legal\":\n          ph = 14 * 72;\n          pl = 8.5 * 72;\n          break;\n\n        case \"A4\":\n          ph = 11.7 * 72;\n          pl = 8.3 * 72;\n          break;\n      }\n\n      if (multilineVars.landscape) {\n        var x = ph;\n        ph = pl;\n        pl = x;\n      }\n\n      multilineVars.openSlurs = tune.cleanUp(pl, ph, multilineVars.barsperstaff, multilineVars.staffnonote, multilineVars.openSlurs);\n    } catch (err) {\n      if (err !== \"normal_abort\") throw err;\n    }\n\n    if (switches.hint_measures) {\n      addHintMeasures();\n    }\n  };\n};\n\nmodule.exports = Parse;","map":{"version":3,"sources":["/Users/philbrockman/coding/MusicalGens/app/http/web/app/node_modules/abcjs/src/parse/abc_parse.js"],"names":["parseCommon","require","parseDirective","ParseHeader","parseKeyVoice","Tokenizer","transpose","Tune","Parse","tune","tokenizer","getTune","addPositioning","el","type","value","positioning","addFont","fonts","multilineVars","reset","property","hasOwnProperty","iChar","key","accidentals","root","acc","mode","meter","origMeter","hasMainTitle","default_length","clef","verticalPos","next_note_duration","start_new_line","is_in_header","is_in_history","partForNextLine","havent_set_length","voices","staves","macros","currBarNumber","inTextBlock","inPsBlock","ignoredDecorations","textBlock","score_is_present","inEnding","inTie","inTieChord","vocalPosition","dynamicPosition","chordPosition","ornamentPosition","volumePosition","openSlurs","differentFont","defaultFonts","decoration","face","size","style","weight","addFormattingOptions","elType","annotationfont","gchordfont","vocalfont","measurefont","repeatfont","addWarning","str","warnings","push","addWarningObject","warningObject","warningObjects","encode","ret","gsub","warn","line","col_num","bad_char","charAt","clean_line","substring","getNumLines","message","startChar","column","header","getWarnings","getWarningObjects","letter_to_chord","i","chord","getBrackettedSubstring","length","x","getFloat","digits","y","ws","skipWhiteSpace","replace","chordName","legalAccents","volumeDecorations","dynamicDecorations","accentPseudonyms","accentDynamicPseudonyms","letter_to_accent","macro","undefined","detect","dec","letter_to_spacer","start","isWhiteSpace","letter_to_bar","curr_pos","getBarLine","len","orig_bar_len","ending","token","retRep","getTokenOf","tripletQ","letter_to_open_slurs_and_triplets","triplet","num_notes","startSlur","consumed","addWords","words","strip","word_list","last_divider","addWord","word","div","syllable","translateString","divider","last","skip","to","inSlur","each","el_type","pitches","shift","lyric","rest","addSymbols","getBrokenRhythm","index","addEndBeam","duration","end_beam","A","B","C","D","E","F","G","a","b","c","d","e","f","g","rests","z","Z","getCoreNote","canHaveBrokenRhythm","isComplete","state","durationSetByPreviousNote","endChar","endSlur","accidental","pitch","note","currentVoice","accMap","formatting","midi","drummap","midipitch","startTie","endTie","grace_notes","fraction","getFraction","num","getNumber","addTieToLastNote","br2","startNewLine","params","part","staffNum","clone","scoreTranspose","standardKey","impliedNaturals","explicitAccidentals","found","j","addPosToKey","st","name","staff","brace","bracket","connectBarLines","subname","stem","stafflines","staffscale","scale","isFirstVoice","barNumbers","barNumber","letter_to_grace","gra","gracenotes","ii","acciaccatura","letter_to_overlay","durationOfMeasure","parseInt","den","nonDecorations","parseRegularMusicLine","resolveTempo","startOfLine","delayStartNewLine","continueall","tripletNotesLeft","retHeader","letter_to_body_header","startI","retInlineHeader","letter_to_inline_header","eatWhiteSpace","appendElement","addedChord","ci","position","rel_position","force_end_beam_last","indexOf","substr","measureNotEmpty","bar","endEnding","startEnding","barFirstEndingNum","startTriplet","tripletMultiplier","chordStartChar","chordDuration","rememberEndBeam","done","accent","chordNote","endTriplet","postChordDone","el2","core","graceNotes","parseLine","parseHeader","regular","newline","getCurrentVoice","symbols","recurse","appendLastMeasure","voice","nextVoice","element","hint","addHintMeasure","nextStaff","stave","nextStave","addHintMeasures","lines","nextLine","parse","strTune","switches","print","media","visualTranspose","globalTranspose","continuationReplacement","all","backslash","comment","spaces","padding","split","pop","format","globalFormatting","header_only","stop_on_warning","addMetaText","stripComment","startsWith","addText","ph","pl","papersize","landscape","cleanUp","barsperstaff","staffnonote","err","hint_measures","module","exports"],"mappings":"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","sourcesContent":["//    abc_parse.js: parses a string representing ABC Music Notation into a usable internal structure.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*global window */\n\nvar parseCommon = require('./abc_common');\nvar parseDirective = require('./abc_parse_directive');\nvar ParseHeader = require('./abc_parse_header');\nvar parseKeyVoice = require('./abc_parse_key_voice');\nvar Tokenizer = require('./abc_tokenizer');\nvar transpose = require('./abc_transpose');\n\nvar Tune = require('../data/abc_tune');\n\nvar Parse = function() {\n\t\"use strict\";\n\tvar tune = new Tune();\n\tvar tokenizer = new Tokenizer();\n\n\tthis.getTune = function() {\n\t\treturn tune;\n\t};\n\n\tfunction addPositioning(el, type, value) {\n\t\tif (!el.positioning) el.positioning = {};\n\t\tel.positioning[type] = value;\n\t}\n\n\tfunction addFont(el, type, value) {\n\t\tif (!el.fonts) el.fonts = {};\n\t\tel.fonts[type] = value;\n\t}\n\n\tvar multilineVars = {\n\t\treset: function() {\n\t\t\tfor (var property in this) {\n\t\t\t\tif (this.hasOwnProperty(property) && typeof this[property] !== \"function\") {\n\t\t\t\t\tdelete this[property];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.iChar = 0;\n\t\t\tthis.key = {accidentals: [], root: 'none', acc: '', mode: '' };\n\t\t\tthis.meter = null; // if no meter is specified, free meter is assumed\n\t\t\tthis.origMeter = null;\t// this is for new voices that are created after we set the meter.\n\t\t\tthis.hasMainTitle = false;\n\t\t\tthis.default_length = 0.125;\n\t\t\tthis.clef = { type: 'treble', verticalPos: 0 };\n\t\t\tthis.next_note_duration = 0;\n\t\t\tthis.start_new_line = true;\n\t\t\tthis.is_in_header = true;\n\t\t\tthis.is_in_history = false;\n\t\t\tthis.partForNextLine = \"\";\n\t\t\tthis.havent_set_length = true;\n\t\t\tthis.voices = {};\n\t\t\tthis.staves = [];\n\t\t\tthis.macros = {};\n\t\t\tthis.currBarNumber = 1;\n\t\t\tthis.inTextBlock = false;\n\t\t\tthis.inPsBlock = false;\n\t\t\tthis.ignoredDecorations = [];\n\t\t\tthis.textBlock = \"\";\n\t\t\tthis.score_is_present = false;\t// Can't have original V: lines when there is the score directive\n\t\t\tthis.inEnding = false;\n\t\t\tthis.inTie = false;\n\t\t\tthis.inTieChord = {};\n\t\t\tthis.vocalPosition = \"auto\";\n\t\t\tthis.dynamicPosition = \"auto\";\n\t\t\tthis.chordPosition = \"auto\";\n\t\t\tthis.ornamentPosition = \"auto\";\n\t\t\tthis.volumePosition = \"auto\";\n\t\t\tthis.openSlurs = [];\n\t\t},\n\t\tdifferentFont: function(type, defaultFonts) {\n\t\t\tif (this[type].decoration !== defaultFonts[type].decoration) return true;\n\t\t\tif (this[type].face !== defaultFonts[type].face) return true;\n\t\t\tif (this[type].size !== defaultFonts[type].size) return true;\n\t\t\tif (this[type].style !== defaultFonts[type].style) return true;\n\t\t\tif (this[type].weight !== defaultFonts[type].weight) return true;\n\t\t\treturn false;\n\t\t},\n\t\taddFormattingOptions: function(el, defaultFonts, elType) {\n\t\t\tif (elType === 'note') {\n\t\t\t\tif (this.vocalPosition !== 'auto') addPositioning(el, 'vocalPosition', this.vocalPosition);\n\t\t\t\tif (this.dynamicPosition !== 'auto') addPositioning(el, 'dynamicPosition', this.dynamicPosition);\n\t\t\t\tif (this.chordPosition !== 'auto') addPositioning(el, 'chordPosition', this.chordPosition);\n\t\t\t\tif (this.ornamentPosition !== 'auto') addPositioning(el, 'ornamentPosition', this.ornamentPosition);\n\t\t\t\tif (this.volumePosition !== 'auto') addPositioning(el, 'volumePosition', this.volumePosition);\n\t\t\t\tif (this.differentFont(\"annotationfont\", defaultFonts)) addFont(el, 'annotationfont', this.annotationfont);\n\t\t\t\tif (this.differentFont(\"gchordfont\", defaultFonts)) addFont(el, 'gchordfont', this.gchordfont);\n\t\t\t\tif (this.differentFont(\"vocalfont\", defaultFonts)) addFont(el, 'vocalfont', this.vocalfont);\n\t\t\t} else if (elType === 'bar') {\n\t\t\t\tif (this.dynamicPosition !== 'auto') addPositioning(el, 'dynamicPosition', this.dynamicPosition);\n\t\t\t\tif (this.chordPosition !== 'auto') addPositioning(el, 'chordPosition', this.chordPosition);\n\t\t\t\tif (this.ornamentPosition !== 'auto') addPositioning(el, 'ornamentPosition', this.ornamentPosition);\n\t\t\t\tif (this.volumePosition !== 'auto') addPositioning(el, 'volumePosition', this.volumePosition);\n\t\t\t\tif (this.differentFont(\"measurefont\", defaultFonts)) addFont(el, 'measurefont', this.measurefont);\n\t\t\t\tif (this.differentFont(\"repeatfont\", defaultFonts)) addFont(el, 'repeatfont', this.repeatfont);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar addWarning = function(str) {\n\t\tif (!multilineVars.warnings)\n\t\t\tmultilineVars.warnings = [];\n\t\tmultilineVars.warnings.push(str);\n\t};\n\n\tvar addWarningObject = function(warningObject) {\n\t\tif (!multilineVars.warningObjects)\n\t\t\tmultilineVars.warningObjects = [];\n\t\tmultilineVars.warningObjects.push(warningObject);\n\t};\n\n\tvar encode = function(str) {\n\t\tvar ret = parseCommon.gsub(str, '\\x12', ' ');\n\t\tret = parseCommon.gsub(ret, '&', '&amp;');\n\t\tret = parseCommon.gsub(ret, '<', '&lt;');\n\t\treturn parseCommon.gsub(ret, '>', '&gt;');\n\t};\n\n\tvar warn = function(str, line, col_num) {\n\t\tif (!line) line = \" \";\n\t\tvar bad_char = line.charAt(col_num);\n\t\tif (bad_char === ' ')\n\t\t\tbad_char = \"SPACE\";\n\t\tvar clean_line = encode(line.substring(0, col_num)) +\n\t\t\t'<span style=\"text-decoration:underline;font-size:1.3em;font-weight:bold;\">' + bad_char + '</span>' +\n\t\t\tencode(line.substring(col_num+1));\n\t\taddWarning(\"Music Line:\" + tune.getNumLines() + \":\" + (col_num+1) + ': ' + str + \":  \" + clean_line);\n\t\taddWarningObject({message:str, line:line, startChar: multilineVars.iChar + col_num, column: col_num});\n\t};\n\tvar header = new ParseHeader(tokenizer, warn, multilineVars, tune);\n\n\tthis.getWarnings = function() {\n\t\treturn multilineVars.warnings;\n\t};\n\tthis.getWarningObjects = function() {\n\t\treturn multilineVars.warningObjects;\n\t};\n\n\tvar letter_to_chord = function(line, i)\n\t{\n\t\tif (line.charAt(i) === '\"')\n\t\t{\n\t\t\tvar chord = tokenizer.getBrackettedSubstring(line, i, 5);\n\t\t\tif (!chord[2])\n\t\t\t\twarn(\"Missing the closing quote while parsing the chord symbol\", line , i);\n\t\t\t// If it starts with ^, then the chord appears above.\n\t\t\t// If it starts with _ then the chord appears below.\n\t\t\t// (note that the 2.0 draft standard defines them as not chords, but annotations and also defines @.)\n\t\t\tif (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '^') {\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tchord[2] = 'above';\n\t\t\t} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '_') {\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tchord[2] = 'below';\n\t\t\t} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '<') {\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tchord[2] = 'left';\n\t\t\t} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '>') {\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tchord[2] = 'right';\n\t\t\t} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '@') {\n\t\t\t\t// @-15,5.7\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tvar x = tokenizer.getFloat(chord[1]);\n\t\t\t\tif (x.digits === 0)\n\t\t\t\t\twarn(\"Missing first position in absolutely positioned annotation.\", line , i);\n\t\t\t\tchord[1] = chord[1].substring(x.digits);\n\t\t\t\tif (chord[1][0] !== ',')\n\t\t\t\t\twarn(\"Missing comma absolutely positioned annotation.\", line , i);\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tvar y = tokenizer.getFloat(chord[1]);\n\t\t\t\tif (y.digits === 0)\n\t\t\t\t\twarn(\"Missing second position in absolutely positioned annotation.\", line , i);\n\t\t\t\tchord[1] = chord[1].substring(y.digits);\n\t\t\t\tvar ws = tokenizer.skipWhiteSpace(chord[1]);\n\t\t\t\tchord[1] = chord[1].substring(ws);\n\t\t\t\tchord[2] = null;\n\t\t\t\tchord[3] = { x: x.value, y: y.value };\n\t\t\t} else {\n\t\t\t\tchord[1] = chord[1].replace(/([ABCDEFG])b/g, \"$1♭\");\n\t\t\t\tchord[1] = chord[1].replace(/([ABCDEFG])#/g, \"$1♯\");\n\t\t\t\tchord[2] = 'default';\n\t\t\t\tchord[1] = transpose.chordName(multilineVars, chord[1]);\n\t\t\t}\n\t\t\treturn chord;\n\t\t}\n\t\treturn [0, \"\"];\n\t};\n\n\tvar legalAccents = [ \"trill\", \"lowermordent\", \"uppermordent\", \"mordent\", \"pralltriller\", \"accent\",\n\t\t\"fermata\", \"invertedfermata\", \"tenuto\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"+\", \"wedge\",\n\t\t\"open\", \"thumb\", \"snap\", \"turn\", \"roll\", \"breath\", \"shortphrase\", \"mediumphrase\", \"longphrase\",\n\t\t\"segno\", \"coda\", \"D.S.\", \"D.C.\", \"fine\",\n\t\t\"slide\", \"^\", \"marcato\",\n\t\t\"upbow\", \"downbow\", \"/\", \"//\", \"///\", \"////\", \"trem1\", \"trem2\", \"trem3\", \"trem4\",\n\t\t\"turnx\", \"invertedturn\", \"invertedturnx\", \"trill(\", \"trill)\", \"arpeggio\", \"xstem\", \"mark\", \"umarcato\",\n\t\t\"style=normal\", \"style=harmonic\", \"style=rhythm\", \"style=x\"\n\t];\n\tvar volumeDecorations = [ \"p\", \"pp\", \"f\", \"ff\", \"mf\", \"mp\", \"ppp\", \"pppp\",  \"fff\", \"ffff\", \"sfz\" ];\n\tvar dynamicDecorations = [\"crescendo(\", \"crescendo)\", \"diminuendo(\", \"diminuendo)\"];\n\n\tvar accentPseudonyms = [ [\"<\", \"accent\"], [\">\", \"accent\"], [\"tr\", \"trill\"],\n\t\t[\"plus\", \"+\"], [ \"emphasis\", \"accent\"],\n\t\t[ \"^\", \"umarcato\" ], [ \"marcato\", \"umarcato\" ] ];\n\tvar accentDynamicPseudonyms = [ [\"<(\", \"crescendo(\"], [\"<)\", \"crescendo)\"],\n\t\t[\">(\", \"diminuendo(\"], [\">)\", \"diminuendo)\"] ];\n\tvar letter_to_accent = function(line, i)\n\t{\n\t\tvar macro = multilineVars.macros[line.charAt(i)];\n\n\t\tif (macro !== undefined) {\n\t\t\tif (macro.charAt(0) === '!' || macro.charAt(0) === '+')\n\t\t\t\tmacro = macro.substring(1);\n\t\t\tif (macro.charAt(macro.length-1) === '!' || macro.charAt(macro.length-1) === '+')\n\t\t\t\tmacro = macro.substring(0, macro.length-1);\n\t\t\tif (parseCommon.detect(legalAccents, function(acc) {\n\t\t\t\t\treturn (macro === acc);\n\t\t\t\t}))\n\t\t\t\treturn [ 1, macro ];\n\t\t\telse if (parseCommon.detect(volumeDecorations, function(acc) {\n\t\t\t\t\treturn (macro === acc);\n\t\t\t\t})) {\n\t\t\t\tif (multilineVars.volumePosition === 'hidden')\n\t\t\t\t\tmacro = \"\";\n\t\t\t\treturn [1, macro];\n\t\t\t} else if (parseCommon.detect(dynamicDecorations, function(acc) {\n\t\t\t\t\tif (multilineVars.dynamicPosition === 'hidden')\n\t\t\t\t\t\tmacro = \"\";\n\t\t\t\t\treturn (macro === acc);\n\t\t\t\t})) {\n\t\t\t\treturn [1, macro];\n\t\t\t} else {\n\t\t\t\tif (!parseCommon.detect(multilineVars.ignoredDecorations, function(dec) {\n\t\t\t\t\treturn (macro === dec);\n\t\t\t\t}))\n\t\t\t\t\twarn(\"Unknown macro: \" + macro, line, i);\n\t\t\t\treturn [1, '' ];\n\t\t\t}\n\t\t}\n\t\tswitch (line.charAt(i))\n\t\t{\n\t\t\tcase '.':return [1, 'staccato'];\n\t\t\tcase 'u':return [1, 'upbow'];\n\t\t\tcase 'v':return [1, 'downbow'];\n\t\t\tcase '~':return [1, 'irishroll'];\n\t\t\tcase '!':\n\t\t\tcase '+':\n\t\t\t\tvar ret = tokenizer.getBrackettedSubstring(line, i, 5);\n\t\t\t\t// Be sure that the accent is recognizable.\n\t\t\tif (ret[1].length > 0 && (ret[1].charAt(0) === '^' || ret[1].charAt(0) ==='_'))\n\t\t\t\t\tret[1] = ret[1].substring(1);\t// TODO-PER: The test files have indicators forcing the ornament to the top or bottom, but that isn't in the standard. We'll just ignore them.\n\t\t\t\tif (parseCommon.detect(legalAccents, function(acc) {\n\t\t\t\t\treturn (ret[1] === acc);\n\t\t\t\t}))\n\t\t\t\t\treturn ret;\n\t\t\t\tif (parseCommon.detect(volumeDecorations, function(acc) {\n\t\t\t\t\t\treturn (ret[1] === acc);\n\t\t\t\t\t})) {\n\t\t\t\t\tif (multilineVars.volumePosition === 'hidden' )\n\t\t\t\t\t\tret[1] = '';\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tif (parseCommon.detect(dynamicDecorations, function(acc) {\n\t\t\t\t\t\treturn (ret[1] === acc);\n\t\t\t\t\t})) {\n\t\t\t\t\tif (multilineVars.dynamicPosition === 'hidden' )\n\t\t\t\t\t\tret[1] = '';\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tif (parseCommon.detect(accentPseudonyms, function(acc) {\n\t\t\t\t\tif (ret[1] === acc[0]) {\n\t\t\t\t\t\tret[1] = acc[1];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn false;\n\t\t\t\t}))\n\t\t\t\t\treturn ret;\n\n\t\t\t\tif (parseCommon.detect(accentDynamicPseudonyms, function(acc) {\n\t\t\t\t\tif (ret[1] === acc[0]) {\n\t\t\t\t\t\tret[1] = acc[1];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn false;\n\t\t\t\t})) {\n\t\t\t\t\tif (multilineVars.dynamicPosition === 'hidden' )\n\t\t\t\t\t\tret[1] = '';\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\t// We didn't find the accent in the list, so consume the space, but don't return an accent.\n\t\t\t\t// Although it is possible that ! was used as a line break, so accept that.\n\t\t\tif (line.charAt(i) === '!' && (ret[0] === 1 || line.charAt(i+ret[0]-1) !== '!'))\n\t\t\t\t\treturn [1, null ];\n\t\t\t\twarn(\"Unknown decoration: \" + ret[1], line, i);\n\t\t\t\tret[1] = \"\";\n\t\t\t\treturn ret;\n\t\t\tcase 'H':return [1, 'fermata'];\n\t\t\tcase 'J':return [1, 'slide'];\n\t\t\tcase 'L':return [1, 'accent'];\n\t\t\tcase 'M':return [1, 'mordent'];\n\t\t\tcase 'O':return[1, 'coda'];\n\t\t\tcase 'P':return[1, 'pralltriller'];\n\t\t\tcase 'R':return [1, 'roll'];\n\t\t\tcase 'S':return [1, 'segno'];\n\t\t\tcase 'T':return [1, 'trill'];\n\t\t}\n\t\treturn [0, 0];\n\t};\n\n\tvar letter_to_spacer = function(line, i)\n\t{\n\t\tvar start = i;\n\t\twhile (tokenizer.isWhiteSpace(line.charAt(i)))\n\t\t\ti++;\n\t\treturn [ i-start ];\n\t};\n\n\t// returns the class of the bar line\n\t// the number of the repeat\n\t// and the number of characters used up\n\t// if 0 is returned, then the next element was not a bar line\n\tvar letter_to_bar = function(line, curr_pos)\n\t{\n\t\tvar ret = tokenizer.getBarLine(line, curr_pos);\n\t\tif (ret.len === 0)\n\t\t\treturn [0,\"\"];\n\t\tif (ret.warn) {\n\t\t\twarn(ret.warn, line, curr_pos);\n\t\t\treturn [ret.len,\"\"];\n\t\t}\n\n\t\t// Now see if this is a repeated ending\n\t\t// A repeated ending is all of the characters 1,2,3,4,5,6,7,8,9,0,-, and comma\n\t\t// It can also optionally start with '[', which is ignored.\n\t\t// Also, it can have white space before the '['.\n\t\tfor (var ws = 0; ws < line.length; ws++)\n\t\t\tif (line.charAt(curr_pos + ret.len + ws) !== ' ')\n\t\t\t\tbreak;\n\t\tvar orig_bar_len = ret.len;\n\t\tif (line.charAt(curr_pos+ret.len+ws) === '[') {\n\t\t\tret.len += ws + 1;\n\t\t}\n\n\t\t// It can also be a quoted string. It is unclear whether that construct requires '[', but it seems like it would. otherwise it would be confused with a regular chord.\n\t\tif (line.charAt(curr_pos+ret.len) === '\"' && line.charAt(curr_pos+ret.len-1) === '[') {\n\t\t\tvar ending = tokenizer.getBrackettedSubstring(line, curr_pos+ret.len, 5);\n\t\t\treturn [ret.len+ending[0], ret.token, ending[1]];\n\t\t}\n\t\tvar retRep = tokenizer.getTokenOf(line.substring(curr_pos+ret.len), \"1234567890-,\");\n\t\tif (retRep.len === 0 || retRep.token[0] === '-')\n\t\t\treturn [orig_bar_len, ret.token];\n\n\t\treturn [ret.len+retRep.len, ret.token, retRep.token];\n\t};\n\n\tvar tripletQ = {\n\t\t2: 3,\n\t\t3: 2,\n\t\t4: 3,\n\t\t5: 2, // TODO-PER: not handling 6/8 rhythm yet\n\t\t6: 2,\n\t\t7: 2, // TODO-PER: not handling 6/8 rhythm yet\n\t\t8: 3,\n\t\t9: 2 // TODO-PER: not handling 6/8 rhythm yet\n\t};\n\tvar letter_to_open_slurs_and_triplets =  function(line, i) {\n\t\t// consume spaces, and look for all the open parens. If there is a number after the open paren,\n\t\t// that is a triplet. Otherwise that is a slur. Collect all the slurs and the first triplet.\n\t\tvar ret = {};\n\t\tvar start = i;\n\t\twhile (line.charAt(i) === '(' || tokenizer.isWhiteSpace(line.charAt(i))) {\n\t\t\tif (line.charAt(i) === '(') {\n\t\t\t\tif (i+1 < line.length && (line.charAt(i+1) >= '2' && line.charAt(i+1) <= '9')) {\n\t\t\t\t\tif (ret.triplet !== undefined)\n\t\t\t\t\t\twarn(\"Can't nest triplets\", line, i);\n\t\t\t\t\telse {\n\t\t\t\t\t\tret.triplet = line.charAt(i+1) - '0';\n\t\t\t\t\t\tret.tripletQ = tripletQ[ret.triplet];\n\t\t\t\t\t\tret.num_notes = ret.triplet;\n\t\t\t\t\t\tif (i+2 < line.length && line.charAt(i+2) === ':') {\n\t\t\t\t\t\t\t// We are expecting \"(p:q:r\" or \"(p:q\" or \"(p::r\"\n\t\t\t\t\t\t\t// That is: \"put p notes into the time of q for the next r notes\"\n\t\t\t\t\t\t\t// if r is missing, then it is equal to p.\n\t\t\t\t\t\t\t// if q is missing, it is determined from this table:\n\t\t\t\t\t\t\t// (2 notes in the time of 3\n\t\t\t\t\t\t\t// (3 notes in the time of 2\n\t\t\t\t\t\t\t// (4 notes in the time of 3\n\t\t\t\t\t\t\t// (5 notes in the time of n | if time sig is (6/8, 9/8, 12/8), n=3, else n=2\n\t\t\t\t\t\t\t// (6 notes in the time of 2\n\t\t\t\t\t\t\t// (7 notes in the time of n\n\t\t\t\t\t\t\t// (8 notes in the time of 3\n\t\t\t\t\t\t\t// (9 notes in the time of n\n\t\t\t\t\t\t\tif (i+3 < line.length && line.charAt(i+3) === ':') {\n\t\t\t\t\t\t\t\t// The second number, 'q', is not present.\n\t\t\t\t\t\t\t\tif (i+4 < line.length && (line.charAt(i+4) >= '1' && line.charAt(i+4) <= '9')) {\n\t\t\t\t\t\t\t\t\tret.num_notes = line.charAt(i+4) - '0';\n\t\t\t\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\twarn(\"expected number after the two colons after the triplet to mark the duration\", line, i);\n\t\t\t\t\t\t\t} else if (i+3 < line.length && (line.charAt(i+3) >= '1' && line.charAt(i+3) <= '9')) {\n\t\t\t\t\t\t\t\tret.tripletQ = line.charAt(i+3) - '0';\n\t\t\t\t\t\t\t\tif (i+4 < line.length && line.charAt(i+4) === ':') {\n\t\t\t\t\t\t\t\t\tif (i+5 < line.length && (line.charAt(i+5) >= '1' && line.charAt(i+5) <= '9')) {\n\t\t\t\t\t\t\t\t\t\tret.num_notes = line.charAt(i+5) - '0';\n\t\t\t\t\t\t\t\t\t\ti += 4;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\twarn(\"expected number after the triplet to mark the duration\", line, i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ret.startSlur === undefined)\n\t\t\t\t\t\tret.startSlur = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tret.startSlur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tret.consumed = i-start;\n\t\treturn ret;\n\t};\n\n\tvar addWords = function(line, words) {\n\t\tif (!line) { warn(\"Can't add words before the first line of music\", line, 0); return; }\n\t\twords = parseCommon.strip(words);\n\t\tif (words.charAt(words.length-1) !== '-')\n\t\t\twords = words + ' ';\t// Just makes it easier to parse below, since every word has a divider after it.\n\t\tvar word_list = [];\n\t\t// first make a list of words from the string we are passed. A word is divided on either a space or dash.\n\t\tvar last_divider = 0;\n\t\tvar replace = false;\n\t\tvar addWord = function(i) {\n\t\t\tvar word = parseCommon.strip(words.substring(last_divider, i));\n\t\t\tlast_divider = i+1;\n\t\t\tif (word.length > 0) {\n\t\t\t\tif (replace)\n\t\t\t\t\tword = parseCommon.gsub(word,'~', ' ');\n\t\t\t\tvar div = words.charAt(i);\n\t\t\t\tif (div !== '_' && div !== '-')\n\t\t\t\t\tdiv = ' ';\n\t\t\t\tword_list.push({syllable: tokenizer.translateString(word), divider: div});\n\t\t\t\treplace = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; i < words.length; i++) {\n\t\t\tswitch (words.charAt(i)) {\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\x12':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif (!addWord(i) && word_list.length > 0) {\n\t\t\t\t\t\tparseCommon.last(word_list).divider = '-';\n\t\t\t\t\t\tword_list.push({skip: true, to: 'next'});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'slur'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'next'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'bar'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '~':\n\t\t\t\t\treplace = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvar inSlur = false;\n\t\tparseCommon.each(line, function(el) {\n\t\t\tif (word_list.length !== 0) {\n\t\t\t\tif (word_list[0].skip) {\n\t\t\t\t\tswitch (word_list[0].to) {\n\t\t\t\t\t\tcase 'next': if (el.el_type === 'note' && el.pitches !== null && !inSlur) word_list.shift(); break;\n\t\t\t\t\t\tcase 'slur': if (el.el_type === 'note' && el.pitches !== null) word_list.shift(); break;\n\t\t\t\t\t\tcase 'bar': if (el.el_type === 'bar') word_list.shift(); break;\n\t\t\t\t\t}\n\t\t\t\t\tif (el.el_type !== 'bar') {\n\t\t\t\t\t\tif (el.lyric === undefined)\n\t\t\t\t\t\t\tel.lyric = [{syllable: \"\", divider: \" \"}];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tel.lyric.push({syllable: \"\", divider: \" \"});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (el.el_type === 'note' && el.rest === undefined && !inSlur) {\n\t\t\t\t\t\tvar lyric = word_list.shift();\n\t\t\t\t\t\tif (lyric.syllable)\n\t\t\t\t\t\t\tlyric.syllable = lyric.syllable.replace(/ +/g,'\\xA0');\n\t\t\t\t\t\tif (el.lyric === undefined)\n\t\t\t\t\t\t\tel.lyric = [ lyric ];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tel.lyric.push(lyric);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tvar addSymbols = function(line, words) {\n\t\t// TODO-PER: Currently copied from w: line. This needs to be read as symbols instead.\n\t\tif (!line) { warn(\"Can't add symbols before the first line of music\", line, 0); return; }\n\t\twords = parseCommon.strip(words);\n\t\tif (words.charAt(words.length-1) !== '-')\n\t\t\twords = words + ' ';\t// Just makes it easier to parse below, since every word has a divider after it.\n\t\tvar word_list = [];\n\t\t// first make a list of words from the string we are passed. A word is divided on either a space or dash.\n\t\tvar last_divider = 0;\n\t\tvar replace = false;\n\t\tvar addWord = function(i) {\n\t\t\tvar word = parseCommon.strip(words.substring(last_divider, i));\n\t\t\tlast_divider = i+1;\n\t\t\tif (word.length > 0) {\n\t\t\t\tif (replace)\n\t\t\t\t\tword = parseCommon.gsub(word, '~', ' ');\n\t\t\t\tvar div = words.charAt(i);\n\t\t\t\tif (div !== '_' && div !== '-')\n\t\t\t\t\tdiv = ' ';\n\t\t\t\tword_list.push({syllable: tokenizer.translateString(word), divider: div});\n\t\t\t\treplace = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; i < words.length; i++) {\n\t\t\tswitch (words.charAt(i)) {\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\x12':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif (!addWord(i) && word_list.length > 0) {\n\t\t\t\t\t\tparseCommon.last(word_list).divider = '-';\n\t\t\t\t\t\tword_list.push({skip: true, to: 'next'});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'slur'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'next'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'bar'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '~':\n\t\t\t\t\treplace = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvar inSlur = false;\n\t\tparseCommon.each(line, function(el) {\n\t\t\tif (word_list.length !== 0) {\n\t\t\t\tif (word_list[0].skip) {\n\t\t\t\t\tswitch (word_list[0].to) {\n\t\t\t\t\t\tcase 'next': if (el.el_type === 'note' && el.pitches !== null && !inSlur) word_list.shift(); break;\n\t\t\t\t\t\tcase 'slur': if (el.el_type === 'note' && el.pitches !== null) word_list.shift(); break;\n\t\t\t\t\t\tcase 'bar': if (el.el_type === 'bar') word_list.shift(); break;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (el.el_type === 'note' && el.rest === undefined && !inSlur) {\n\t\t\t\t\t\tvar lyric = word_list.shift();\n\t\t\t\t\t\tif (el.lyric === undefined)\n\t\t\t\t\t\t\tel.lyric = [ lyric ];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tel.lyric.push(lyric);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tvar getBrokenRhythm = function(line, index) {\n\t\tswitch (line.charAt(index)) {\n\t\t\tcase '>':\n\t\t\tif (index < line.length - 1 && line.charAt(index+1) === '>')\t// double >>\n\t\t\t\t\treturn [2, 1.75, 0.25];\n\t\t\t\telse\n\t\t\t\t\treturn [1, 1.5, 0.5];\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\tif (index < line.length - 1 && line.charAt(index+1) === '<')\t// double <<\n\t\t\t\t\treturn [2, 0.25, 1.75];\n\t\t\t\telse\n\t\t\t\t\treturn [1, 0.5, 1.5];\n\t\t\t\tbreak;\n\t\t}\n\t\treturn null;\n\t};\n\n\t// TODO-PER: make this a method in el.\n\tvar addEndBeam = function(el) {\n\t\tif (el.duration !== undefined && el.duration < 0.25)\n\t\t\tel.end_beam = true;\n\t\treturn el;\n\t};\n\n\tvar pitches = {A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11};\n\tvar rests = {x: 'invisible', y: 'spacer', z: 'rest', Z: 'multimeasure' };\n\tvar getCoreNote = function(line, index, el, canHaveBrokenRhythm) {\n\t\t//var el = { startChar: index };\n\t\tvar isComplete = function(state) {\n\t\t\treturn (state === 'octave' || state === 'duration' || state === 'Zduration' || state === 'broken_rhythm' || state === 'end_slur');\n\t\t};\n\t\tvar state = 'startSlur';\n\t\tvar durationSetByPreviousNote = false;\n\t\twhile (1) {\n\t\t\tswitch(line.charAt(index)) {\n\t\t\t\tcase '(':\n\t\t\t\t\tif (state === 'startSlur') {\n\t\t\t\t\t\tif (el.startSlur === undefined) el.startSlur = 1; else el.startSlur++;\n\t\t\t\t\t} else if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\tif (isComplete(state)) {\n\t\t\t\t\t\tif (el.endSlur === undefined) el.endSlur = 1; else el.endSlur++;\n\t\t\t\t\t} else return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\tif (state === 'startSlur') {el.accidental = 'sharp';state = 'sharp2';}\n\t\t\t\t\telse if (state === 'sharp2') {el.accidental = 'dblsharp';state = 'pitch';}\n\t\t\t\t\telse if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif (state === 'startSlur') {el.accidental = 'flat';state = 'flat2';}\n\t\t\t\t\telse if (state === 'flat2') {el.accidental = 'dblflat';state = 'pitch';}\n\t\t\t\t\telse if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '=':\n\t\t\t\t\tif (state === 'startSlur') {el.accidental = 'natural';state = 'pitch';}\n\t\t\t\t\telse if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\tcase 'B':\n\t\t\t\tcase 'C':\n\t\t\t\tcase 'D':\n\t\t\t\tcase 'E':\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'G':\n\t\t\t\tcase 'a':\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'e':\n\t\t\t\tcase 'f':\n\t\t\t\tcase 'g':\n\t\t\t\t\tif (state === 'startSlur' || state === 'sharp2' || state === 'flat2' || state === 'pitch') {\n\t\t\t\t\t\tel.pitch = pitches[line.charAt(index)];\n\t\t\t\t\t\ttranspose.note(multilineVars, el);\n\t\t\t\t\t\tstate = 'octave';\n\t\t\t\t\t\t// At this point we have a valid note. The rest is optional. Set the duration in case we don't get one below\n\t\t\t\t\t\tif (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {\n\t\t\t\t\t\t\tel.duration = multilineVars.default_length * multilineVars.next_note_duration;\n\t\t\t\t\t\t\tmultilineVars.next_note_duration = 0;\n\t\t\t\t\t\t\tdurationSetByPreviousNote = true;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tel.duration = multilineVars.default_length;\n\t\t\t\t\t\t// If the clef is percussion, there is probably some translation of the pitch to a particular drum kit item.\n\t\t\t\t\t\tif ((multilineVars.clef && multilineVars.clef.type === \"perc\") ||\n\t\t\t\t\t\t\t(multilineVars.currentVoice && multilineVars.currentVoice.clef === \"perc\")) {\n\t\t\t\t\t\t\tvar key = line.charAt(index);\n\t\t\t\t\t\t\tif (el.accidental) {\n\t\t\t\t\t\t\t\tvar accMap = { 'dblflat': '__', 'flat': '_', 'natural': '=', 'sharp': '^', 'dblsharp': '^^'};\n\t\t\t\t\t\t\t\tkey = accMap[el.accidental] + key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (tune.formatting && tune.formatting.midi && tune.formatting.midi.drummap)\n\t\t\t\t\t\t\t\tel.midipitch = tune.formatting.midi.drummap[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ',':\n\t\t\t\t\tif (state === 'octave') {el.pitch -= 7;}\n\t\t\t\t\telse if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (state === 'octave') {el.pitch += 7;}\n\t\t\t\t\telse if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\n\t\t\t\tcase 'y':\n\t\t\t\tcase 'z':\n\t\t\t\tcase 'Z':\n\t\t\t\t\tif (state === 'startSlur') {\n\t\t\t\t\t\tel.rest = { type: rests[line.charAt(index)] };\n\t\t\t\t\t\t// There shouldn't be some of the properties that notes have. If some sneak in due to bad syntax in the abc file,\n\t\t\t\t\t\t// just nix them here.\n\t\t\t\t\t\tdelete el.accidental;\n\t\t\t\t\t\tdelete el.startSlur;\n\t\t\t\t\t\tdelete el.startTie;\n\t\t\t\t\t\tdelete el.endSlur;\n\t\t\t\t\t\tdelete el.endTie;\n\t\t\t\t\t\tdelete el.end_beam;\n\t\t\t\t\t\tdelete el.grace_notes;\n\t\t\t\t\t\t// At this point we have a valid note. The rest is optional. Set the duration in case we don't get one below\n\t\t\t\t\t\tif (el.rest.type === 'multimeasure') {\n\t\t\t\t\t\t\tel.duration = 1;\n\t\t\t\t\t\t\tstate = 'Zduration';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {\n\t\t\t\t\t\t\t\tel.duration = multilineVars.default_length * multilineVars.next_note_duration;\n\t\t\t\t\t\t\t\tmultilineVars.next_note_duration = 0;\n\t\t\t\t\t\t\t\tdurationSetByPreviousNote = true;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tel.duration = multilineVars.default_length;\n\t\t\t\t\t\t\tstate = 'duration';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\tcase '0':\n\t\t\t\tcase '/':\n\t\t\t\t\tif (state === 'octave' || state === 'duration') {\n\t\t\t\t\t\tvar fraction = tokenizer.getFraction(line, index);\n\t\t\t\t\t\t//if (!durationSetByPreviousNote)\n\t\t\t\t\t\t\tel.duration = el.duration * fraction.value;\n\t\t\t\t\t\t// TODO-PER: We can test the returned duration here and give a warning if it isn't the one expected.\n\t\t\t\t\t\tel.endChar = fraction.index;\n\t\t\t\t\t\twhile (fraction.index < line.length && (tokenizer.isWhiteSpace(line.charAt(fraction.index)) || line.charAt(fraction.index) === '-')) {\n\t\t\t\t\t\t\tif (line.charAt(fraction.index) === '-')\n\t\t\t\t\t\t\t\tel.startTie = {};\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tel = addEndBeam(el);\n\t\t\t\t\t\t\tfraction.index++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex = fraction.index-1;\n\t\t\t\t\t\tstate = 'broken_rhythm';\n\t\t\t\t\t} else if (state === 'sharp2') {\n\t\t\t\t\t\tel.accidental = 'quartersharp';state = 'pitch';\n\t\t\t\t\t} else if (state === 'flat2') {\n\t\t\t\t\t\tel.accidental = 'quarterflat';state = 'pitch';\n\t\t\t\t\t} else if (state === 'Zduration') {\n\t\t\t\t\t\tvar num = tokenizer.getNumber(line, index);\n\t\t\t\t\t\tel.duration = num.num;\n\t\t\t\t\t\tel.endChar = num.index;\n\t\t\t\t\t\treturn el;\n\t\t\t\t\t} else return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif (state === 'startSlur') {\n\t\t\t\t\t\t// This is the first character, so it must have been meant for the previous note. Correct that here.\n\t\t\t\t\t\ttune.addTieToLastNote();\n\t\t\t\t\t\tel.endTie = true;\n\t\t\t\t\t} else if (state === 'octave' || state === 'duration' || state === 'end_slur') {\n\t\t\t\t\t\tel.startTie = {};\n\t\t\t\t\t\tif (!durationSetByPreviousNote && canHaveBrokenRhythm)\n\t\t\t\t\t\t\tstate = 'broken_rhythm';\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Peek ahead to the next character. If it is a space, then we have an end beam.\n\t\t\t\t\t\t\tif (tokenizer.isWhiteSpace(line.charAt(index + 1)))\n\t\t\t\t\t\t\t\taddEndBeam(el);\n\t\t\t\t\t\t\tel.endChar = index+1;\n\t\t\t\t\t\t\treturn el;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (state === 'broken_rhythm') {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tif (isComplete(state)) {\n\t\t\t\t\t\tel.end_beam = true;\n\t\t\t\t\t\t// look ahead to see if there is a tie\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (line.charAt(index) === '-')\n\t\t\t\t\t\t\t\tel.startTie = {};\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} while (index < line.length && (tokenizer.isWhiteSpace(line.charAt(index)) || line.charAt(index) === '-'));\n\t\t\t\t\t\tel.endChar = index;\n\t\t\t\t\t\tif (!durationSetByPreviousNote && canHaveBrokenRhythm && (line.charAt(index) === '<' || line.charAt(index) === '>')) {\t// TODO-PER: Don't need the test for < and >, but that makes the endChar work out for the regression test.\n\t\t\t\t\t\t\tindex--;\n\t\t\t\t\t\t\tstate = 'broken_rhythm';\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn el;\n\t\t\t\t\t}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\tcase '<':\n\t\t\t\t\tif (isComplete(state)) {\n\t\t\t\t\t\tif (canHaveBrokenRhythm) {\n\t\t\t\t\t\t\tvar br2 = getBrokenRhythm(line, index);\n\t\t\t\t\t\t\tindex += br2[0] - 1;\t// index gets incremented below, so we'll let that happen\n\t\t\t\t\t\t\tmultilineVars.next_note_duration = br2[2];\n\t\t\t\t\t\t\tel.duration = br2[1]*el.duration;\n\t\t\t\t\t\t\tstate = 'end_slur';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tel.endChar = index;\n\t\t\t\t\t\t\treturn el;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (isComplete(state)) {\n\t\t\t\t\t\tel.endChar = index;\n\t\t\t\t\t\treturn el;\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t\tindex++;\n\t\t\tif (index === line.length) {\n\t\t\t\tif (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\telse return null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\tfunction startNewLine() {\n\t\tvar params = { startChar: -1, endChar: -1};\n\t\tif (multilineVars.partForNextLine.length)\n\t\t\tparams.part = multilineVars.partForNextLine;\n\t\tparams.clef = multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].clef !== undefined ? parseCommon.clone(multilineVars.staves[multilineVars.currentVoice.staffNum].clef) : parseCommon.clone(multilineVars.clef);\n\t\tvar scoreTranspose = multilineVars.currentVoice ? multilineVars.currentVoice.scoreTranspose : 0;\n\t\tparams.key = parseKeyVoice.standardKey(multilineVars.key.root+multilineVars.key.acc+multilineVars.key.mode, multilineVars.key.root, multilineVars.key.acc, scoreTranspose);\n\t\tparams.key.mode = multilineVars.key.mode;\n\t\tif (multilineVars.key.impliedNaturals)\n\t\t\tparams.key.impliedNaturals = multilineVars.key.impliedNaturals;\n\t\tif (multilineVars.key.explicitAccidentals) {\n\t\t\tfor (var i = 0; i < multilineVars.key.explicitAccidentals.length; i++) {\n\t\t\t\tvar found = false;\n\t\t\t\tfor (var j = 0; j < params.key.accidentals.length; j++) {\n\t\t\t\t\tif (params.key.accidentals[j].note === multilineVars.key.explicitAccidentals[i].note) {\n\t\t\t\t\t\t// If the note is already in the list, override it with the new value\n\t\t\t\t\t\tparams.key.accidentals[j].acc = multilineVars.key.explicitAccidentals[i].acc;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found)\n\t\t\t\t\tparams.key.accidentals.push(multilineVars.key.explicitAccidentals[i]);\n\t\t\t}\n\t\t}\n\t\tif (params.key.explicitAccidentals)\n\t\t\tdelete params.key.explicitAccidentals;\n\t\tparseKeyVoice.addPosToKey(params.clef, params.key);\n\t\tif (multilineVars.meter !== null) {\n\t\t\tif (multilineVars.currentVoice) {\n\t\t\t\tparseCommon.each(multilineVars.staves, function(st) {\n\t\t\t\t\tst.meter = multilineVars.meter;\n\t\t\t\t});\n\t\t\t\tparams.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;\n\t\t\t\tmultilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;\n\t\t\t} else\n\t\t\t\tparams.meter = multilineVars.meter;\n\t\t\tmultilineVars.meter = null;\n\t\t} else if (multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].meter) {\n\t\t\t// Make sure that each voice gets the meter marking.\n\t\t\tparams.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;\n\t\t\tmultilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;\n\t\t}\n\t\tif (multilineVars.currentVoice && multilineVars.currentVoice.name)\n\t\t\tparams.name = multilineVars.currentVoice.name;\n\t\tif (multilineVars.vocalfont)\n\t\t\tparams.vocalfont = multilineVars.vocalfont;\n\t\tif (multilineVars.style)\n\t\t\tparams.style = multilineVars.style;\n\t\tif (multilineVars.currentVoice) {\n\t\t\tvar staff = multilineVars.staves[multilineVars.currentVoice.staffNum];\n\t\t\tif (staff.brace) params.brace = staff.brace;\n\t\t\tif (staff.bracket) params.bracket = staff.bracket;\n\t\t\tif (staff.connectBarLines) params.connectBarLines = staff.connectBarLines;\n\t\t\tif (staff.name) params.name = staff.name[multilineVars.currentVoice.index];\n\t\t\tif (staff.subname) params.subname = staff.subname[multilineVars.currentVoice.index];\n\t\t\tif (multilineVars.currentVoice.stem)\n\t\t\t\tparams.stem = multilineVars.currentVoice.stem;\n\t\t\tif (multilineVars.currentVoice.stafflines)\n\t\t\t\tparams.stafflines = multilineVars.currentVoice.stafflines;\n\t\t\tif (multilineVars.currentVoice.staffscale)\n\t\t\t\tparams.staffscale = multilineVars.currentVoice.staffscale;\n\t\t\tif (multilineVars.currentVoice.scale)\n\t\t\t\tparams.scale = multilineVars.currentVoice.scale;\n\t\t\tif (multilineVars.currentVoice.style)\n\t\t\t\tparams.style = multilineVars.currentVoice.style;\n\t\t\tif (multilineVars.currentVoice.transpose)\n\t\t\t\tparams.clef.transpose = multilineVars.currentVoice.transpose;\n\t\t}\n\t\tvar isFirstVoice = multilineVars.currentVoice === undefined || (multilineVars.currentVoice.staffNum ===  0 && multilineVars.currentVoice.index ===  0);\n\t\tif (multilineVars.barNumbers === 0 && isFirstVoice && multilineVars.currBarNumber !== 1)\n\t\t\tparams.barNumber = multilineVars.currBarNumber;\n\t\ttune.startNewLine(params);\n\t\tif (multilineVars.key.impliedNaturals)\n\t\t\tdelete multilineVars.key.impliedNaturals;\n\n\t\tmultilineVars.partForNextLine = \"\";\n\t}\n\n\tvar letter_to_grace =  function(line, i) {\n\t\t// Grace notes are an array of: startslur, note, endslur, space; where note is accidental, pitch, duration\n\t\tif (line.charAt(i) === '{') {\n\t\t\t// fetch the gracenotes string and consume that into the array\n\t\t\tvar gra = tokenizer.getBrackettedSubstring(line, i, 1, '}');\n\t\t\tif (!gra[2])\n\t\t\t\twarn(\"Missing the closing '}' while parsing grace note\", line, i);\n\t\t\t// If there is a slur after the grace construction, then move it to the last note inside the grace construction\n\t\t\tif (line[i+gra[0]] === ')') {\n\t\t\t\tgra[0]++;\n\t\t\t\tgra[1] += ')';\n\t\t\t}\n\n\t\t\tvar gracenotes = [];\n\t\t\tvar ii = 0;\n\t\t\tvar inTie = false;\n\t\t\twhile (ii < gra[1].length) {\n\t\t\t\tvar acciaccatura = false;\n\t\t\t\tif (gra[1].charAt(ii) === '/') {\n\t\t\t\t\tacciaccatura = true;\n\t\t\t\t\tii++;\n\t\t\t\t}\n\t\t\t\tvar note = getCoreNote(gra[1], ii, {}, false);\n\t\t\t\tif (note !== null) {\n\t\t\t\t\t// The grace note durations should not be affected by the default length: they should be based on 1/16, so if that isn't the default, then multiply here.\n\t\t\t\t\tnote.duration = note.duration / (multilineVars.default_length * 8);\n\t\t\t\t\tif (acciaccatura)\n\t\t\t\t\t\tnote.acciaccatura = true;\n\t\t\t\t\tgracenotes.push(note);\n\n\t\t\t\t\tif (inTie) {\n\t\t\t\t\t\tnote.endTie = true;\n\t\t\t\t\t\tinTie = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (note.startTie)\n\t\t\t\t\t\tinTie = true;\n\n\t\t\t\t\tii  = note.endChar;\n\t\t\t\t\tdelete note.endChar;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// We shouldn't get anything but notes or a space here, so report an error\n\t\t\t\t\tif (gra[1].charAt(ii) === ' ') {\n\t\t\t\t\t\tif (gracenotes.length > 0)\n\t\t\t\t\t\t\tgracenotes[gracenotes.length-1].end_beam = true;\n\t\t\t\t\t} else\n\t\t\t\t\t\twarn(\"Unknown character '\" + gra[1].charAt(ii) + \"' while parsing grace note\", line, i);\n\t\t\t\t\tii++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (gracenotes.length)\n\t\t\t\treturn [gra[0], gracenotes];\n\t\t}\n\t\treturn [ 0 ];\n\t};\n\n\tfunction letter_to_overlay(line, i) {\n\t\tif (line.charAt(i) === '&') {\n\t\t\tvar start = i;\n\t\t\twhile (line.charAt(i) && line.charAt(i) !== ':' && line.charAt(i) !== '|')\n\t\t\t\ti++;\n\t\t\treturn [ i-start, line.substring(start+1, i) ];\n\t\t}\n\t\treturn [ 0 ];\n\t}\n\n\tfunction durationOfMeasure(multilineVars) {\n\t\t// TODO-PER: This could be more complicated if one of the unusual measures is used.\n\t\tvar meter = multilineVars.origMeter;\n\t\tif (!meter || meter.type !== 'specified')\n\t\t\treturn 1;\n\t\tif (!meter.value || meter.value.length === 0)\n\t\t\treturn 1;\n\t\treturn parseInt(meter.value[0].num, 10) / parseInt(meter.value[0].den, 10);\n\t}\n\n\t//\n\t// Parse line of music\n\t//\n\t// This is a stream of <(bar-marking|header|note-group)...> in any order, with optional spaces between each element\n\t// core-note is <open-slur, accidental, pitch:required, octave, duration, close-slur&|tie> with no spaces within that\n\t// chord is <open-bracket:required, core-note:required... close-bracket:required duration> with no spaces within that\n\t// grace-notes is <open-brace:required, (open-slur|core-note:required|close-slur)..., close-brace:required> spaces are allowed\n\t// note-group is <grace-notes, chord symbols&|decorations..., grace-notes, slur&|triplet, chord|core-note, end-slur|tie> spaces are allowed between items\n\t// bar-marking is <ampersand> or <chord symbols&|decorations..., bar:required> spaces allowed\n\t// header is <open-bracket:required, K|M|L|V:required, colon:required, field:required, close-bracket:required> spaces can occur between the colon, in the field, and before the close bracket\n\t// header can also be the only thing on a line. This is true even if it is a continuation line. In this case the brackets are not required.\n\t// a space is a back-tick, a space, or a tab. If it is a back-tick, then there is no end-beam.\n\n\t// Line preprocessing: anything after a % is ignored (the double %% should have been taken care of before this)\n\t// Then, all leading and trailing spaces are ignored.\n\t// If there was a line continuation, the \\n was replaced by a \\r and the \\ was replaced by a space. This allows the construct\n\t// of having a header mid-line conceptually, but actually be at the start of the line. This is equivolent to putting the header in [ ].\n\n\t// TODO-PER: How to handle ! for line break?\n\t// TODO-PER: dots before bar, dots before slur\n\t// TODO-PER: U: redefinable symbols.\n\n\t// Ambiguous symbols:\n\t// \"[\" can be the start of a chord, the start of a header element or part of a bar line.\n\t// --- if it is immediately followed by \"|\", it is a bar line\n\t// --- if it is immediately followed by K: L: M: V: it is a header (note: there are other headers mentioned in the standard, but I'm not sure how they would be used.)\n\t// --- otherwise it is the beginning of a chord\n\t// \"(\" can be the start of a slur or a triplet\n\t// --- if it is followed by a number from 2-9, then it is a triplet\n\t// --- otherwise it is a slur\n\t// \"]\"\n\t// --- if there is a chord open, then this is the close\n\t// --- if it is after a [|, then it is an invisible bar line\n\t// --- otherwise, it is par of a bar\n\t// \".\" can be a bar modifier or a slur modifier, or a decoration\n\t// --- if it comes immediately before a bar, it is a bar modifier\n\t// --- if it comes immediately before a slur, it is a slur modifier\n\t// --- otherwise it is a decoration for the next note.\n\t// number:\n\t// --- if it is after a bar, with no space, it is an ending marker\n\t// --- if it is after a ( with no space, it is a triplet count\n\t// --- if it is after a pitch or octave or slash, then it is a duration\n\n\t// Unambiguous symbols (except inside quoted strings):\n\t// vertical-bar, colon: part of a bar\n\t// ABCDEFGabcdefg: pitch\n\t// xyzZ: rest\n\t// comma, prime: octave\n\t// close-paren: end-slur\n\t// hyphen: tie\n\t// tilde, v, u, bang, plus, THLMPSO: decoration\n\t// carat, underscore, equal: accidental\n\t// ampersand: time reset\n\t// open-curly, close-curly: grace notes\n\t// double-quote: chord symbol\n\t// less-than, greater-than, slash: duration\n\t// back-tick, space, tab: space\n\tvar nonDecorations = \"ABCDEFGabcdefgxyzZ[]|^_{\";\t// use this to prescreen so we don't have to look for a decoration at every note.\n\n\tvar parseRegularMusicLine = function(line) {\n\t\theader.resolveTempo();\n\t\t//multilineVars.havent_set_length = false;\t// To late to set this now.\n\t\tmultilineVars.is_in_header = false;\t// We should have gotten a key header by now, but just in case, this is definitely out of the header.\n\t\tvar i = 0;\n\t\tvar startOfLine = multilineVars.iChar;\n\t\t// see if there is nothing but a comment on this line. If so, just ignore it. A full line comment is optional white space followed by %\n\t\twhile (tokenizer.isWhiteSpace(line.charAt(i)) && i < line.length)\n\t\t\ti++;\n\t\tif (i === line.length || line.charAt(i) === '%')\n\t\t\treturn;\n\n\t\t// Start with the standard staff, clef and key symbols on each line\n\t\tvar delayStartNewLine = multilineVars.start_new_line;\n\t\tif (multilineVars.continueall === undefined)\n\t\t\tmultilineVars.start_new_line = true;\n\t\telse\n\t\t\tmultilineVars.start_new_line = false;\n\t\tvar tripletNotesLeft = 0;\n\n\t\t// See if the line starts with a header field\n\t\tvar retHeader = header.letter_to_body_header(line, i);\n\t\tif (retHeader[0] > 0) {\n\t\t\ti += retHeader[0];\n\t\t\tif (retHeader[1] === 'V')\n\t\t\t\tdelayStartNewLine = true; // fixes bug on this: c[V:2]d\n\t\t\t// TODO-PER: Handle inline headers\n\t\t}\n\t\tvar el = { };\n\n\t\twhile (i < line.length)\n\t\t{\n\t\t\tvar startI = i;\n\t\t\tif (line.charAt(i) === '%')\n\t\t\t\tbreak;\n\n\t\t\tvar retInlineHeader = header.letter_to_inline_header(line, i);\n\t\t\tif (retInlineHeader[0] > 0) {\n\t\t\t\t\ti += retInlineHeader[0];\n\t\t\t\t\tif (retInlineHeader[1] === 'V')\n\t\t\t\t\t\tdelayStartNewLine = true; // fixes bug on this: c[V:2]d\n\t\t\t\t\t// TODO-PER: Handle inline headers\n\t\t\t\t\t//multilineVars.start_new_line = false;\n\t\t\t} else {\n\t\t\t\t// Wait until here to actually start the line because we know we're past the inline statements.\n\t\t\t\tif (delayStartNewLine) {\n\t\t\t\t\tstartNewLine();\n\t\t\t\t\tdelayStartNewLine = false;\n\t\t\t\t}\n\n\t\t\t\t// We need to decide if the following characters are a bar-marking or a note-group.\n\t\t\t\t// Unfortunately, that is ambiguous. Both can contain chord symbols and decorations.\n\t\t\t\t// If there is a grace note either before or after the chord symbols and decorations, then it is definitely a note-group.\n\t\t\t\t// If there is a bar marker, it is definitely a bar-marking.\n\t\t\t\t// If there is either a core-note or chord, it is definitely a note-group.\n\t\t\t\t// So, loop while we find grace-notes, chords-symbols, or decorations. [It is an error to have more than one grace-note group in a row; the others can be multiple]\n\t\t\t\t// Then, if there is a grace-note, we know where to go.\n\t\t\t\t// Else see if we have a chord, core-note, slur, triplet, or bar.\n\n\t\t\t\tvar ret;\n\t\t\t\twhile (1) {\n\t\t\t\t\tret = tokenizer.eatWhiteSpace(line, i);\n\t\t\t\t\tif (ret > 0) {\n\t\t\t\t\t\ti += ret;\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 0 && line.charAt(i-1) === '\\x12') {\n\t\t\t\t\t\t// there is one case where a line continuation isn't the same as being on the same line, and that is if the next character after it is a header.\n\t\t\t\t\t\tret = header.letter_to_body_header(line, i);\n\t\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\t\tif (ret[1] === 'V')\n\t\t\t\t\t\t\t\tstartNewLine(); // fixes bug on this: c\\\\nV:2]\\\\nd\n\t\t\t\t\t\t\t// TODO: insert header here\n\t\t\t\t\t\t\ti = ret[0];\n\t\t\t\t\t\t\tmultilineVars.start_new_line = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// gather all the grace notes, chord symbols and decorations\n\t\t\t\t\tret = letter_to_spacer(line, i);\n\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\ti += ret[0];\n\t\t\t\t\t}\n\n\t\t\t\t\tret = letter_to_overlay(line, i);\n\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\ttune.appendElement('overlay', startOfLine, startOfLine+1, {});\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tret = letter_to_chord(line, i);\n\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\t// There could be more than one chord here if they have different positions.\n\t\t\t\t\t\t// If two chords have the same position, then connect them with newline.\n\t\t\t\t\t\tif (!el.chord)\n\t\t\t\t\t\t\tel.chord = [];\n\t\t\t\t\t\tvar chordName = tokenizer.translateString(ret[1]);\n\t\t\t\t\t\tchordName = chordName.replace(/;/g, \"\\n\");\n\t\t\t\t\t\tvar addedChord = false;\n\t\t\t\t\t\tfor (var ci = 0; ci < el.chord.length; ci++) {\n\t\t\t\t\t\t\tif (el.chord[ci].position === ret[2]) {\n\t\t\t\t\t\t\t\taddedChord = true;\n\t\t\t\t\t\t\t\tel.chord[ci].name += \"\\n\" + chordName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (addedChord === false) {\n\t\t\t\t\t\t\tif (ret[2] === null && ret[3])\n\t\t\t\t\t\t\t\tel.chord.push({name: chordName, rel_position: ret[3]});\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tel.chord.push({name: chordName, position: ret[2]});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti += ret[0];\n\t\t\t\t\t\tvar ii = tokenizer.skipWhiteSpace(line.substring(i));\n\t\t\t\t\t\tif (ii > 0)\n\t\t\t\t\t\t\tel.force_end_beam_last = true;\n\t\t\t\t\t\ti += ii;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (nonDecorations.indexOf(line.charAt(i)) === -1)\n\t\t\t\t\t\t\tret = letter_to_accent(line, i);\n\t\t\t\t\t\telse ret = [ 0 ];\n\t\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\t\tif (ret[1] === null) {\n\t\t\t\t\t\t\t\tif (i + 1 < line.length)\n\t\t\t\t\t\t\t\t\tstartNewLine();\t// There was a ! in the middle of the line. Start a new line if there is anything after it.\n\t\t\t\t\t\t\t} else if (ret[1].length > 0) {\n\t\t\t\t\t\t\t\tif (ret[1].indexOf(\"style=\") === 0) {\n\t\t\t\t\t\t\t\t\tel.style = ret[1].substr(6);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (el.decoration === undefined)\n\t\t\t\t\t\t\t\t\t\tel.decoration = [];\n\t\t\t\t\t\t\t\t\tel.decoration.push(ret[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti += ret[0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tret = letter_to_grace(line, i);\n\t\t\t\t\t\t\t// TODO-PER: Be sure there aren't already grace notes defined. That is an error.\n\t\t\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\t\t\tel.gracenotes = ret[1];\n\t\t\t\t\t\t\t\ti += ret[0];\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tret = letter_to_bar(line, i);\n\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t// This is definitely a bar\n\t\t\t\t\tif (el.gracenotes !== undefined) {\n\t\t\t\t\t\t// Attach the grace note to an invisible note\n\t\t\t\t\t\tel.rest = { type: 'spacer' };\n\t\t\t\t\t\tel.duration = 0.125; // TODO-PER: I don't think the duration of this matters much, but figure out if it does.\n\t\t\t\t\t\tmultilineVars.addFormattingOptions(el, tune.formatting, 'note');\n\t\t\t\t\t\ttune.appendElement('note', startOfLine+i, startOfLine+i+ret[0], el);\n\t\t\t\t\t\tmultilineVars.measureNotEmpty = true;\n\t\t\t\t\t\tel = {};\n\t\t\t\t\t}\n\t\t\t\t\tvar bar = {type: ret[1]};\n\t\t\t\t\tif (bar.type.length === 0)\n\t\t\t\t\t\twarn(\"Unknown bar type\", line, i);\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (multilineVars.inEnding && bar.type !== 'bar_thin') {\n\t\t\t\t\t\t\tbar.endEnding = true;\n\t\t\t\t\t\t\tmultilineVars.inEnding = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ret[2]) {\n\t\t\t\t\t\t\tbar.startEnding = ret[2];\n\t\t\t\t\t\t\tif (multilineVars.inEnding)\n\t\t\t\t\t\t\t\tbar.endEnding = true;\n\t\t\t\t\t\t\tmultilineVars.inEnding = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (el.decoration !== undefined)\n\t\t\t\t\t\t\tbar.decoration = el.decoration;\n\t\t\t\t\t\tif (el.chord !== undefined)\n\t\t\t\t\t\t\tbar.chord = el.chord;\n\t\t\t\t\t\tif (bar.startEnding && multilineVars.barFirstEndingNum === undefined)\n\t\t\t\t\t\t\tmultilineVars.barFirstEndingNum = multilineVars.currBarNumber;\n\t\t\t\t\t\telse if (bar.startEnding && bar.endEnding && multilineVars.barFirstEndingNum)\n\t\t\t\t\t\t\tmultilineVars.currBarNumber = multilineVars.barFirstEndingNum;\n\t\t\t\t\t\telse if (bar.endEnding)\n\t\t\t\t\t\t\tmultilineVars.barFirstEndingNum = undefined;\n\t\t\t\t\t\tif (bar.type !== 'bar_invisible' && multilineVars.measureNotEmpty) {\n\t\t\t\t\t\t\tvar isFirstVoice = multilineVars.currentVoice === undefined || (multilineVars.currentVoice.staffNum ===  0 && multilineVars.currentVoice.index ===  0);\n\t\t\t\t\t\t\tif (isFirstVoice) {\n\t\t\t\t\t\t\t\tmultilineVars.currBarNumber++;\n\t\t\t\t\t\t\t\tif (multilineVars.barNumbers && multilineVars.currBarNumber % multilineVars.barNumbers === 0)\n\t\t\t\t\t\t\t\t\tbar.barNumber = multilineVars.currBarNumber;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmultilineVars.addFormattingOptions(el, tune.formatting, 'bar');\n\t\t\t\t\t\ttune.appendElement('bar', startOfLine+i, startOfLine+i+ret[0], bar);\n\t\t\t\t\t\tmultilineVars.measureNotEmpty = false;\n\t\t\t\t\t\tel = {};\n\t\t\t\t\t}\n\t\t\t\t\ti += ret[0];\n\t\t\t\t} else if (line[i] === '&') {\t// backtrack to beginning of measure\n\t\t\t\t\twarn(\"Overlay not yet supported\", line, i);\n\t\t\t\t\ti++;\n\n\t\t\t\t} else {\n\t\t\t\t\t// This is definitely a note group\n\t\t\t\t\t//\n\t\t\t\t\t// Look for as many open slurs and triplets as there are. (Note: only the first triplet is valid.)\n\t\t\t\t\tret = letter_to_open_slurs_and_triplets(line, i);\n\t\t\t\t\tif (ret.consumed > 0) {\n\t\t\t\t\t\tif (ret.startSlur !== undefined)\n\t\t\t\t\t\t\tel.startSlur = ret.startSlur;\n\t\t\t\t\t\tif (ret.triplet !== undefined) {\n\t\t\t\t\t\t\tif (tripletNotesLeft > 0)\n\t\t\t\t\t\t\t\twarn(\"Can't nest triplets\", line, i);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tel.startTriplet = ret.triplet;\n\t\t\t\t\t\t\t\tel.tripletMultiplier = ret.tripletQ / ret.triplet;\n\t\t\t\t\t\t\t\ttripletNotesLeft = ret.num_notes === undefined ? ret.triplet : ret.num_notes;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti += ret.consumed;\n\t\t\t\t\t}\n\n\t\t\t\t\t// handle chords.\n\t\t\t\t\tif (line.charAt(i) === '[') {\n\t\t\t\t\t\tvar chordStartChar = i;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tvar chordDuration = null;\n\t\t\t\t\t\tvar rememberEndBeam = false;\n\n\t\t\t\t\t\tvar done = false;\n\t\t\t\t\t\twhile (!done) {\n\t\t\t\t\t\t\tvar accent = letter_to_accent(line, i);\n\t\t\t\t\t\t\tif (accent[0] > 0) {\n\t\t\t\t\t\t\t\ti += accent[0];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar chordNote = getCoreNote(line, i, {}, false);\n\t\t\t\t\t\t\tif (chordNote !== null) {\n\t\t\t\t\t\t\t\tif (accent[0] > 0) { // If we found a decoration above, it modifies the entire chord. \"style\" is handled below.\n\t\t\t\t\t\t\t\t\tif (accent[1].indexOf(\"style=\") !== 0) {\n\t\t\t\t\t\t\t\t\t\tif (el.decoration === undefined)\n\t\t\t\t\t\t\t\t\t\t\tel.decoration = [];\n\t\t\t\t\t\t\t\t\t\tel.decoration.push(accent[1]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (chordNote.end_beam) {\n\t\t\t\t\t\t\t\t\tel.end_beam = true;\n\t\t\t\t\t\t\t\t\tdelete chordNote.end_beam;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (el.pitches === undefined) {\n\t\t\t\t\t\t\t\t\tel.duration = chordNote.duration;\n\t\t\t\t\t\t\t\t\tel.pitches = [ chordNote ];\n\t\t\t\t\t\t\t\t} else\t// Just ignore the note lengths of all but the first note. The standard isn't clear here, but this seems less confusing.\n\t\t\t\t\t\t\t\t\tel.pitches.push(chordNote);\n\t\t\t\t\t\t\t\tdelete chordNote.duration;\n\t\t\t\t\t\t\t\tif (accent[0] > 0) { // If we found a style above, it modifies the individual pitch, not the entire chord.\n\t\t\t\t\t\t\t\t\tif (accent[1].indexOf(\"style=\") === 0) {\n\t\t\t\t\t\t\t\t\t\tel.pitches[el.pitches.length-1].style = accent[1].substr(6);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (multilineVars.inTieChord[el.pitches.length]) {\n\t\t\t\t\t\t\t\t\tchordNote.endTie = true;\n\t\t\t\t\t\t\t\t\tmultilineVars.inTieChord[el.pitches.length] = undefined;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (chordNote.startTie)\n\t\t\t\t\t\t\t\t\tmultilineVars.inTieChord[el.pitches.length] = true;\n\n\t\t\t\t\t\t\t\ti  = chordNote.endChar;\n\t\t\t\t\t\t\t\tdelete chordNote.endChar;\n\t\t\t\t\t\t\t} else if (line.charAt(i) === ' ') {\n\t\t\t\t\t\t\t\t// Spaces are not allowed in chords, but we can recover from it by ignoring it.\n\t\t\t\t\t\t\t\twarn(\"Spaces are not allowed in chords\", line, i);\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (i < line.length && line.charAt(i) === ']') {\n\t\t\t\t\t\t\t\t\t// consume the close bracket\n\t\t\t\t\t\t\t\t\ti++;\n\n\t\t\t\t\t\t\t\t\tif (multilineVars.next_note_duration !== 0) {\n\t\t\t\t\t\t\t\t\t\tel.duration = el.duration * multilineVars.next_note_duration;\n\t\t\t\t\t\t\t\t\t\tmultilineVars.next_note_duration = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (multilineVars.inTie) {\n\t\t\t\t\t\t\t\t\t\tparseCommon.each(el.pitches, function(pitch) { pitch.endTie = true; });\n\t\t\t\t\t\t\t\t\t\tmultilineVars.inTie = false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (tripletNotesLeft > 0) {\n\t\t\t\t\t\t\t\t\t\ttripletNotesLeft--;\n\t\t\t\t\t\t\t\t\t\tif (tripletNotesLeft === 0) {\n\t\t\t\t\t\t\t\t\t\t\tel.endTriplet = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar postChordDone = false;\n\t\t\t\t\t\t\t\t\twhile (i < line.length && !postChordDone) {\n\t\t\t\t\t\t\t\t\t\tswitch (line.charAt(i)) {\n\t\t\t\t\t\t\t\t\t\t\tcase ' ':\n\t\t\t\t\t\t\t\t\t\t\tcase '\\t':\n\t\t\t\t\t\t\t\t\t\t\t\taddEndBeam(el);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase ')':\n\t\t\t\t\t\t\t\t\t\t\t\tif (el.endSlur === undefined) el.endSlur = 1; else el.endSlur++;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\t\t\t\t\t\tparseCommon.each(el.pitches, function(pitch) { pitch.startTie = {}; });\n\t\t\t\t\t\t\t\t\t\t\t\tmultilineVars.inTie = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\t\t\t\t\t\tvar br2 = getBrokenRhythm(line, i);\n\t\t\t\t\t\t\t\t\t\t\t\ti += br2[0] - 1;\t// index gets incremented below, so we'll let that happen\n\t\t\t\t\t\t\t\t\t\t\t\tmultilineVars.next_note_duration = br2[2];\n\t\t\t\t\t\t\t\t\t\t\t\tif (chordDuration)\n\t\t\t\t\t\t\t\t\t\t\t\t\tchordDuration = chordDuration * br2[1];\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\tchordDuration = br2[1];\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase '1':\n\t\t\t\t\t\t\t\t\t\t\tcase '2':\n\t\t\t\t\t\t\t\t\t\t\tcase '3':\n\t\t\t\t\t\t\t\t\t\t\tcase '4':\n\t\t\t\t\t\t\t\t\t\t\tcase '5':\n\t\t\t\t\t\t\t\t\t\t\tcase '6':\n\t\t\t\t\t\t\t\t\t\t\tcase '7':\n\t\t\t\t\t\t\t\t\t\t\tcase '8':\n\t\t\t\t\t\t\t\t\t\t\tcase '9':\n\t\t\t\t\t\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\t\t\t\t\t\tvar fraction = tokenizer.getFraction(line, i);\n\t\t\t\t\t\t\t\t\t\t\t\tchordDuration = fraction.value;\n\t\t\t\t\t\t\t\t\t\t\t\ti = fraction.index;\n\t\t\t\t\t\t\t\t\t\t\t\tif (line.charAt(i) === ' ')\n\t\t\t\t\t\t\t\t\t\t\t\t\trememberEndBeam = true;\n\t\t\t\t\t\t\t\t\t\t\t\tif (line.charAt(i) === '-' || line.charAt(i) === ')' || line.charAt(i) === ' ' || line.charAt(i) === '<' || line.charAt(i) === '>')\n\t\t\t\t\t\t\t\t\t\t\t\t\ti--; // Subtracting one because one is automatically added below\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\tpostChordDone = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\tpostChordDone = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!postChordDone) {\n\t\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\twarn(\"Expected ']' to end the chords\", line, i);\n\n\t\t\t\t\t\t\t\tif (el.pitches !== undefined) {\n\t\t\t\t\t\t\t\t\tif (chordDuration !== null) {\n\t\t\t\t\t\t\t\t\t\tel.duration = el.duration * chordDuration;\n\t\t\t\t\t\t\t\t\t\tif (rememberEndBeam)\n\t\t\t\t\t\t\t\t\t\t\taddEndBeam(el);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tmultilineVars.addFormattingOptions(el, tune.formatting, 'note');\n\t\t\t\t\t\t\t\t\ttune.appendElement('note', startOfLine+chordStartChar, startOfLine+i, el);\n\t\t\t\t\t\t\t\t\tmultilineVars.measureNotEmpty = true;\n\t\t\t\t\t\t\t\t\tel = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Single pitch\n\t\t\t\t\t\tvar el2 = {};\n\t\t\t\t\t\tvar core = getCoreNote(line, i, el2, true);\n\t\t\t\t\t\tif (el2.endTie !== undefined) multilineVars.inTie = true;\n\t\t\t\t\t\tif (core !== null) {\n\t\t\t\t\t\t\tif (core.pitch !== undefined) {\n\t\t\t\t\t\t\t\tel.pitches = [ { } ];\n\t\t\t\t\t\t\t\t// TODO-PER: straighten this out so there is not so much copying: getCoreNote shouldn't change e'\n\t\t\t\t\t\t\t\tif (core.accidental !== undefined) el.pitches[0].accidental = core.accidental;\n\t\t\t\t\t\t\t\tel.pitches[0].pitch = core.pitch;\n\t\t\t\t\t\t\t\tif (core.midipitch)\n\t\t\t\t\t\t\t\t\tel.pitches[0].midipitch = core.midipitch;\n\t\t\t\t\t\t\t\tif (core.endSlur !== undefined) el.pitches[0].endSlur = core.endSlur;\n\t\t\t\t\t\t\t\tif (core.endTie !== undefined) el.pitches[0].endTie = core.endTie;\n\t\t\t\t\t\t\t\tif (core.startSlur !== undefined) el.pitches[0].startSlur = core.startSlur;\n\t\t\t\t\t\t\t\tif (el.startSlur !== undefined) el.pitches[0].startSlur = el.startSlur;\n\t\t\t\t\t\t\t\tif (core.startTie !== undefined) el.pitches[0].startTie = core.startTie;\n\t\t\t\t\t\t\t\tif (el.startTie !== undefined) el.pitches[0].startTie = el.startTie;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tel.rest = core.rest;\n\t\t\t\t\t\t\t\tif (core.endSlur !== undefined) el.endSlur = core.endSlur;\n\t\t\t\t\t\t\t\tif (core.endTie !== undefined) el.rest.endTie = core.endTie;\n\t\t\t\t\t\t\t\tif (core.startSlur !== undefined) el.startSlur = core.startSlur;\n\t\t\t\t\t\t\t\tif (core.startTie !== undefined) el.rest.startTie = core.startTie;\n\t\t\t\t\t\t\t\tif (el.startTie !== undefined) el.rest.startTie = el.startTie;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (core.chord !== undefined) el.chord = core.chord;\n\t\t\t\t\t\t\tif (core.duration !== undefined) el.duration = core.duration;\n\t\t\t\t\t\t\tif (core.decoration !== undefined) el.decoration = core.decoration;\n\t\t\t\t\t\t\tif (core.graceNotes !== undefined) el.graceNotes = core.graceNotes;\n\t\t\t\t\t\t\tdelete el.startSlur;\n\t\t\t\t\t\t\tif (multilineVars.inTie) {\n\t\t\t\t\t\t\t\tif (el.pitches !== undefined) {\n\t\t\t\t\t\t\t\t\tel.pitches[0].endTie = true;\n\t\t\t\t\t\t\t\t\tmultilineVars.inTie = false;\n\t\t\t\t\t\t\t\t} else if (el.rest.type !== 'spacer') {\n\t\t\t\t\t\t\t\t\tel.rest.endTie = true;\n\t\t\t\t\t\t\t\t\tmultilineVars.inTie = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (core.startTie || el.startTie)\n\t\t\t\t\t\t\t\tmultilineVars.inTie = true;\n\t\t\t\t\t\t\ti  = core.endChar;\n\n\t\t\t\t\t\t\tif (tripletNotesLeft > 0) {\n\t\t\t\t\t\t\t\ttripletNotesLeft--;\n\t\t\t\t\t\t\t\tif (tripletNotesLeft === 0) {\n\t\t\t\t\t\t\t\t\tel.endTriplet = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (core.end_beam)\n\t\t\t\t\t\t\t\taddEndBeam(el);\n\n\t\t\t\t\t\t\t// If there is a whole rest, then it should be the duration of the measure, not it's own duration. We need to special case it.\n\t\t\t\t\t\t\tif (el.rest && el.rest.type === 'rest' && el.duration === 1) {\n\t\t\t\t\t\t\t\tel.rest.type = 'whole';\n\n\t\t\t\t\t\t\t\tel.duration = durationOfMeasure(multilineVars);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmultilineVars.addFormattingOptions(el, tune.formatting, 'note');\n\t\t\t\t\t\t\ttune.appendElement('note', startOfLine+startI, startOfLine+i, el);\n\t\t\t\t\t\t\tmultilineVars.measureNotEmpty = true;\n\t\t\t\t\t\t\tel = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i === startI) {\t// don't know what this is, so ignore it.\n\t\t\t\t\t\tif (line.charAt(i) !== ' ' && line.charAt(i) !== '`')\n\t\t\t\t\t\t\twarn(\"Unknown character ignored\", line, i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar parseLine = function(line) {\n\t\tvar ret = header.parseHeader(line);\n\t\tif (ret.regular)\n\t\t\tparseRegularMusicLine(ret.str);\n\t\tif (ret.newline && multilineVars.continueall === undefined)\n\t\t\tstartNewLine();\n\t\tif (ret.words)\n\t\t\taddWords(tune.getCurrentVoice(), line.substring(2));\n\t\tif (ret.symbols)\n\t\t\taddSymbols(tune.getCurrentVoice(), line.substring(2));\n\t\tif (ret.recurse)\n\t\t\tparseLine(ret.str);\n\t};\n\n\tfunction appendLastMeasure(voice, nextVoice) {\n\t\tvoice.push({\n\t\t\tel_type: 'hint'\n\t\t});\n\t\tfor (var i = 0; i < nextVoice.length; i++) {\n\t\t\tvar element = nextVoice[i];\n\t\t\tvar hint = parseCommon.clone(element);\n\t\t\tvoice.push(hint);\n\t\t\tif (element.el_type === 'bar')\n\t\t\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction addHintMeasure(staff, nextStaff) {\n\t\tfor (var i = 0; i < staff.length; i++) {\n\t\t\tvar stave = staff[i];\n\t\t\tvar nextStave = nextStaff[i];\n\t\t\tif (nextStave) { // Be sure there is the same number of staves on the next line.\n\t\t\t\tfor (var j = 0; j < nextStave.voices.length; j++) {\n\t\t\t\t\tvar nextVoice = nextStave.voices[j];\n\t\t\t\t\tvar voice = stave.voices[j];\n\t\t\t\t\tif (voice) { // Be sure there are the same number of voices on the previous line.\n\t\t\t\t\t\tappendLastMeasure(voice, nextVoice);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addHintMeasures() {\n\t\tfor (var i = 0; i < tune.lines.length; i++) {\n\t\t\tvar line = tune.lines[i].staff;\n\t\t\tif (line) {\n\t\t\t\tvar j = i+1;\n\t\t\t\twhile (j < tune.lines.length && tune.lines[j].staff === undefined)\n\t\t\t\t\tj++;\n\t\t\t\tif (j < tune.lines.length) {\n\t\t\t\t\tvar nextLine = tune.lines[j].staff;\n\t\t\t\t\taddHintMeasure(line, nextLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.parse = function(strTune, switches) {\n\t\t// the switches are optional and cause a difference in the way the tune is parsed.\n\t\t// switches.header_only : stop parsing when the header is finished\n\t\t// switches.stop_on_warning : stop at the first warning encountered.\n\t\t// switches.print: format for the page instead of the browser.\n\t\t// switches.format: a hash of the desired formatting commands.\n\t\t// switches.hint_measures: put the next measure at the end of the current line.\n\t\t// switches.transpose: change the key signature, chords, and notes by a number of half-steps.\n\t\tif (!switches) switches = {};\n\t\ttune.reset();\n\t\tif (switches.print)\n\t\t\ttune.media = 'print';\n\t\tmultilineVars.reset();\n\t\tif (switches.visualTranspose) {\n\t\t\tmultilineVars.globalTranspose = parseInt(switches.visualTranspose);\n\t\t\tif (multilineVars.globalTranspose === 0)\n\t\t\t\tmultilineVars.globalTranspose = undefined;\n\t\t} else\n\t\t\tmultilineVars.globalTranspose = undefined;\n\t\theader.reset(tokenizer, warn, multilineVars, tune);\n\n\t\t// Take care of whatever line endings come our way\n\t\tstrTune = parseCommon.gsub(strTune, '\\r\\n', '\\n');\n\t\tstrTune = parseCommon.gsub(strTune, '\\r', '\\n');\n\t\tstrTune += '\\n';\t// Tacked on temporarily to make the last line continuation work\n\t\tstrTune = strTune.replace(/\\n\\\\.*\\n/g, \"\\n\");\t// get rid of latex commands.\n\t\tvar continuationReplacement = function(all, backslash, comment){\n\t\t\tvar spaces = \"                                                                                                                                                                                                     \";\n\t\t\tvar padding = comment ? spaces.substring(0, comment.length) : \"\";\n\t\t\treturn backslash + \" \\x12\" + padding;\n\t\t};\n\t\tstrTune = strTune.replace(/\\\\([ \\t]*)(%.*)*\\n/g, continuationReplacement);\t// take care of line continuations right away, but keep the same number of characters\n\t\tvar lines = strTune.split('\\n');\n\t\tif (parseCommon.last(lines).length === 0)\t// remove the blank line we added above.\n\t\t\tlines.pop();\n\t\ttry {\n\t\t\tif (switches.format) {\n\t\t\t\tparseDirective.globalFormatting(switches.format);\n\t\t\t}\n\t\t\tparseCommon.each(lines,  function(line) {\n\t\t\t\tif (switches.header_only && multilineVars.is_in_header === false)\n\t\t\t\t\tthrow \"normal_abort\";\n\t\t\t\tif (switches.stop_on_warning && multilineVars.warnings)\n\t\t\t\t\tthrow \"normal_abort\";\n\t\t\t\tif (multilineVars.is_in_history) {\n\t\t\t\t\tif (line.charAt(1) === ':') {\n\t\t\t\t\t\tmultilineVars.is_in_history = false;\n\t\t\t\t\t\tparseLine(line);\n\t\t\t\t\t} else\n\t\t\t\t\t\ttune.addMetaText(\"history\", tokenizer.translateString(tokenizer.stripComment(line)));\n\t\t\t\t} else if (multilineVars.inTextBlock) {\n\t\t\t\t\tif (parseCommon.startsWith(line, \"%%endtext\")) {\n\t\t\t\t\t\t//tune.addMetaText(\"textBlock\", multilineVars.textBlock);\n\t\t\t\t\t\ttune.addText(multilineVars.textBlock);\n\t\t\t\t\t\tmultilineVars.inTextBlock = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (parseCommon.startsWith(line, \"%%\"))\n\t\t\t\t\t\t\tmultilineVars.textBlock += ' ' + line.substring(2);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmultilineVars.textBlock += ' ' + line;\n\t\t\t\t\t}\n\t\t\t\t} else if (multilineVars.inPsBlock) {\n\t\t\t\t\tif (parseCommon.startsWith(line, \"%%endps\")) {\n\t\t\t\t\t\t// Just ignore postscript\n\t\t\t\t\t\tmultilineVars.inPsBlock = false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tmultilineVars.textBlock += ' ' + line;\n\t\t\t\t} else\n\t\t\t\t\tparseLine(line);\n\t\t\t\tmultilineVars.iChar += line.length + 1;\n\t\t\t});\n\t\t\tvar ph = 11*72;\n\t\t\tvar pl = 8.5*72;\n\t\t\tswitch (multilineVars.papersize) {\n\t\t\t\t//case \"letter\": ph = 11*72; pl = 8.5*72; break;\n\t\t\t\tcase \"legal\": ph = 14*72; pl = 8.5*72; break;\n\t\t\t\tcase \"A4\": ph = 11.7*72; pl = 8.3*72; break;\n\t\t\t}\n\t\t\tif (multilineVars.landscape) {\n\t\t\t\tvar x = ph;\n\t\t\t\tph = pl;\n\t\t\t\tpl = x;\n\t\t\t}\n\t\t\tmultilineVars.openSlurs = tune.cleanUp(pl, ph, multilineVars.barsperstaff, multilineVars.staffnonote, multilineVars.openSlurs);\n\t\t} catch (err) {\n\t\t\tif (err !== \"normal_abort\")\n\t\t\t\tthrow err;\n\t\t}\n\t\tif (switches.hint_measures) {\n\t\t\taddHintMeasures();\n\t\t}\n\t};\n};\n\nmodule.exports = Parse;\n"]},"metadata":{},"sourceType":"script"}