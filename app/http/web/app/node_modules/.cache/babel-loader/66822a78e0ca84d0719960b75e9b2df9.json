{"ast":null,"code":"//    abc_transpose.js: Handles the automatic transposition of key signatures, chord symbols, and notes.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar transpose = {};\nvar keyIndex = {\n  'C': 0,\n  'C#': 1,\n  'Db': 1,\n  'D': 2,\n  'D#': 3,\n  'Eb': 3,\n  'E': 4,\n  'F': 5,\n  'F#': 6,\n  'Gb': 6,\n  'G': 7,\n  'G#': 8,\n  'Ab': 8,\n  'A': 9,\n  'A#': 10,\n  'Bb': 10,\n  'B': 11\n};\nvar newKey = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'];\nvar newKeyMinor = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'Bb', 'B'];\n\ntranspose.keySignature = function (multilineVars, keys, keyName, root, acc, localTranspose) {\n  if (!localTranspose) localTranspose = 0;\n  multilineVars.localTransposeVerticalMovement = 0;\n  multilineVars.localTransposePreferFlats = false;\n  var k = keys[keyName];\n  if (!k) return multilineVars.key; // If the key isn't in the list, it is non-standard. We won't attempt to transpose it.\n\n  multilineVars.localTranspose = (multilineVars.globalTranspose ? multilineVars.globalTranspose : 0) + localTranspose;\n  if (!multilineVars.localTranspose) return {\n    accidentals: k,\n    root: root,\n    acc: acc\n  };\n  multilineVars.globalTransposeOrigKeySig = k;\n\n  if (multilineVars.localTranspose % 12 === 0) {\n    multilineVars.localTransposeVerticalMovement = multilineVars.localTranspose / 12 * 7;\n    return {\n      accidentals: k,\n      root: root,\n      acc: acc\n    };\n  }\n\n  var baseKey = keyName[0];\n\n  if (keyName[1] === 'b' || keyName[1] === '#') {\n    baseKey += keyName[1];\n    keyName = keyName.substr(2);\n  } else keyName = keyName.substr(1);\n\n  var index = keyIndex[baseKey] + multilineVars.localTranspose;\n\n  while (index < 0) index += 12;\n\n  if (index > 11) index = index % 12;\n  var newKeyName = keyName[0] === 'm' ? newKeyMinor[index] : newKey[index];\n  var transposedKey = newKeyName + keyName;\n  var newKeySig = keys[transposedKey];\n  if (newKeySig.length > 0 && newKeySig[0].acc === 'flat') multilineVars.localTransposePreferFlats = true;\n  var distance = transposedKey.charCodeAt(0) - baseKey.charCodeAt(0);\n\n  if (multilineVars.localTranspose > 0) {\n    if (distance < 0) distance += 7;else if (distance === 0) {\n      // There's a funny thing that happens when the key changes only an accidental's distance, for instance, from Ab to A.\n      // If the distance is positive (we are raising pitch), and the change is higher (that is, Ab -> A), then raise an octave.\n      // This test is easier because we know the keys are not equal (or we wouldn't get this far), so if the base key is a flat key, then\n      // the transposed key must be higher. Likewise, if the transposed key is sharp, then the base key must be lower. And one\n      // of those two things must be true because they are not both natural.\n      if (baseKey[1] === '#' || transposedKey[1] === 'b') distance += 7;\n    }\n  } else if (multilineVars.localTranspose < 0) {\n    if (distance > 0) distance -= 7;else if (distance === 0) {\n      // There's a funny thing that happens when the key changes only an accidental's distance, for instance, from Ab to A.\n      // If the distance is negative (we are dropping pitch), and the change is lower (that is, A -> Ab), then drop an octave.\n      if (baseKey[1] === 'b' || transposedKey[1] === '#') distance -= 7;\n    }\n  }\n\n  if (multilineVars.localTranspose > 0) multilineVars.localTransposeVerticalMovement = distance + Math.floor(multilineVars.localTranspose / 12) * 7;else multilineVars.localTransposeVerticalMovement = distance + Math.ceil(multilineVars.localTranspose / 12) * 7;\n  return {\n    accidentals: newKeySig,\n    root: newKeyName[0],\n    acc: newKeyName.length > 1 ? newKeyName[1] : \"\"\n  };\n};\n\nvar sharpChords = ['C', 'C♯', 'D', \"D♯\", 'E', 'F', \"F♯\", 'G', 'G♯', 'A', 'A♯', 'B'];\nvar flatChords = ['C', 'D♭', 'D', 'E♭', 'E', 'F', 'G♭', 'G', 'A♭', 'A', 'B♭', 'B'];\n\ntranspose.chordName = function (multilineVars, chord) {\n  if (multilineVars.localTranspose && multilineVars.localTranspose % 12 !== 0) {\n    // The chords are the same if it is an exact octave change.\n    var transposeFactor = multilineVars.localTranspose;\n\n    while (transposeFactor < 0) transposeFactor += 12;\n\n    if (transposeFactor > 11) transposeFactor = transposeFactor % 12;\n    chord = chord.replace(/C♭/g, \"`~11`\");\n    chord = chord.replace(/D♭/g, \"`~1`\");\n    chord = chord.replace(/E♭/g, \"`~3`\");\n    chord = chord.replace(/F♭/g, \"`~4`\");\n    chord = chord.replace(/G♭/g, \"`~6`\");\n    chord = chord.replace(/A♭/g, \"`~8`\");\n    chord = chord.replace(/B♭/g, \"`~10`\");\n    chord = chord.replace(/C♯/g, \"`~1`\");\n    chord = chord.replace(/D♯/g, \"`~3`\");\n    chord = chord.replace(/E♯/g, \"`~5`\");\n    chord = chord.replace(/F♯/g, \"`~6`\");\n    chord = chord.replace(/G♯/g, \"`~8`\");\n    chord = chord.replace(/A♯/g, \"`~10`\");\n    chord = chord.replace(/B♯/g, \"`~0`\");\n    chord = chord.replace(/C/g, \"`~0`\");\n    chord = chord.replace(/D/g, \"`~2`\");\n    chord = chord.replace(/E/g, \"`~4`\");\n    chord = chord.replace(/F/g, \"`~5`\");\n    chord = chord.replace(/G/g, \"`~7`\");\n    chord = chord.replace(/A/g, \"`~9`\");\n    chord = chord.replace(/B/g, \"`~11`\");\n    var arr = chord.split(\"`\");\n\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i][0] === '~') {\n        var chordNum = parseInt(arr[i].substr(1), 10);\n        chordNum += transposeFactor;\n        if (chordNum > 11) chordNum -= 12;\n        arr[i] = multilineVars.localTransposePreferFlats ? flatChords[chordNum] : sharpChords[chordNum];\n      }\n    }\n\n    chord = arr.join(\"\");\n  }\n\n  return chord;\n};\n\nvar pitchToLetter = ['c', 'd', 'e', 'f', 'g', 'a', 'b'];\n\nfunction accidentalChange(origPitch, newPitch, accidental, origKeySig, newKeySig) {\n  var origPitchLetter = pitchToLetter[(origPitch + 49) % 7]; // Make sure it is a positive pitch before normalizing.\n\n  var origAccidental = 0;\n\n  for (var i = 0; i < origKeySig.length; i++) {\n    if (origKeySig[i].note.toLowerCase() === origPitchLetter) origAccidental = accidentals[origKeySig[i].acc];\n  }\n\n  var currentAccidental = accidentals[accidental];\n  var delta = currentAccidental - origAccidental;\n  var newPitchLetter = pitchToLetter[(newPitch + 49) % 7]; // Make sure it is a positive pitch before normalizing.\n\n  var newAccidental = 0;\n\n  for (var j = 0; j < newKeySig.accidentals.length; j++) {\n    if (newKeySig.accidentals[j].note.toLowerCase() === newPitchLetter) newAccidental = accidentals[newKeySig.accidentals[j].acc];\n  }\n\n  var calcAccidental = delta + newAccidental;\n\n  if (calcAccidental < -2) {\n    newPitch--;\n    calcAccidental += newPitchLetter === 'c' || newPitchLetter === 'f' ? 1 : 2;\n  }\n\n  if (calcAccidental > 2) {\n    newPitch++;\n    calcAccidental -= newPitchLetter === 'b' || newPitchLetter === 'e' ? 1 : 2;\n  }\n\n  return [newPitch, calcAccidental];\n}\n\nvar accidentals = {\n  dblflat: -2,\n  flat: -1,\n  natural: 0,\n  sharp: 1,\n  dblsharp: 2\n};\nvar accidentals2 = {\n  \"-2\": \"dblflat\",\n  \"-1\": \"flat\",\n  \"0\": \"natural\",\n  \"1\": \"sharp\",\n  \"2\": \"dblsharp\"\n};\n\ntranspose.note = function (multilineVars, el) {\n  // the \"el\" that is passed in has el.accidental, and el.pitch. \"pitch\" is the vertical position (0=middle C)\n  // localTranspose is the number of half steps\n  // localTransposeVerticalMovement is the vertical distance to move.\n  if (!multilineVars.localTranspose) return;\n  var origPitch = el.pitch;\n  el.pitch = el.pitch + multilineVars.localTransposeVerticalMovement;\n\n  if (el.accidental) {\n    var ret = accidentalChange(origPitch, el.pitch, el.accidental, multilineVars.globalTransposeOrigKeySig, multilineVars.key);\n    el.pitch = ret[0];\n    el.accidental = accidentals2[ret[1]];\n  }\n};\n\nmodule.exports = transpose;","map":{"version":3,"sources":["/Users/philbrockman/coding/MusicalGens/app/http/web/app/node_modules/abcjs/src/parse/abc_transpose.js"],"names":["transpose","keyIndex","newKey","newKeyMinor","keySignature","multilineVars","keys","keyName","root","acc","localTranspose","localTransposeVerticalMovement","localTransposePreferFlats","k","key","globalTranspose","accidentals","globalTransposeOrigKeySig","baseKey","substr","index","newKeyName","transposedKey","newKeySig","length","distance","charCodeAt","Math","floor","ceil","sharpChords","flatChords","chordName","chord","transposeFactor","replace","arr","split","i","chordNum","parseInt","join","pitchToLetter","accidentalChange","origPitch","newPitch","accidental","origKeySig","origPitchLetter","origAccidental","note","toLowerCase","currentAccidental","delta","newPitchLetter","newAccidental","j","calcAccidental","dblflat","flat","natural","sharp","dblsharp","accidentals2","el","pitch","ret","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,SAAS,GAAG,EAAhB;AAEA,IAAIC,QAAQ,GAAG;AACd,OAAK,CADS;AAEd,QAAM,CAFQ;AAGd,QAAM,CAHQ;AAId,OAAK,CAJS;AAKd,QAAM,CALQ;AAMd,QAAM,CANQ;AAOd,OAAK,CAPS;AAQd,OAAK,CARS;AASd,QAAM,CATQ;AAUd,QAAM,CAVQ;AAWd,OAAK,CAXS;AAYd,QAAM,CAZQ;AAad,QAAM,CAbQ;AAcd,OAAK,CAdS;AAed,QAAM,EAfQ;AAgBd,QAAM,EAhBQ;AAiBd,OAAK;AAjBS,CAAf;AAmBA,IAAIC,MAAM,GAAG,CAAC,GAAD,EAAM,IAAN,EAAY,GAAZ,EAAiB,IAAjB,EAAuB,GAAvB,EAA4B,GAA5B,EAAiC,IAAjC,EAAuC,GAAvC,EAA4C,IAA5C,EAAkD,GAAlD,EAAuD,IAAvD,EAA6D,GAA7D,CAAb;AACA,IAAIC,WAAW,GAAG,CAAC,GAAD,EAAM,IAAN,EAAY,GAAZ,EAAiB,IAAjB,EAAuB,GAAvB,EAA4B,GAA5B,EAAiC,IAAjC,EAAuC,GAAvC,EAA4C,IAA5C,EAAkD,GAAlD,EAAuD,IAAvD,EAA6D,GAA7D,CAAlB;;AAEAH,SAAS,CAACI,YAAV,GAAyB,UAASC,aAAT,EAAwBC,IAAxB,EAA8BC,OAA9B,EAAuCC,IAAvC,EAA6CC,GAA7C,EAAkDC,cAAlD,EAAkE;AAC1F,MAAI,CAACA,cAAL,EAAqBA,cAAc,GAAG,CAAjB;AACrBL,EAAAA,aAAa,CAACM,8BAAd,GAA+C,CAA/C;AACAN,EAAAA,aAAa,CAACO,yBAAd,GAA0C,KAA1C;AACA,MAAIC,CAAC,GAAGP,IAAI,CAACC,OAAD,CAAZ;AACA,MAAI,CAACM,CAAL,EAAQ,OAAOR,aAAa,CAACS,GAArB,CALkF,CAKxD;;AAClCT,EAAAA,aAAa,CAACK,cAAd,GAA+B,CAACL,aAAa,CAACU,eAAd,GAAgCV,aAAa,CAACU,eAA9C,GAAgE,CAAjE,IAAsEL,cAArG;AAEA,MAAI,CAACL,aAAa,CAACK,cAAnB,EACC,OAAO;AAAEM,IAAAA,WAAW,EAAEH,CAAf;AAAkBL,IAAAA,IAAI,EAAEA,IAAxB;AAA8BC,IAAAA,GAAG,EAAEA;AAAnC,GAAP;AACDJ,EAAAA,aAAa,CAACY,yBAAd,GAA0CJ,CAA1C;;AACA,MAAIR,aAAa,CAACK,cAAd,GAA+B,EAA/B,KAAsC,CAA1C,EAA6C;AAC5CL,IAAAA,aAAa,CAACM,8BAAd,GAAgDN,aAAa,CAACK,cAAd,GAA+B,EAAhC,GAAsC,CAArF;AACA,WAAO;AAAEM,MAAAA,WAAW,EAAEH,CAAf;AAAkBL,MAAAA,IAAI,EAAEA,IAAxB;AAA8BC,MAAAA,GAAG,EAAEA;AAAnC,KAAP;AACA;;AAED,MAAIS,OAAO,GAAGX,OAAO,CAAC,CAAD,CAArB;;AACA,MAAIA,OAAO,CAAC,CAAD,CAAP,KAAe,GAAf,IAAsBA,OAAO,CAAC,CAAD,CAAP,KAAe,GAAzC,EAA8C;AAC7CW,IAAAA,OAAO,IAAIX,OAAO,CAAC,CAAD,CAAlB;AACAA,IAAAA,OAAO,GAAGA,OAAO,CAACY,MAAR,CAAe,CAAf,CAAV;AACA,GAHD,MAICZ,OAAO,GAAGA,OAAO,CAACY,MAAR,CAAe,CAAf,CAAV;;AACD,MAAIC,KAAK,GAAGnB,QAAQ,CAACiB,OAAD,CAAR,GAAoBb,aAAa,CAACK,cAA9C;;AACA,SAAOU,KAAK,GAAG,CAAf,EAAkBA,KAAK,IAAI,EAAT;;AAClB,MAAIA,KAAK,GAAG,EAAZ,EAAgBA,KAAK,GAAGA,KAAK,GAAG,EAAhB;AAChB,MAAIC,UAAU,GAAId,OAAO,CAAC,CAAD,CAAP,KAAe,GAAf,GAAqBJ,WAAW,CAACiB,KAAD,CAAhC,GAA0ClB,MAAM,CAACkB,KAAD,CAAlE;AACA,MAAIE,aAAa,GAAGD,UAAU,GAAGd,OAAjC;AACA,MAAIgB,SAAS,GAAGjB,IAAI,CAACgB,aAAD,CAApB;AACA,MAAIC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,CAAad,GAAb,KAAqB,MAAjD,EACCJ,aAAa,CAACO,yBAAd,GAA0C,IAA1C;AACD,MAAIa,QAAQ,GAAGH,aAAa,CAACI,UAAd,CAAyB,CAAzB,IAA8BR,OAAO,CAACQ,UAAR,CAAmB,CAAnB,CAA7C;;AACA,MAAIrB,aAAa,CAACK,cAAd,GAA+B,CAAnC,EAAsC;AACrC,QAAIe,QAAQ,GAAG,CAAf,EACCA,QAAQ,IAAI,CAAZ,CADD,KAEK,IAAIA,QAAQ,KAAK,CAAjB,EAAoB;AACxB;AACA;AACA;AACA;AACA;AACA,UAAIP,OAAO,CAAC,CAAD,CAAP,KAAe,GAAf,IAAuBI,aAAa,CAAC,CAAD,CAAb,KAAqB,GAAhD,EACCG,QAAQ,IAAI,CAAZ;AACD;AACD,GAZD,MAYO,IAAIpB,aAAa,CAACK,cAAd,GAA+B,CAAnC,EAAsC;AAC5C,QAAIe,QAAQ,GAAG,CAAf,EACCA,QAAQ,IAAI,CAAZ,CADD,KAEK,IAAIA,QAAQ,KAAK,CAAjB,EAAoB;AACxB;AACA;AACA,UAAIP,OAAO,CAAC,CAAD,CAAP,KAAe,GAAf,IAAuBI,aAAa,CAAC,CAAD,CAAb,KAAqB,GAAhD,EACCG,QAAQ,IAAI,CAAZ;AACD;AACD;;AAED,MAAIpB,aAAa,CAACK,cAAd,GAA+B,CAAnC,EACCL,aAAa,CAACM,8BAAd,GAA+Cc,QAAQ,GAAGE,IAAI,CAACC,KAAL,CAAWvB,aAAa,CAACK,cAAd,GAA+B,EAA1C,IAAgD,CAA1G,CADD,KAGCL,aAAa,CAACM,8BAAd,GAA+Cc,QAAQ,GAAGE,IAAI,CAACE,IAAL,CAAUxB,aAAa,CAACK,cAAd,GAA+B,EAAzC,IAA+C,CAAzG;AACD,SAAO;AAAEM,IAAAA,WAAW,EAAEO,SAAf;AAA0Bf,IAAAA,IAAI,EAAEa,UAAU,CAAC,CAAD,CAA1C;AAA+CZ,IAAAA,GAAG,EAAEY,UAAU,CAACG,MAAX,GAAoB,CAApB,GAAwBH,UAAU,CAAC,CAAD,CAAlC,GAAwC;AAA5F,GAAP;AACA,CA3DD;;AA6DA,IAAIS,WAAW,GAAG,CAAE,GAAF,EAAO,IAAP,EAAa,GAAb,EAAkB,IAAlB,EAAwB,GAAxB,EAA6B,GAA7B,EAAkC,IAAlC,EAAwC,GAAxC,EAA6C,IAA7C,EAAmD,GAAnD,EAAwD,IAAxD,EAA8D,GAA9D,CAAlB;AACA,IAAIC,UAAU,GAAG,CAAE,GAAF,EAAO,IAAP,EAAa,GAAb,EAAkB,IAAlB,EAAwB,GAAxB,EAA6B,GAA7B,EAAkC,IAAlC,EAAwC,GAAxC,EAA6C,IAA7C,EAAmD,GAAnD,EAAwD,IAAxD,EAA8D,GAA9D,CAAjB;;AAEA/B,SAAS,CAACgC,SAAV,GAAsB,UAAS3B,aAAT,EAAwB4B,KAAxB,EAA+B;AACpD,MAAI5B,aAAa,CAACK,cAAd,IAAiCL,aAAa,CAACK,cAAd,GAA+B,EAA/B,KAAsC,CAA3E,EAA+E;AAAE;AAChF,QAAIwB,eAAe,GAAG7B,aAAa,CAACK,cAApC;;AACA,WAAOwB,eAAe,GAAG,CAAzB,EAA4BA,eAAe,IAAI,EAAnB;;AAC5B,QAAIA,eAAe,GAAG,EAAtB,EAA0BA,eAAe,GAAGA,eAAe,GAAG,EAApC;AAC1BD,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,OAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,OAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,OAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,MAApB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,MAApB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,MAApB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,MAApB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,MAApB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,MAApB,CAAR;AACAF,IAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,OAApB,CAAR;AACA,QAAIC,GAAG,GAAGH,KAAK,CAACI,KAAN,CAAY,GAAZ,CAAV;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAAG,CAACZ,MAAxB,EAAgCc,CAAC,EAAjC,EAAqC;AACpC,UAAIF,GAAG,CAACE,CAAD,CAAH,CAAO,CAAP,MAAc,GAAlB,EAAuB;AACtB,YAAIC,QAAQ,GAAGC,QAAQ,CAACJ,GAAG,CAACE,CAAD,CAAH,CAAOnB,MAAP,CAAc,CAAd,CAAD,EAAkB,EAAlB,CAAvB;AACAoB,QAAAA,QAAQ,IAAIL,eAAZ;AACA,YAAIK,QAAQ,GAAG,EAAf,EAAmBA,QAAQ,IAAI,EAAZ;AACnBH,QAAAA,GAAG,CAACE,CAAD,CAAH,GAASjC,aAAa,CAACO,yBAAd,GAA0CmB,UAAU,CAACQ,QAAD,CAApD,GAAiET,WAAW,CAACS,QAAD,CAArF;AACA;AACD;;AACDN,IAAAA,KAAK,GAAGG,GAAG,CAACK,IAAJ,CAAS,EAAT,CAAR;AACA;;AACD,SAAOR,KAAP;AACA,CAtCD;;AAwCA,IAAIS,aAAa,GAAG,CAAE,GAAF,EAAO,GAAP,EAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,EAA2B,GAA3B,EAAgC,GAAhC,CAApB;;AACA,SAASC,gBAAT,CAA0BC,SAA1B,EAAqCC,QAArC,EAA+CC,UAA/C,EAA2DC,UAA3D,EAAuExB,SAAvE,EAAkF;AACjF,MAAIyB,eAAe,GAAGN,aAAa,CAAC,CAACE,SAAS,GAAG,EAAb,IAAmB,CAApB,CAAnC,CADiF,CACtB;;AAC3D,MAAIK,cAAc,GAAG,CAArB;;AACA,OAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,UAAU,CAACvB,MAA/B,EAAuCc,CAAC,EAAxC,EAA4C;AAC3C,QAAIS,UAAU,CAACT,CAAD,CAAV,CAAcY,IAAd,CAAmBC,WAAnB,OAAqCH,eAAzC,EACCC,cAAc,GAAGjC,WAAW,CAAC+B,UAAU,CAACT,CAAD,CAAV,CAAc7B,GAAf,CAA5B;AACD;;AAED,MAAI2C,iBAAiB,GAAGpC,WAAW,CAAC8B,UAAD,CAAnC;AACA,MAAIO,KAAK,GAAGD,iBAAiB,GAAGH,cAAhC;AAEA,MAAIK,cAAc,GAAGZ,aAAa,CAAC,CAACG,QAAQ,GAAG,EAAZ,IAAkB,CAAnB,CAAlC,CAXiF,CAWxB;;AACzD,MAAIU,aAAa,GAAG,CAApB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,SAAS,CAACP,WAAV,CAAsBQ,MAA1C,EAAkDgC,CAAC,EAAnD,EAAuD;AACtD,QAAIjC,SAAS,CAACP,WAAV,CAAsBwC,CAAtB,EAAyBN,IAAzB,CAA8BC,WAA9B,OAAgDG,cAApD,EACCC,aAAa,GAAGvC,WAAW,CAACO,SAAS,CAACP,WAAV,CAAsBwC,CAAtB,EAAyB/C,GAA1B,CAA3B;AACD;;AACD,MAAIgD,cAAc,GAAGJ,KAAK,GAAGE,aAA7B;;AACA,MAAIE,cAAc,GAAG,CAAC,CAAtB,EAAyB;AACxBZ,IAAAA,QAAQ;AACRY,IAAAA,cAAc,IAAKH,cAAc,KAAK,GAAnB,IAA0BA,cAAc,KAAK,GAA9C,GAAqD,CAArD,GAAyD,CAA3E;AACA;;AACD,MAAIG,cAAc,GAAG,CAArB,EAAwB;AACvBZ,IAAAA,QAAQ;AACRY,IAAAA,cAAc,IAAKH,cAAc,KAAK,GAAnB,IAA0BA,cAAc,KAAK,GAA9C,GAAqD,CAArD,GAAyD,CAA3E;AACA;;AACD,SAAO,CAACT,QAAD,EAAWY,cAAX,CAAP;AACA;;AAED,IAAIzC,WAAW,GAAG;AACjB0C,EAAAA,OAAO,EAAE,CAAC,CADO;AAEjBC,EAAAA,IAAI,EAAE,CAAC,CAFU;AAGjBC,EAAAA,OAAO,EAAE,CAHQ;AAIjBC,EAAAA,KAAK,EAAE,CAJU;AAKjBC,EAAAA,QAAQ,EAAE;AALO,CAAlB;AAOA,IAAIC,YAAY,GAAG;AAClB,QAAM,SADY;AAElB,QAAM,MAFY;AAGlB,OAAK,SAHa;AAIlB,OAAK,OAJa;AAKlB,OAAK;AALa,CAAnB;;AAOA/D,SAAS,CAACkD,IAAV,GAAiB,UAAS7C,aAAT,EAAwB2D,EAAxB,EAA4B;AAC5C;AACA;AACA;AACA,MAAI,CAAC3D,aAAa,CAACK,cAAnB,EACC;AACD,MAAIkC,SAAS,GAAGoB,EAAE,CAACC,KAAnB;AACAD,EAAAA,EAAE,CAACC,KAAH,GAAWD,EAAE,CAACC,KAAH,GAAW5D,aAAa,CAACM,8BAApC;;AAEA,MAAIqD,EAAE,CAAClB,UAAP,EAAmB;AAClB,QAAIoB,GAAG,GAAGvB,gBAAgB,CAACC,SAAD,EAAYoB,EAAE,CAACC,KAAf,EAAsBD,EAAE,CAAClB,UAAzB,EAAqCzC,aAAa,CAACY,yBAAnD,EAA8EZ,aAAa,CAACS,GAA5F,CAA1B;AACAkD,IAAAA,EAAE,CAACC,KAAH,GAAWC,GAAG,CAAC,CAAD,CAAd;AACAF,IAAAA,EAAE,CAAClB,UAAH,GAAgBiB,YAAY,CAACG,GAAG,CAAC,CAAD,CAAJ,CAA5B;AACA;AAED,CAfD;;AAiBAC,MAAM,CAACC,OAAP,GAAiBpE,SAAjB","sourcesContent":["//    abc_transpose.js: Handles the automatic transposition of key signatures, chord symbols, and notes.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar transpose = {};\n\nvar keyIndex = {\n\t'C': 0,\n\t'C#': 1,\n\t'Db': 1,\n\t'D': 2,\n\t'D#': 3,\n\t'Eb': 3,\n\t'E': 4,\n\t'F': 5,\n\t'F#': 6,\n\t'Gb': 6,\n\t'G': 7,\n\t'G#': 8,\n\t'Ab': 8,\n\t'A': 9,\n\t'A#': 10,\n\t'Bb': 10,\n\t'B': 11\n};\nvar newKey = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'];\nvar newKeyMinor = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'Bb', 'B'];\n\ntranspose.keySignature = function(multilineVars, keys, keyName, root, acc, localTranspose) {\n\tif (!localTranspose) localTranspose = 0;\n\tmultilineVars.localTransposeVerticalMovement = 0;\n\tmultilineVars.localTransposePreferFlats = false;\n\tvar k = keys[keyName];\n\tif (!k) return multilineVars.key; // If the key isn't in the list, it is non-standard. We won't attempt to transpose it.\n\tmultilineVars.localTranspose = (multilineVars.globalTranspose ? multilineVars.globalTranspose : 0) + localTranspose;\n\n\tif (!multilineVars.localTranspose)\n\t\treturn { accidentals: k, root: root, acc: acc };\n\tmultilineVars.globalTransposeOrigKeySig = k;\n\tif (multilineVars.localTranspose % 12 === 0) {\n\t\tmultilineVars.localTransposeVerticalMovement = (multilineVars.localTranspose / 12) * 7;\n\t\treturn { accidentals: k, root: root, acc: acc };\n\t}\n\n\tvar baseKey = keyName[0];\n\tif (keyName[1] === 'b' || keyName[1] === '#') {\n\t\tbaseKey += keyName[1];\n\t\tkeyName = keyName.substr(2);\n\t} else\n\t\tkeyName = keyName.substr(1);\n\tvar index = keyIndex[baseKey] + multilineVars.localTranspose;\n\twhile (index < 0) index += 12;\n\tif (index > 11) index = index % 12;\n\tvar newKeyName = (keyName[0] === 'm' ? newKeyMinor[index] : newKey[index]);\n\tvar transposedKey = newKeyName + keyName;\n\tvar newKeySig = keys[transposedKey];\n\tif (newKeySig.length > 0 && newKeySig[0].acc === 'flat')\n\t\tmultilineVars.localTransposePreferFlats = true;\n\tvar distance = transposedKey.charCodeAt(0) - baseKey.charCodeAt(0);\n\tif (multilineVars.localTranspose > 0) {\n\t\tif (distance < 0)\n\t\t\tdistance += 7;\n\t\telse if (distance === 0) {\n\t\t\t// There's a funny thing that happens when the key changes only an accidental's distance, for instance, from Ab to A.\n\t\t\t// If the distance is positive (we are raising pitch), and the change is higher (that is, Ab -> A), then raise an octave.\n\t\t\t// This test is easier because we know the keys are not equal (or we wouldn't get this far), so if the base key is a flat key, then\n\t\t\t// the transposed key must be higher. Likewise, if the transposed key is sharp, then the base key must be lower. And one\n\t\t\t// of those two things must be true because they are not both natural.\n\t\t\tif (baseKey[1] === '#' ||  transposedKey[1] === 'b')\n\t\t\t\tdistance += 7;\n\t\t}\n\t} else if (multilineVars.localTranspose < 0) {\n\t\tif (distance > 0)\n\t\t\tdistance -= 7;\n\t\telse if (distance === 0) {\n\t\t\t// There's a funny thing that happens when the key changes only an accidental's distance, for instance, from Ab to A.\n\t\t\t// If the distance is negative (we are dropping pitch), and the change is lower (that is, A -> Ab), then drop an octave.\n\t\t\tif (baseKey[1] === 'b' ||  transposedKey[1] === '#')\n\t\t\t\tdistance -= 7;\n\t\t}\n\t}\n\n\tif (multilineVars.localTranspose > 0)\n\t\tmultilineVars.localTransposeVerticalMovement = distance + Math.floor(multilineVars.localTranspose / 12) * 7;\n\telse\n\t\tmultilineVars.localTransposeVerticalMovement = distance + Math.ceil(multilineVars.localTranspose / 12) * 7;\n\treturn { accidentals: newKeySig, root: newKeyName[0], acc: newKeyName.length > 1 ? newKeyName[1] : \"\" };\n};\n\nvar sharpChords = [ 'C', 'C♯', 'D', \"D♯\", 'E', 'F', \"F♯\", 'G', 'G♯', 'A', 'A♯', 'B'];\nvar flatChords = [ 'C', 'D♭', 'D', 'E♭', 'E', 'F', 'G♭', 'G', 'A♭', 'A', 'B♭', 'B'];\n\ntranspose.chordName = function(multilineVars, chord) {\n\tif (multilineVars.localTranspose && (multilineVars.localTranspose % 12 !== 0)) { // The chords are the same if it is an exact octave change.\n\t\tvar transposeFactor = multilineVars.localTranspose;\n\t\twhile (transposeFactor < 0) transposeFactor += 12;\n\t\tif (transposeFactor > 11) transposeFactor = transposeFactor % 12;\n\t\tchord = chord.replace(/C♭/g, \"`~11`\");\n\t\tchord = chord.replace(/D♭/g, \"`~1`\");\n\t\tchord = chord.replace(/E♭/g, \"`~3`\");\n\t\tchord = chord.replace(/F♭/g, \"`~4`\");\n\t\tchord = chord.replace(/G♭/g, \"`~6`\");\n\t\tchord = chord.replace(/A♭/g, \"`~8`\");\n\t\tchord = chord.replace(/B♭/g, \"`~10`\");\n\t\tchord = chord.replace(/C♯/g, \"`~1`\");\n\t\tchord = chord.replace(/D♯/g, \"`~3`\");\n\t\tchord = chord.replace(/E♯/g, \"`~5`\");\n\t\tchord = chord.replace(/F♯/g, \"`~6`\");\n\t\tchord = chord.replace(/G♯/g, \"`~8`\");\n\t\tchord = chord.replace(/A♯/g, \"`~10`\");\n\t\tchord = chord.replace(/B♯/g, \"`~0`\");\n\t\tchord = chord.replace(/C/g, \"`~0`\");\n\t\tchord = chord.replace(/D/g, \"`~2`\");\n\t\tchord = chord.replace(/E/g, \"`~4`\");\n\t\tchord = chord.replace(/F/g, \"`~5`\");\n\t\tchord = chord.replace(/G/g, \"`~7`\");\n\t\tchord = chord.replace(/A/g, \"`~9`\");\n\t\tchord = chord.replace(/B/g, \"`~11`\");\n\t\tvar arr = chord.split(\"`\");\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i][0] === '~') {\n\t\t\t\tvar chordNum = parseInt(arr[i].substr(1),10);\n\t\t\t\tchordNum += transposeFactor;\n\t\t\t\tif (chordNum > 11) chordNum -= 12;\n\t\t\t\tarr[i] = multilineVars.localTransposePreferFlats ? flatChords[chordNum] : sharpChords[chordNum];\n\t\t\t}\n\t\t}\n\t\tchord = arr.join(\"\");\n\t}\n\treturn chord;\n};\n\nvar pitchToLetter = [ 'c', 'd', 'e', 'f', 'g', 'a', 'b' ];\nfunction accidentalChange(origPitch, newPitch, accidental, origKeySig, newKeySig) {\n\tvar origPitchLetter = pitchToLetter[(origPitch + 49) % 7]; // Make sure it is a positive pitch before normalizing.\n\tvar origAccidental = 0;\n\tfor (var i = 0; i < origKeySig.length; i++) {\n\t\tif (origKeySig[i].note.toLowerCase() === origPitchLetter)\n\t\t\torigAccidental = accidentals[origKeySig[i].acc];\n\t}\n\n\tvar currentAccidental = accidentals[accidental];\n\tvar delta = currentAccidental - origAccidental;\n\n\tvar newPitchLetter = pitchToLetter[(newPitch + 49) % 7]; // Make sure it is a positive pitch before normalizing.\n\tvar newAccidental = 0;\n\tfor (var j = 0; j < newKeySig.accidentals.length; j++) {\n\t\tif (newKeySig.accidentals[j].note.toLowerCase() === newPitchLetter)\n\t\t\tnewAccidental = accidentals[newKeySig.accidentals[j].acc];\n\t}\n\tvar calcAccidental = delta + newAccidental;\n\tif (calcAccidental < -2) {\n\t\tnewPitch--;\n\t\tcalcAccidental += (newPitchLetter === 'c' || newPitchLetter === 'f') ? 1 : 2;\n\t}\n\tif (calcAccidental > 2) {\n\t\tnewPitch++;\n\t\tcalcAccidental -= (newPitchLetter === 'b' || newPitchLetter === 'e') ? 1 : 2;\n\t}\n\treturn [newPitch, calcAccidental];\n}\n\nvar accidentals = {\n\tdblflat: -2,\n\tflat: -1,\n\tnatural: 0,\n\tsharp: 1,\n\tdblsharp: 2\n};\nvar accidentals2 = {\n\t\"-2\": \"dblflat\",\n\t\"-1\": \"flat\",\n\t\"0\": \"natural\",\n\t\"1\": \"sharp\",\n\t\"2\": \"dblsharp\",\n};\ntranspose.note = function(multilineVars, el) {\n\t// the \"el\" that is passed in has el.accidental, and el.pitch. \"pitch\" is the vertical position (0=middle C)\n\t// localTranspose is the number of half steps\n\t// localTransposeVerticalMovement is the vertical distance to move.\n\tif (!multilineVars.localTranspose)\n\t\treturn;\n\tvar origPitch = el.pitch;\n\tel.pitch = el.pitch + multilineVars.localTransposeVerticalMovement;\n\n\tif (el.accidental) {\n\t\tvar ret = accidentalChange(origPitch, el.pitch, el.accidental, multilineVars.globalTransposeOrigKeySig, multilineVars.key);\n\t\tel.pitch = ret[0];\n\t\tel.accidental = accidentals2[ret[1]];\n\t}\n\n};\n\nmodule.exports = transpose;\n"]},"metadata":{},"sourceType":"script"}