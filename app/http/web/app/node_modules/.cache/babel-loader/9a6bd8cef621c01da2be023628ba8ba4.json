{"ast":null,"code":"/*! timidity. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nconst Debug = require('debug');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst fs = require('fs');\n\nconst LibTimidity = require('./libtimidity');\n\nconst debug = Debug('timidity');\nconst debugVerbose = Debug('timidity:verbose'); // Inlined at build time by 'brfs' browserify transform\n\nconst TIMIDITY_CFG = fs.readFileSync(__dirname + '/freepats.cfg', // eslint-disable-line node/no-path-concat\n'utf8');\nconst SAMPLE_RATE = 44100;\nconst AUDIO_FORMAT = 0x8010; // format of the rendered audio 's16'\n\nconst NUM_CHANNELS = 2; // stereo (2 channels)\n\nconst BYTES_PER_SAMPLE = 2 * NUM_CHANNELS;\nconst BUFFER_SIZE = 16384; // buffer size for each render() call\n\nconst AudioContext = typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext);\n\nclass Timidity extends EventEmitter {\n  constructor(baseUrl = '/') {\n    super();\n    this.destroyed = false;\n    if (!baseUrl.endsWith('/')) baseUrl += '/';\n    this._baseUrl = new URL(baseUrl, window.location.origin).href;\n    this._ready = false;\n    this._playing = false;\n    this._pendingFetches = {}; // instrument -> fetch\n\n    this._songPtr = 0;\n    this._bufferPtr = 0;\n    this._array = new Int16Array(BUFFER_SIZE * 2);\n    this._currentUrlOrBuf = null; // currently loading url or buf\n\n    this._interval = null;\n    this._startInterval = this._startInterval.bind(this);\n    this._stopInterval = this._stopInterval.bind(this); // If the Timidity constructor was not invoked inside a user-initiated event\n    // handler, then the AudioContext will be suspended. See:\n    // https://developers.google.com/web/updates/2017/09/autoplay-policy-changes\n\n    this._audioContext = new AudioContext(); // Start the 'onaudioprocess' events flowing\n\n    this._node = this._audioContext.createScriptProcessor(BUFFER_SIZE, 0, NUM_CHANNELS);\n    this._onAudioProcess = this._onAudioProcess.bind(this);\n\n    this._node.addEventListener('audioprocess', this._onAudioProcess);\n\n    this._node.connect(this._audioContext.destination);\n\n    LibTimidity({\n      locateFile: file => new URL(file, this._baseUrl).href\n    }).then(lib => {\n      this._lib = lib;\n\n      this._onLibReady();\n    });\n  }\n\n  _onLibReady() {\n    this._lib.FS.writeFile('/timidity.cfg', TIMIDITY_CFG);\n\n    const result = this._lib._mid_init('/timidity.cfg');\n\n    if (result !== 0) {\n      return this._destroy(new Error('Failed to initialize libtimidity'));\n    }\n\n    this._bufferPtr = this._lib._malloc(BUFFER_SIZE * BYTES_PER_SAMPLE);\n    debugVerbose('Initialized libtimidity');\n    this._ready = true;\n    this.emit('_ready');\n  }\n\n  async load(urlOrBuf) {\n    debug('load %o', urlOrBuf);\n    if (this.destroyed) throw new Error('load() called after destroy()'); // If the Timidity constructor was not invoked inside a user-initiated event\n    // handler, then the AudioContext will be suspended. Attempt to resume it.\n\n    this._audioContext.resume(); // If a song already exists, destroy it before starting a new one\n\n\n    if (this._songPtr) this._destroySong();\n    this.emit('unstarted');\n\n    this._stopInterval();\n\n    if (!this._ready) return this.once('_ready', () => this.load(urlOrBuf));\n    this.emit('buffering'); // Save the url or buf to load. Allows detection of when a new interleaved\n    // load() starts so we can abort this load.\n\n    this._currentUrlOrBuf = urlOrBuf;\n    let midiBuf;\n\n    if (typeof urlOrBuf === 'string') {\n      midiBuf = await this._fetch(new URL(urlOrBuf, this._baseUrl)); // If another load() started while awaiting, abort this load\n\n      if (this._currentUrlOrBuf !== urlOrBuf) return;\n    } else if (urlOrBuf instanceof Uint8Array) {\n      midiBuf = urlOrBuf;\n    } else {\n      throw new Error('load() expects a `string` or `Uint8Array` argument');\n    }\n\n    let songPtr = this._loadSong(midiBuf); // Are we missing instrument files?\n\n\n    let missingCount = this._lib._mid_get_load_request_count(songPtr);\n\n    if (missingCount > 0) {\n      let missingInstruments = this._getMissingInstruments(songPtr, missingCount);\n\n      debugVerbose('Fetching instruments: %o', missingInstruments); // Wait for all instruments to load\n\n      await Promise.all(missingInstruments.map(instrument => this._fetchInstrument(instrument))); // If another load() started while awaiting, abort this load\n\n      if (this._currentUrlOrBuf !== urlOrBuf) return; // Retry the song load, now that instruments have been loaded\n\n      this._lib._mid_song_free(songPtr);\n\n      songPtr = this._loadSong(midiBuf); // Are we STILL missing instrument files? Then our General MIDI soundset\n      // is probably missing instrument files.\n\n      missingCount = this._lib._mid_get_load_request_count(songPtr); // Print out missing instrument names\n\n      if (missingCount > 0) {\n        missingInstruments = this._getMissingInstruments(songPtr, missingCount);\n        debug('Playing with missing instruments: %o', missingInstruments);\n      }\n    }\n\n    this._songPtr = songPtr;\n\n    this._lib._mid_song_start(this._songPtr);\n\n    debugVerbose('Song and instruments are loaded');\n  }\n\n  _getMissingInstruments(songPtr, missingCount) {\n    const missingInstruments = [];\n\n    for (let i = 0; i < missingCount; i++) {\n      const instrumentPtr = this._lib._mid_get_load_request(songPtr, i);\n\n      const instrument = this._lib.UTF8ToString(instrumentPtr);\n\n      missingInstruments.push(instrument);\n    }\n\n    return missingInstruments;\n  }\n\n  _loadSong(midiBuf) {\n    const optsPtr = this._lib._mid_alloc_options(SAMPLE_RATE, AUDIO_FORMAT, NUM_CHANNELS, BUFFER_SIZE); // Copy the MIDI buffer into the heap\n\n\n    const midiBufPtr = this._lib._malloc(midiBuf.byteLength);\n\n    this._lib.HEAPU8.set(midiBuf, midiBufPtr); // Create a stream\n\n\n    const iStreamPtr = this._lib._mid_istream_open_mem(midiBufPtr, midiBuf.byteLength); // Load the song\n\n\n    const songPtr = this._lib._mid_song_load(iStreamPtr, optsPtr); // Free resources no longer needed\n\n\n    this._lib._mid_istream_close(iStreamPtr);\n\n    this._lib._free(optsPtr);\n\n    this._lib._free(midiBufPtr);\n\n    if (songPtr === 0) {\n      return this._destroy(new Error('Failed to load MIDI file'));\n    }\n\n    return songPtr;\n  }\n\n  async _fetchInstrument(instrument) {\n    if (this._pendingFetches[instrument]) {\n      // If this instrument is already in the process of being fetched, return\n      // the existing promise to prevent duplicate fetches.\n      return this._pendingFetches[instrument];\n    }\n\n    const url = new URL(instrument, this._baseUrl);\n\n    const bufPromise = this._fetch(url);\n\n    this._pendingFetches[instrument] = bufPromise;\n    const buf = await bufPromise;\n\n    this._writeInstrumentFile(instrument, buf);\n\n    delete this._pendingFetches[instrument];\n    return buf;\n  }\n\n  _writeInstrumentFile(instrument, buf) {\n    const folderPath = instrument.split('/').slice(0, -1) // remove basename\n    .join('/');\n\n    this._mkdirp(folderPath);\n\n    this._lib.FS.writeFile(instrument, buf, {\n      encoding: 'binary'\n    });\n  }\n\n  _mkdirp(folderPath) {\n    const pathParts = folderPath.split('/');\n    let dirPath = '/';\n\n    for (let i = 0; i < pathParts.length; i++) {\n      const curPart = pathParts[i];\n\n      try {\n        this._lib.FS.mkdir(`${dirPath}${curPart}`);\n      } catch (err) {}\n\n      dirPath += `${curPart}/`;\n    }\n  }\n\n  async _fetch(url) {\n    const opts = {\n      mode: 'cors',\n      credentials: 'same-origin'\n    };\n    const response = await window.fetch(url, opts);\n    if (response.status !== 200) throw new Error(`Could not load ${url}`);\n    const arrayBuffer = await response.arrayBuffer();\n    const buf = new Uint8Array(arrayBuffer);\n    return buf;\n  }\n\n  play() {\n    debug('play');\n    if (this.destroyed) throw new Error('play() called after destroy()'); // If the Timidity constructor was not invoked inside a user-initiated event\n    // handler, then the AudioContext will be suspended. Attempt to resume it.\n\n    this._audioContext.resume();\n\n    this._playing = true;\n\n    if (this._ready && !this._currentUrlOrBuf) {\n      this.emit('playing');\n\n      this._startInterval();\n    }\n  }\n\n  _onAudioProcess(event) {\n    const sampleCount = this._songPtr && this._playing ? this._readMidiData() : 0;\n\n    if (sampleCount > 0 && this._currentUrlOrBuf) {\n      this._currentUrlOrBuf = null;\n      this.emit('playing');\n\n      this._startInterval();\n    }\n\n    const output0 = event.outputBuffer.getChannelData(0);\n    const output1 = event.outputBuffer.getChannelData(1);\n\n    for (let i = 0; i < sampleCount; i++) {\n      output0[i] = this._array[i * 2] / 0x7FFF;\n      output1[i] = this._array[i * 2 + 1] / 0x7FFF;\n    }\n\n    for (let i = sampleCount; i < BUFFER_SIZE; i++) {\n      output0[i] = 0;\n      output1[i] = 0;\n    }\n\n    if (this._songPtr && this._playing && sampleCount === 0) {\n      // Reached the end of the file\n      this.seek(0);\n      this.pause();\n\n      this._lib._mid_song_start(this._songPtr);\n\n      this.emit('ended');\n    }\n  }\n\n  _readMidiData() {\n    const byteCount = this._lib._mid_song_read_wave(this._songPtr, this._bufferPtr, BUFFER_SIZE * BYTES_PER_SAMPLE);\n\n    const sampleCount = byteCount / BYTES_PER_SAMPLE; // Was anything output? If not, don't bother copying anything\n\n    if (sampleCount === 0) {\n      return 0;\n    }\n\n    this._array.set(this._lib.HEAP16.subarray(this._bufferPtr / 2, (this._bufferPtr + byteCount) / 2));\n\n    return sampleCount;\n  }\n\n  pause() {\n    debug('pause');\n    if (this.destroyed) throw new Error('pause() called after destroy()');\n    this._playing = false;\n\n    this._stopInterval();\n\n    this.emit('paused');\n  }\n\n  seek(time) {\n    debug('seek %d', time);\n    if (this.destroyed) throw new Error('seek() called after destroy()');\n    if (!this._songPtr) return; // ignore seek if there is no song loaded yet\n\n    const timeMs = Math.floor(time * 1000);\n\n    this._lib._mid_song_seek(this._songPtr, timeMs);\n\n    this._onTimeupdate();\n  }\n\n  get currentTime() {\n    if (this.destroyed || !this._songPtr) return 0;\n    return this._lib._mid_song_get_time(this._songPtr) / 1000;\n  }\n\n  get duration() {\n    if (this.destroyed || !this._songPtr) return 1;\n    return this._lib._mid_song_get_total_time(this._songPtr) / 1000;\n  }\n  /**\n   * This event fires when the time indicated by the `currentTime` property\n   * has been updated.\n   */\n\n\n  _onTimeupdate() {\n    this.emit('timeupdate', this.currentTime);\n  }\n\n  _startInterval() {\n    this._onTimeupdate();\n\n    this._interval = setInterval(() => this._onTimeupdate(), 1000);\n  }\n\n  _stopInterval() {\n    this._onTimeupdate();\n\n    clearInterval(this._interval);\n    this._interval = null;\n  }\n\n  destroy() {\n    debug('destroy');\n    if (this.destroyed) throw new Error('destroy() called after destroy()');\n\n    this._destroy();\n  }\n\n  _destroy(err) {\n    if (this.destroyed) return;\n    this.destroyed = true;\n\n    this._stopInterval();\n\n    this._array = null;\n\n    if (this._songPtr) {\n      this._destroySong();\n    }\n\n    if (this._bufferPtr) {\n      this._lib._free(this._bufferPtr);\n\n      this._bufferPtr = 0;\n    }\n\n    if (this._node) {\n      this._node.disconnect();\n\n      this._node.removeEventListener('audioprocess', this._onAudioProcess);\n    }\n\n    if (this._audioContext) {\n      this._audioContext.close();\n    }\n\n    if (err) this.emit('error', err);\n    debug('destroyed (err %o)', err);\n  }\n\n  _destroySong() {\n    this._lib._mid_song_free(this._songPtr);\n\n    this._songPtr = 0;\n  }\n\n}\n\nmodule.exports = Timidity;","map":{"version":3,"sources":["/Users/philbrockman/coding/MusicalGens/app/http/web/app/node_modules/timidity/index.js"],"names":["Debug","require","EventEmitter","fs","LibTimidity","debug","debugVerbose","TIMIDITY_CFG","readFileSync","__dirname","SAMPLE_RATE","AUDIO_FORMAT","NUM_CHANNELS","BYTES_PER_SAMPLE","BUFFER_SIZE","AudioContext","window","webkitAudioContext","Timidity","constructor","baseUrl","destroyed","endsWith","_baseUrl","URL","location","origin","href","_ready","_playing","_pendingFetches","_songPtr","_bufferPtr","_array","Int16Array","_currentUrlOrBuf","_interval","_startInterval","bind","_stopInterval","_audioContext","_node","createScriptProcessor","_onAudioProcess","addEventListener","connect","destination","locateFile","file","then","lib","_lib","_onLibReady","FS","writeFile","result","_mid_init","_destroy","Error","_malloc","emit","load","urlOrBuf","resume","_destroySong","once","midiBuf","_fetch","Uint8Array","songPtr","_loadSong","missingCount","_mid_get_load_request_count","missingInstruments","_getMissingInstruments","Promise","all","map","instrument","_fetchInstrument","_mid_song_free","_mid_song_start","i","instrumentPtr","_mid_get_load_request","UTF8ToString","push","optsPtr","_mid_alloc_options","midiBufPtr","byteLength","HEAPU8","set","iStreamPtr","_mid_istream_open_mem","_mid_song_load","_mid_istream_close","_free","url","bufPromise","buf","_writeInstrumentFile","folderPath","split","slice","join","_mkdirp","encoding","pathParts","dirPath","length","curPart","mkdir","err","opts","mode","credentials","response","fetch","status","arrayBuffer","play","event","sampleCount","_readMidiData","output0","outputBuffer","getChannelData","output1","seek","pause","byteCount","_mid_song_read_wave","HEAP16","subarray","time","timeMs","Math","floor","_mid_song_seek","_onTimeupdate","currentTime","_mid_song_get_time","duration","_mid_song_get_total_time","setInterval","clearInterval","destroy","disconnect","removeEventListener","close","module","exports"],"mappings":"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","sourcesContent":["/*! timidity. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nconst Debug = require('debug')\nconst EventEmitter = require('events').EventEmitter\nconst fs = require('fs')\nconst LibTimidity = require('./libtimidity')\n\nconst debug = Debug('timidity')\nconst debugVerbose = Debug('timidity:verbose')\n\n// Inlined at build time by 'brfs' browserify transform\nconst TIMIDITY_CFG = fs.readFileSync(\n  __dirname + '/freepats.cfg', // eslint-disable-line node/no-path-concat\n  'utf8'\n)\n\nconst SAMPLE_RATE = 44100\nconst AUDIO_FORMAT = 0x8010 // format of the rendered audio 's16'\nconst NUM_CHANNELS = 2 // stereo (2 channels)\nconst BYTES_PER_SAMPLE = 2 * NUM_CHANNELS\nconst BUFFER_SIZE = 16384 // buffer size for each render() call\n\nconst AudioContext = typeof window !== 'undefined' &&\n  (window.AudioContext || window.webkitAudioContext)\n\nclass Timidity extends EventEmitter {\n  constructor (baseUrl = '/') {\n    super()\n\n    this.destroyed = false\n\n    if (!baseUrl.endsWith('/')) baseUrl += '/'\n    this._baseUrl = new URL(baseUrl, window.location.origin).href\n\n    this._ready = false\n    this._playing = false\n    this._pendingFetches = {} // instrument -> fetch\n    this._songPtr = 0\n    this._bufferPtr = 0\n    this._array = new Int16Array(BUFFER_SIZE * 2)\n    this._currentUrlOrBuf = null // currently loading url or buf\n    this._interval = null\n\n    this._startInterval = this._startInterval.bind(this)\n    this._stopInterval = this._stopInterval.bind(this)\n\n    // If the Timidity constructor was not invoked inside a user-initiated event\n    // handler, then the AudioContext will be suspended. See:\n    // https://developers.google.com/web/updates/2017/09/autoplay-policy-changes\n    this._audioContext = new AudioContext()\n\n    // Start the 'onaudioprocess' events flowing\n    this._node = this._audioContext.createScriptProcessor(\n      BUFFER_SIZE,\n      0,\n      NUM_CHANNELS\n    )\n    this._onAudioProcess = this._onAudioProcess.bind(this)\n    this._node.addEventListener('audioprocess', this._onAudioProcess)\n    this._node.connect(this._audioContext.destination)\n\n    LibTimidity({\n      locateFile: file => new URL(file, this._baseUrl).href\n    }).then((lib) => {\n      this._lib = lib\n      this._onLibReady()\n    })\n  }\n\n  _onLibReady () {\n    this._lib.FS.writeFile('/timidity.cfg', TIMIDITY_CFG)\n\n    const result = this._lib._mid_init('/timidity.cfg')\n    if (result !== 0) {\n      return this._destroy(new Error('Failed to initialize libtimidity'))\n    }\n\n    this._bufferPtr = this._lib._malloc(BUFFER_SIZE * BYTES_PER_SAMPLE)\n\n    debugVerbose('Initialized libtimidity')\n    this._ready = true\n    this.emit('_ready')\n  }\n\n  async load (urlOrBuf) {\n    debug('load %o', urlOrBuf)\n    if (this.destroyed) throw new Error('load() called after destroy()')\n\n    // If the Timidity constructor was not invoked inside a user-initiated event\n    // handler, then the AudioContext will be suspended. Attempt to resume it.\n    this._audioContext.resume()\n\n    // If a song already exists, destroy it before starting a new one\n    if (this._songPtr) this._destroySong()\n\n    this.emit('unstarted')\n    this._stopInterval()\n\n    if (!this._ready) return this.once('_ready', () => this.load(urlOrBuf))\n\n    this.emit('buffering')\n\n    // Save the url or buf to load. Allows detection of when a new interleaved\n    // load() starts so we can abort this load.\n    this._currentUrlOrBuf = urlOrBuf\n\n    let midiBuf\n    if (typeof urlOrBuf === 'string') {\n      midiBuf = await this._fetch(new URL(urlOrBuf, this._baseUrl))\n      // If another load() started while awaiting, abort this load\n      if (this._currentUrlOrBuf !== urlOrBuf) return\n    } else if (urlOrBuf instanceof Uint8Array) {\n      midiBuf = urlOrBuf\n    } else {\n      throw new Error('load() expects a `string` or `Uint8Array` argument')\n    }\n\n    let songPtr = this._loadSong(midiBuf)\n\n    // Are we missing instrument files?\n    let missingCount = this._lib._mid_get_load_request_count(songPtr)\n    if (missingCount > 0) {\n      let missingInstruments = this._getMissingInstruments(songPtr, missingCount)\n      debugVerbose('Fetching instruments: %o', missingInstruments)\n\n      // Wait for all instruments to load\n      await Promise.all(\n        missingInstruments.map(instrument => this._fetchInstrument(instrument))\n      )\n\n      // If another load() started while awaiting, abort this load\n      if (this._currentUrlOrBuf !== urlOrBuf) return\n\n      // Retry the song load, now that instruments have been loaded\n      this._lib._mid_song_free(songPtr)\n      songPtr = this._loadSong(midiBuf)\n\n      // Are we STILL missing instrument files? Then our General MIDI soundset\n      // is probably missing instrument files.\n      missingCount = this._lib._mid_get_load_request_count(songPtr)\n\n      // Print out missing instrument names\n      if (missingCount > 0) {\n        missingInstruments = this._getMissingInstruments(songPtr, missingCount)\n        debug('Playing with missing instruments: %o', missingInstruments)\n      }\n    }\n\n    this._songPtr = songPtr\n    this._lib._mid_song_start(this._songPtr)\n    debugVerbose('Song and instruments are loaded')\n  }\n\n  _getMissingInstruments (songPtr, missingCount) {\n    const missingInstruments = []\n    for (let i = 0; i < missingCount; i++) {\n      const instrumentPtr = this._lib._mid_get_load_request(songPtr, i)\n      const instrument = this._lib.UTF8ToString(instrumentPtr)\n      missingInstruments.push(instrument)\n    }\n    return missingInstruments\n  }\n\n  _loadSong (midiBuf) {\n    const optsPtr = this._lib._mid_alloc_options(\n      SAMPLE_RATE,\n      AUDIO_FORMAT,\n      NUM_CHANNELS,\n      BUFFER_SIZE\n    )\n\n    // Copy the MIDI buffer into the heap\n    const midiBufPtr = this._lib._malloc(midiBuf.byteLength)\n    this._lib.HEAPU8.set(midiBuf, midiBufPtr)\n\n    // Create a stream\n    const iStreamPtr = this._lib._mid_istream_open_mem(midiBufPtr, midiBuf.byteLength)\n\n    // Load the song\n    const songPtr = this._lib._mid_song_load(iStreamPtr, optsPtr)\n\n    // Free resources no longer needed\n    this._lib._mid_istream_close(iStreamPtr)\n    this._lib._free(optsPtr)\n    this._lib._free(midiBufPtr)\n\n    if (songPtr === 0) {\n      return this._destroy(new Error('Failed to load MIDI file'))\n    }\n\n    return songPtr\n  }\n\n  async _fetchInstrument (instrument) {\n    if (this._pendingFetches[instrument]) {\n      // If this instrument is already in the process of being fetched, return\n      // the existing promise to prevent duplicate fetches.\n      return this._pendingFetches[instrument]\n    }\n\n    const url = new URL(instrument, this._baseUrl)\n    const bufPromise = this._fetch(url)\n    this._pendingFetches[instrument] = bufPromise\n\n    const buf = await bufPromise\n    this._writeInstrumentFile(instrument, buf)\n\n    delete this._pendingFetches[instrument]\n\n    return buf\n  }\n\n  _writeInstrumentFile (instrument, buf) {\n    const folderPath = instrument\n      .split('/')\n      .slice(0, -1) // remove basename\n      .join('/')\n    this._mkdirp(folderPath)\n    this._lib.FS.writeFile(instrument, buf, { encoding: 'binary' })\n  }\n\n  _mkdirp (folderPath) {\n    const pathParts = folderPath.split('/')\n    let dirPath = '/'\n    for (let i = 0; i < pathParts.length; i++) {\n      const curPart = pathParts[i]\n      try {\n        this._lib.FS.mkdir(`${dirPath}${curPart}`)\n      } catch (err) {}\n      dirPath += `${curPart}/`\n    }\n  }\n\n  async _fetch (url) {\n    const opts = {\n      mode: 'cors',\n      credentials: 'same-origin'\n    }\n    const response = await window.fetch(url, opts)\n    if (response.status !== 200) throw new Error(`Could not load ${url}`)\n\n    const arrayBuffer = await response.arrayBuffer()\n    const buf = new Uint8Array(arrayBuffer)\n    return buf\n  }\n\n  play () {\n    debug('play')\n    if (this.destroyed) throw new Error('play() called after destroy()')\n\n    // If the Timidity constructor was not invoked inside a user-initiated event\n    // handler, then the AudioContext will be suspended. Attempt to resume it.\n    this._audioContext.resume()\n\n    this._playing = true\n    if (this._ready && !this._currentUrlOrBuf) {\n      this.emit('playing')\n      this._startInterval()\n    }\n  }\n\n  _onAudioProcess (event) {\n    const sampleCount = (this._songPtr && this._playing)\n      ? this._readMidiData()\n      : 0\n\n    if (sampleCount > 0 && this._currentUrlOrBuf) {\n      this._currentUrlOrBuf = null\n      this.emit('playing')\n      this._startInterval()\n    }\n\n    const output0 = event.outputBuffer.getChannelData(0)\n    const output1 = event.outputBuffer.getChannelData(1)\n\n    for (let i = 0; i < sampleCount; i++) {\n      output0[i] = this._array[i * 2] / 0x7FFF\n      output1[i] = this._array[i * 2 + 1] / 0x7FFF\n    }\n\n    for (let i = sampleCount; i < BUFFER_SIZE; i++) {\n      output0[i] = 0\n      output1[i] = 0\n    }\n\n    if (this._songPtr && this._playing && sampleCount === 0) {\n      // Reached the end of the file\n      this.seek(0)\n      this.pause()\n      this._lib._mid_song_start(this._songPtr)\n      this.emit('ended')\n    }\n  }\n\n  _readMidiData () {\n    const byteCount = this._lib._mid_song_read_wave(\n      this._songPtr,\n      this._bufferPtr,\n      BUFFER_SIZE * BYTES_PER_SAMPLE\n    )\n    const sampleCount = byteCount / BYTES_PER_SAMPLE\n\n    // Was anything output? If not, don't bother copying anything\n    if (sampleCount === 0) {\n      return 0\n    }\n\n    this._array.set(\n      this._lib.HEAP16.subarray(this._bufferPtr / 2, (this._bufferPtr + byteCount) / 2)\n    )\n\n    return sampleCount\n  }\n\n  pause () {\n    debug('pause')\n    if (this.destroyed) throw new Error('pause() called after destroy()')\n\n    this._playing = false\n    this._stopInterval()\n    this.emit('paused')\n  }\n\n  seek (time) {\n    debug('seek %d', time)\n    if (this.destroyed) throw new Error('seek() called after destroy()')\n    if (!this._songPtr) return // ignore seek if there is no song loaded yet\n\n    const timeMs = Math.floor(time * 1000)\n    this._lib._mid_song_seek(this._songPtr, timeMs)\n    this._onTimeupdate()\n  }\n\n  get currentTime () {\n    if (this.destroyed || !this._songPtr) return 0\n    return this._lib._mid_song_get_time(this._songPtr) / 1000\n  }\n\n  get duration () {\n    if (this.destroyed || !this._songPtr) return 1\n    return this._lib._mid_song_get_total_time(this._songPtr) / 1000\n  }\n\n  /**\n   * This event fires when the time indicated by the `currentTime` property\n   * has been updated.\n   */\n  _onTimeupdate () {\n    this.emit('timeupdate', this.currentTime)\n  }\n\n  _startInterval () {\n    this._onTimeupdate()\n    this._interval = setInterval(() => this._onTimeupdate(), 1000)\n  }\n\n  _stopInterval () {\n    this._onTimeupdate()\n    clearInterval(this._interval)\n    this._interval = null\n  }\n\n  destroy () {\n    debug('destroy')\n    if (this.destroyed) throw new Error('destroy() called after destroy()')\n    this._destroy()\n  }\n\n  _destroy (err) {\n    if (this.destroyed) return\n    this.destroyed = true\n\n    this._stopInterval()\n\n    this._array = null\n\n    if (this._songPtr) {\n      this._destroySong()\n    }\n\n    if (this._bufferPtr) {\n      this._lib._free(this._bufferPtr)\n      this._bufferPtr = 0\n    }\n\n    if (this._node) {\n      this._node.disconnect()\n      this._node.removeEventListener('audioprocess', this._onAudioProcess)\n    }\n\n    if (this._audioContext) {\n      this._audioContext.close()\n    }\n\n    if (err) this.emit('error', err)\n    debug('destroyed (err %o)', err)\n  }\n\n  _destroySong () {\n    this._lib._mid_song_free(this._songPtr)\n    this._songPtr = 0\n  }\n}\n\nmodule.exports = Timidity\n"]},"metadata":{},"sourceType":"script"}