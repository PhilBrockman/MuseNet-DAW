{"ast":null,"code":"//    abc_tokenizer.js: tokenizes an ABC Music Notation string to support abc_parse.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar parseCommon = require('./abc_common'); // this is a series of functions that get a particular element out of the passed stream.\n// the return is the number of characters consumed, so 0 means that the element wasn't found.\n// also returned is the element found. This may be a different length because spaces may be consumed that aren't part of the string.\n// The return structure for most calls is { len: num_chars_consumed, token: str }\n\n\nvar Tokenizer = function () {\n  this.skipWhiteSpace = function (str) {\n    for (var i = 0; i < str.length; i++) {\n      if (!this.isWhiteSpace(str.charAt(i))) return i;\n    }\n\n    return str.length; // It must have been all white space\n  };\n\n  var finished = function (str, i) {\n    return i >= str.length;\n  };\n\n  this.eatWhiteSpace = function (line, index) {\n    for (var i = index; i < line.length; i++) {\n      if (!this.isWhiteSpace(line.charAt(i))) return i - index;\n    }\n\n    return i - index;\n  }; // This just gets the basic pitch letter, ignoring leading spaces, and normalizing it to a capital\n\n\n  this.getKeyPitch = function (str) {\n    var i = this.skipWhiteSpace(str);\n    if (finished(str, i)) return {\n      len: 0\n    };\n\n    switch (str.charAt(i)) {\n      case 'A':\n        return {\n          len: i + 1,\n          token: 'A'\n        };\n\n      case 'B':\n        return {\n          len: i + 1,\n          token: 'B'\n        };\n\n      case 'C':\n        return {\n          len: i + 1,\n          token: 'C'\n        };\n\n      case 'D':\n        return {\n          len: i + 1,\n          token: 'D'\n        };\n\n      case 'E':\n        return {\n          len: i + 1,\n          token: 'E'\n        };\n\n      case 'F':\n        return {\n          len: i + 1,\n          token: 'F'\n        };\n\n      case 'G':\n        return {\n          len: i + 1,\n          token: 'G'\n        };\n      //\t\t\tcase 'a':return {len: i+1, token: 'A'};\n      //\t\t\tcase 'b':return {len: i+1, token: 'B'};\n      //\t\t\tcase 'c':return {len: i+1, token: 'C'};\n      //\t\t\tcase 'd':return {len: i+1, token: 'D'};\n      //\t\t\tcase 'e':return {len: i+1, token: 'E'};\n      //\t\t\tcase 'f':return {len: i+1, token: 'F'};\n      //\t\t\tcase 'g':return {len: i+1, token: 'G'};\n    }\n\n    return {\n      len: 0\n    };\n  }; // This just gets the basic accidental, ignoring leading spaces, and only the ones that appear in a key\n\n\n  this.getSharpFlat = function (str) {\n    if (str === 'bass') return {\n      len: 0\n    };\n\n    switch (str.charAt(0)) {\n      case '#':\n        return {\n          len: 1,\n          token: '#'\n        };\n\n      case 'b':\n        return {\n          len: 1,\n          token: 'b'\n        };\n    }\n\n    return {\n      len: 0\n    };\n  };\n\n  this.getMode = function (str) {\n    var skipAlpha = function (str, start) {\n      // This returns the index of the next non-alphabetic char, or the entire length of the string if not found.\n      while (start < str.length && (str.charAt(start) >= 'a' && str.charAt(start) <= 'z' || str.charAt(start) >= 'A' && str.charAt(start) <= 'Z')) start++;\n\n      return start;\n    };\n\n    var i = this.skipWhiteSpace(str);\n    if (finished(str, i)) return {\n      len: 0\n    };\n    var firstThree = str.substring(i, i + 3).toLowerCase();\n    if (firstThree.length > 1 && firstThree.charAt(1) === ' ' || firstThree.charAt(1) === '^' || firstThree.charAt(1) === '_' || firstThree.charAt(1) === '=') firstThree = firstThree.charAt(0); // This will handle the case of 'm'\n\n    switch (firstThree) {\n      case 'mix':\n        return {\n          len: skipAlpha(str, i),\n          token: 'Mix'\n        };\n\n      case 'dor':\n        return {\n          len: skipAlpha(str, i),\n          token: 'Dor'\n        };\n\n      case 'phr':\n        return {\n          len: skipAlpha(str, i),\n          token: 'Phr'\n        };\n\n      case 'lyd':\n        return {\n          len: skipAlpha(str, i),\n          token: 'Lyd'\n        };\n\n      case 'loc':\n        return {\n          len: skipAlpha(str, i),\n          token: 'Loc'\n        };\n\n      case 'aeo':\n        return {\n          len: skipAlpha(str, i),\n          token: 'm'\n        };\n\n      case 'maj':\n        return {\n          len: skipAlpha(str, i),\n          token: ''\n        };\n\n      case 'ion':\n        return {\n          len: skipAlpha(str, i),\n          token: ''\n        };\n\n      case 'min':\n        return {\n          len: skipAlpha(str, i),\n          token: 'm'\n        };\n\n      case 'm':\n        return {\n          len: skipAlpha(str, i),\n          token: 'm'\n        };\n    }\n\n    return {\n      len: 0\n    };\n  };\n\n  this.getClef = function (str, bExplicitOnly) {\n    var strOrig = str;\n    var i = this.skipWhiteSpace(str);\n    if (finished(str, i)) return {\n      len: 0\n    }; // The word 'clef' is optional, but if it appears, a clef MUST appear\n\n    var needsClef = false;\n    var strClef = str.substring(i);\n\n    if (parseCommon.startsWith(strClef, 'clef=')) {\n      needsClef = true;\n      strClef = strClef.substring(5);\n      i += 5;\n    }\n\n    if (strClef.length === 0 && needsClef) return {\n      len: i + 5,\n      warn: \"No clef specified: \" + strOrig\n    };\n    var j = this.skipWhiteSpace(strClef);\n    if (finished(strClef, j)) return {\n      len: 0\n    };\n\n    if (j > 0) {\n      i += j;\n      strClef = strClef.substring(j);\n    }\n\n    var name = null;\n    if (parseCommon.startsWith(strClef, 'treble')) name = 'treble';else if (parseCommon.startsWith(strClef, 'bass3')) name = 'bass3';else if (parseCommon.startsWith(strClef, 'bass')) name = 'bass';else if (parseCommon.startsWith(strClef, 'tenor')) name = 'tenor';else if (parseCommon.startsWith(strClef, 'alto2')) name = 'alto2';else if (parseCommon.startsWith(strClef, 'alto1')) name = 'alto1';else if (parseCommon.startsWith(strClef, 'alto')) name = 'alto';else if (!bExplicitOnly && needsClef && parseCommon.startsWith(strClef, 'none')) name = 'none';else if (parseCommon.startsWith(strClef, 'perc')) name = 'perc';else if (!bExplicitOnly && needsClef && parseCommon.startsWith(strClef, 'C')) name = 'tenor';else if (!bExplicitOnly && needsClef && parseCommon.startsWith(strClef, 'F')) name = 'bass';else if (!bExplicitOnly && needsClef && parseCommon.startsWith(strClef, 'G')) name = 'treble';else return {\n      len: i + 5,\n      warn: \"Unknown clef specified: \" + strOrig\n    };\n    strClef = strClef.substring(name.length);\n    j = this.isMatch(strClef, '+8');\n    if (j > 0) name += \"+8\";else {\n      j = this.isMatch(strClef, '-8');\n      if (j > 0) name += \"-8\";\n    }\n    return {\n      len: i + name.length,\n      token: name,\n      explicit: needsClef\n    };\n  }; // This returns one of the legal bar lines\n  // This is called alot and there is no obvious tokenable items, so this is broken apart.\n\n\n  this.getBarLine = function (line, i) {\n    switch (line.charAt(i)) {\n      case ']':\n        ++i;\n\n        switch (line.charAt(i)) {\n          case '|':\n            return {\n              len: 2,\n              token: \"bar_thick_thin\"\n            };\n\n          case '[':\n            ++i;\n            if (line.charAt(i) >= '1' && line.charAt(i) <= '9' || line.charAt(i) === '\"') return {\n              len: 2,\n              token: \"bar_invisible\"\n            };\n            return {\n              len: 1,\n              warn: \"Unknown bar symbol\"\n            };\n\n          default:\n            return {\n              len: 1,\n              token: \"bar_invisible\"\n            };\n        }\n\n        break;\n\n      case ':':\n        ++i;\n\n        switch (line.charAt(i)) {\n          case ':':\n            return {\n              len: 2,\n              token: \"bar_dbl_repeat\"\n            };\n\n          case '|':\n            // :|\n            ++i;\n\n            switch (line.charAt(i)) {\n              case ']':\n                // :|]\n                ++i;\n\n                switch (line.charAt(i)) {\n                  case '|':\n                    // :|]|\n                    ++i;\n                    if (line.charAt(i) === ':') return {\n                      len: 5,\n                      token: \"bar_dbl_repeat\"\n                    };\n                    return {\n                      len: 3,\n                      token: \"bar_right_repeat\"\n                    };\n\n                  default:\n                    return {\n                      len: 3,\n                      token: \"bar_right_repeat\"\n                    };\n                }\n\n                break;\n\n              case '|':\n                // :||\n                ++i;\n                if (line.charAt(i) === ':') return {\n                  len: 4,\n                  token: \"bar_dbl_repeat\"\n                };\n                return {\n                  len: 3,\n                  token: \"bar_right_repeat\"\n                };\n\n              default:\n                return {\n                  len: 2,\n                  token: \"bar_right_repeat\"\n                };\n            }\n\n            break;\n\n          default:\n            return {\n              len: 1,\n              warn: \"Unknown bar symbol\"\n            };\n        }\n\n        break;\n\n      case '[':\n        // [\n        ++i;\n\n        if (line.charAt(i) === '|') {\n          // [|\n          ++i;\n\n          switch (line.charAt(i)) {\n            case ':':\n              return {\n                len: 3,\n                token: \"bar_left_repeat\"\n              };\n\n            case ']':\n              return {\n                len: 3,\n                token: \"bar_invisible\"\n              };\n\n            default:\n              return {\n                len: 2,\n                token: \"bar_thick_thin\"\n              };\n          }\n        } else {\n          if (line.charAt(i) >= '1' && line.charAt(i) <= '9' || line.charAt(i) === '\"') return {\n            len: 1,\n            token: \"bar_invisible\"\n          };\n          return {\n            len: 0\n          };\n        }\n\n        break;\n\n      case '|':\n        // |\n        ++i;\n\n        switch (line.charAt(i)) {\n          case ']':\n            return {\n              len: 2,\n              token: \"bar_thin_thick\"\n            };\n\n          case '|':\n            // ||\n            ++i;\n            if (line.charAt(i) === ':') return {\n              len: 3,\n              token: \"bar_left_repeat\"\n            };\n            return {\n              len: 2,\n              token: \"bar_thin_thin\"\n            };\n\n          case ':':\n            // |:\n            var colons = 0;\n\n            while (line.charAt(i + colons) === ':') colons++;\n\n            return {\n              len: 1 + colons,\n              token: \"bar_left_repeat\"\n            };\n\n          default:\n            return {\n              len: 1,\n              token: \"bar_thin\"\n            };\n        }\n\n        break;\n    }\n\n    return {\n      len: 0\n    };\n  }; // this returns all the characters in the string that match one of the characters in the legalChars string\n\n\n  this.getTokenOf = function (str, legalChars) {\n    for (var i = 0; i < str.length; i++) {\n      if (legalChars.indexOf(str.charAt(i)) < 0) return {\n        len: i,\n        token: str.substring(0, i)\n      };\n    }\n\n    return {\n      len: i,\n      token: str\n    };\n  };\n\n  this.getToken = function (str, start, end) {\n    // This returns the next set of chars that doesn't contain spaces\n    var i = start;\n\n    while (i < end && !this.isWhiteSpace(str.charAt(i))) i++;\n\n    return str.substring(start, i);\n  }; // This just sees if the next token is the word passed in, with possible leading spaces\n\n\n  this.isMatch = function (str, match) {\n    var i = this.skipWhiteSpace(str);\n    if (finished(str, i)) return 0;\n    if (parseCommon.startsWith(str.substring(i), match)) return i + match.length;\n    return 0;\n  };\n\n  this.getPitchFromTokens = function (tokens) {\n    var ret = {};\n    var pitches = {\n      A: 5,\n      B: 6,\n      C: 0,\n      D: 1,\n      E: 2,\n      F: 3,\n      G: 4,\n      a: 12,\n      b: 13,\n      c: 7,\n      d: 8,\n      e: 9,\n      f: 10,\n      g: 11\n    };\n    ret.position = pitches[tokens[0].token];\n    if (ret.position === undefined) return {\n      warn: \"Pitch expected. Found: \" + tokens[0].token\n    };\n    tokens.shift();\n\n    while (tokens.length) {\n      switch (tokens[0].token) {\n        case ',':\n          ret.position -= 7;\n          tokens.shift();\n          break;\n\n        case '\\'':\n          ret.position += 7;\n          tokens.shift();\n          break;\n\n        default:\n          return ret;\n      }\n    }\n\n    return ret;\n  };\n\n  this.getKeyAccidentals2 = function (tokens) {\n    var accs; // find and strip off all accidentals in the token list\n\n    while (tokens.length > 0) {\n      var acc;\n\n      if (tokens[0].token === '^') {\n        acc = 'sharp';\n        tokens.shift();\n        if (tokens.length === 0) return {\n          accs: accs,\n          warn: 'Expected note name after ' + acc\n        };\n\n        switch (tokens[0].token) {\n          case '^':\n            acc = 'dblsharp';\n            tokens.shift();\n            break;\n\n          case '/':\n            acc = 'quartersharp';\n            tokens.shift();\n            break;\n        }\n      } else if (tokens[0].token === '=') {\n        acc = 'natural';\n        tokens.shift();\n      } else if (tokens[0].token === '_') {\n        acc = 'flat';\n        tokens.shift();\n        if (tokens.length === 0) return {\n          accs: accs,\n          warn: 'Expected note name after ' + acc\n        };\n\n        switch (tokens[0].token) {\n          case '_':\n            acc = 'dblflat';\n            tokens.shift();\n            break;\n\n          case '/':\n            acc = 'quarterflat';\n            tokens.shift();\n            break;\n        }\n      } else {\n        // Not an accidental, we'll assume that a later parse will recognize it.\n        return {\n          accs: accs\n        };\n      }\n\n      if (tokens.length === 0) return {\n        accs: accs,\n        warn: 'Expected note name after ' + acc\n      };\n\n      switch (tokens[0].token.charAt(0)) {\n        case 'a':\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'e':\n        case 'f':\n        case 'g':\n        case 'A':\n        case 'B':\n        case 'C':\n        case 'D':\n        case 'E':\n        case 'F':\n        case 'G':\n          if (accs === undefined) accs = [];\n          accs.push({\n            acc: acc,\n            note: tokens[0].token.charAt(0)\n          });\n          if (tokens[0].token.length === 1) tokens.shift();else tokens[0].token = tokens[0].token.substring(1);\n          break;\n\n        default:\n          return {\n            accs: accs,\n            warn: 'Expected note name after ' + acc + ' Found: ' + tokens[0].token\n          };\n      }\n    }\n\n    return {\n      accs: accs\n    };\n  }; // This gets an accidental marking for the key signature. It has the accidental then the pitch letter.\n\n\n  this.getKeyAccidental = function (str) {\n    var accTranslation = {\n      '^': 'sharp',\n      '^^': 'dblsharp',\n      '=': 'natural',\n      '_': 'flat',\n      '__': 'dblflat',\n      '_/': 'quarterflat',\n      '^/': 'quartersharp'\n    };\n    var i = this.skipWhiteSpace(str);\n    if (finished(str, i)) return {\n      len: 0\n    };\n    var acc = null;\n\n    switch (str.charAt(i)) {\n      case '^':\n      case '_':\n      case '=':\n        acc = str.charAt(i);\n        break;\n\n      default:\n        return {\n          len: 0\n        };\n    }\n\n    i++;\n    if (finished(str, i)) return {\n      len: 1,\n      warn: 'Expected note name after accidental'\n    };\n\n    switch (str.charAt(i)) {\n      case 'a':\n      case 'b':\n      case 'c':\n      case 'd':\n      case 'e':\n      case 'f':\n      case 'g':\n      case 'A':\n      case 'B':\n      case 'C':\n      case 'D':\n      case 'E':\n      case 'F':\n      case 'G':\n        return {\n          len: i + 1,\n          token: {\n            acc: accTranslation[acc],\n            note: str.charAt(i)\n          }\n        };\n\n      case '^':\n      case '_':\n      case '/':\n        acc += str.charAt(i);\n        i++;\n        if (finished(str, i)) return {\n          len: 2,\n          warn: 'Expected note name after accidental'\n        };\n\n        switch (str.charAt(i)) {\n          case 'a':\n          case 'b':\n          case 'c':\n          case 'd':\n          case 'e':\n          case 'f':\n          case 'g':\n          case 'A':\n          case 'B':\n          case 'C':\n          case 'D':\n          case 'E':\n          case 'F':\n          case 'G':\n            return {\n              len: i + 1,\n              token: {\n                acc: accTranslation[acc],\n                note: str.charAt(i)\n              }\n            };\n\n          default:\n            return {\n              len: 2,\n              warn: 'Expected note name after accidental'\n            };\n        }\n\n        break;\n\n      default:\n        return {\n          len: 1,\n          warn: 'Expected note name after accidental'\n        };\n    }\n  };\n\n  this.isWhiteSpace = function (ch) {\n    return ch === ' ' || ch === '\\t' || ch === '\\x12';\n  };\n\n  this.getMeat = function (line, start, end) {\n    // This removes any comments starting with '%' and trims the ends of the string so that there are no leading or trailing spaces.\n    // it returns just the start and end characters that contain the meat.\n    var comment = line.indexOf('%', start);\n    if (comment >= 0 && comment < end) end = comment;\n\n    while (start < end && (line.charAt(start) === ' ' || line.charAt(start) === '\\t' || line.charAt(start) === '\\x12')) start++;\n\n    while (start < end && (line.charAt(end - 1) === ' ' || line.charAt(end - 1) === '\\t' || line.charAt(end - 1) === '\\x12')) end--;\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  var isLetter = function (ch) {\n    return ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z';\n  };\n\n  var isNumber = function (ch) {\n    return ch >= '0' && ch <= '9';\n  };\n\n  this.tokenize = function (line, start, end, alphaUntilWhiteSpace) {\n    // this returns all the tokens inside the passed string. A token is a punctuation mark, a string of digits, a string of letters.\n    //  Quoted strings are one token.\n    //  If there is a minus sign next to a number, then it is included in the number.\n    // If there is a period immediately after a number, with a number immediately following, then a float is returned.\n    // The type of token is returned: quote, alpha, number, punct\n    // If alphaUntilWhiteSpace is true, then the behavior of the alpha token changes.\n    var ret = this.getMeat(line, start, end);\n    start = ret.start;\n    end = ret.end;\n    var tokens = [];\n    var i;\n\n    while (start < end) {\n      if (line.charAt(start) === '\"') {\n        i = start + 1;\n\n        while (i < end && line.charAt(i) !== '\"') i++;\n\n        tokens.push({\n          type: 'quote',\n          token: line.substring(start + 1, i),\n          start: start + 1,\n          end: i\n        });\n        i++;\n      } else if (isLetter(line.charAt(start))) {\n        i = start + 1;\n        if (alphaUntilWhiteSpace) while (i < end && !this.isWhiteSpace(line.charAt(i))) i++;else while (i < end && isLetter(line.charAt(i))) i++;\n        tokens.push({\n          type: 'alpha',\n          token: line.substring(start, i),\n          continueId: isNumber(line.charAt(i)),\n          start: start,\n          end: i\n        });\n        start = i + 1;\n      } else if (line.charAt(start) === '.' && isNumber(line.charAt(i + 1))) {\n        i = start + 1;\n        var int2 = null;\n        var float2 = null;\n\n        while (i < end && isNumber(line.charAt(i))) i++;\n\n        float2 = parseFloat(line.substring(start, i));\n        tokens.push({\n          type: 'number',\n          token: line.substring(start, i),\n          intt: int2,\n          floatt: float2,\n          continueId: isLetter(line.charAt(i)),\n          start: start,\n          end: i\n        });\n        start = i + 1;\n      } else if (isNumber(line.charAt(start)) || line.charAt(start) === '-' && isNumber(line.charAt(i + 1))) {\n        i = start + 1;\n        var intt = null;\n        var floatt = null;\n\n        while (i < end && isNumber(line.charAt(i))) i++;\n\n        if (line.charAt(i) === '.' && isNumber(line.charAt(i + 1))) {\n          i++;\n\n          while (i < end && isNumber(line.charAt(i))) i++;\n        } else intt = parseInt(line.substring(start, i));\n\n        floatt = parseFloat(line.substring(start, i));\n        tokens.push({\n          type: 'number',\n          token: line.substring(start, i),\n          intt: intt,\n          floatt: floatt,\n          continueId: isLetter(line.charAt(i)),\n          start: start,\n          end: i\n        });\n        start = i + 1;\n      } else if (line.charAt(start) === ' ' || line.charAt(start) === '\\t') {\n        i = start + 1;\n      } else {\n        tokens.push({\n          type: 'punct',\n          token: line.charAt(start),\n          start: start,\n          end: start + 1\n        });\n        i = start + 1;\n      }\n\n      start = i;\n    }\n\n    return tokens;\n  };\n\n  this.getVoiceToken = function (line, start, end) {\n    // This finds the next token. A token is delimited by a space or an equal sign. If it starts with a quote, then the portion between the quotes is returned.\n    var i = start;\n\n    while (i < end && this.isWhiteSpace(line.charAt(i)) || line.charAt(i) === '=') i++;\n\n    if (line.charAt(i) === '\"') {\n      var close = line.indexOf('\"', i + 1);\n      if (close === -1 || close >= end) return {\n        len: 1,\n        err: \"Missing close quote\"\n      };\n      return {\n        len: close - start + 1,\n        token: this.translateString(line.substring(i + 1, close))\n      };\n    } else {\n      var ii = i;\n\n      while (ii < end && !this.isWhiteSpace(line.charAt(ii)) && line.charAt(ii) !== '=') ii++;\n\n      return {\n        len: ii - start + 1,\n        token: line.substring(i, ii)\n      };\n    }\n  };\n\n  var charMap = {\n    \"`a\": 'à',\n    \"'a\": \"á\",\n    \"^a\": \"â\",\n    \"~a\": \"ã\",\n    \"\\\"a\": \"ä\",\n    \"oa\": \"å\",\n    \"aa\": \"å\",\n    \"=a\": \"ā\",\n    \"ua\": \"ă\",\n    \";a\": \"ą\",\n    \"`e\": 'è',\n    \"'e\": \"é\",\n    \"^e\": \"ê\",\n    \"\\\"e\": \"ë\",\n    \"=e\": \"ē\",\n    \"ue\": \"ĕ\",\n    \";e\": \"ę\",\n    \".e\": \"ė\",\n    \"`i\": 'ì',\n    \"'i\": \"í\",\n    \"^i\": \"î\",\n    \"\\\"i\": \"ï\",\n    \"=i\": \"ī\",\n    \"ui\": \"ĭ\",\n    \";i\": \"į\",\n    \"`o\": 'ò',\n    \"'o\": \"ó\",\n    \"^o\": \"ô\",\n    \"~o\": \"õ\",\n    \"\\\"o\": \"ö\",\n    \"=o\": \"ō\",\n    \"uo\": \"ŏ\",\n    \"/o\": \"ø\",\n    \"`u\": 'ù',\n    \"'u\": \"ú\",\n    \"^u\": \"û\",\n    \"~u\": \"ũ\",\n    \"\\\"u\": \"ü\",\n    \"ou\": \"ů\",\n    \"=u\": \"ū\",\n    \"uu\": \"ŭ\",\n    \";u\": \"ų\",\n    \"`A\": 'À',\n    \"'A\": \"Á\",\n    \"^A\": \"Â\",\n    \"~A\": \"Ã\",\n    \"\\\"A\": \"Ä\",\n    \"oA\": \"Å\",\n    \"AA\": \"Å\",\n    \"=A\": \"Ā\",\n    \"uA\": \"Ă\",\n    \";A\": \"Ą\",\n    \"`E\": 'È',\n    \"'E\": \"É\",\n    \"^E\": \"Ê\",\n    \"\\\"E\": \"Ë\",\n    \"=E\": \"Ē\",\n    \"uE\": \"Ĕ\",\n    \";E\": \"Ę\",\n    \".E\": \"Ė\",\n    \"`I\": 'Ì',\n    \"'I\": \"Í\",\n    \"^I\": \"Î\",\n    \"~I\": \"Ĩ\",\n    \"\\\"I\": \"Ï\",\n    \"=I\": \"Ī\",\n    \"uI\": \"Ĭ\",\n    \";I\": \"Į\",\n    \".I\": \"İ\",\n    \"`O\": 'Ò',\n    \"'O\": \"Ó\",\n    \"^O\": \"Ô\",\n    \"~O\": \"Õ\",\n    \"\\\"O\": \"Ö\",\n    \"=O\": \"Ō\",\n    \"uO\": \"Ŏ\",\n    \"/O\": \"Ø\",\n    \"`U\": 'Ù',\n    \"'U\": \"Ú\",\n    \"^U\": \"Û\",\n    \"~U\": \"Ũ\",\n    \"\\\"U\": \"Ü\",\n    \"oU\": \"Ů\",\n    \"=U\": \"Ū\",\n    \"uU\": \"Ŭ\",\n    \";U\": \"Ų\",\n    \"ae\": \"æ\",\n    \"AE\": \"Æ\",\n    \"oe\": \"œ\",\n    \"OE\": \"Œ\",\n    \"ss\": \"ß\",\n    \"'c\": \"ć\",\n    \"^c\": \"ĉ\",\n    \"uc\": \"č\",\n    \"cc\": \"ç\",\n    \".c\": \"ċ\",\n    \"cC\": \"Ç\",\n    \"'C\": \"Ć\",\n    \"^C\": \"Ĉ\",\n    \"uC\": \"Č\",\n    \".C\": \"Ċ\",\n    \"~N\": \"Ñ\",\n    \"~n\": \"ñ\",\n    \"=s\": \"š\",\n    \"vs\": \"š\",\n    \"DH\": \"Ð\",\n    \"dh\": \"ð\",\n    \"HO\": \"Ő\",\n    \"Ho\": \"ő\",\n    \"HU\": \"Ű\",\n    \"Hu\": \"ű\",\n    \"'Y\": \"Ý\",\n    \"'y\": \"ý\",\n    \"^Y\": \"Ŷ\",\n    \"^y\": \"ŷ\",\n    \"\\\"Y\": \"Ÿ\",\n    \"\\\"y\": \"ÿ\",\n    \"vS\": \"Š\",\n    \"vZ\": \"Ž\",\n    \"vz\": 'ž' // More chars: Ĳ ĳ Ď ď Đ đ Ĝ ĝ Ğ ğ Ġ ġ Ģ ģ Ĥ ĥ Ħ ħ Ĵ ĵ Ķ ķ ĸ Ĺ ĺ Ļ ļ Ľ ľ Ŀ ŀ Ł ł Ń ń Ņ ņ Ň ň ŉ Ŋ ŋ Ŕ ŕ Ŗ ŗ Ř ř Ś ś Ŝ ŝ Ş ş Š Ţ ţ Ť ť Ŧ ŧ Ŵ ŵ Ź ź Ż ż Ž\n\n  };\n  var charMap1 = {\n    \"#\": \"♯\",\n    \"b\": \"♭\",\n    \"=\": \"♮\"\n  };\n  var charMap2 = {\n    \"201\": \"♯\",\n    \"202\": \"♭\",\n    \"203\": \"♮\",\n    \"241\": \"¡\",\n    \"242\": \"¢\",\n    \"252\": \"a\",\n    \"262\": \"2\",\n    \"272\": \"o\",\n    \"302\": \"Â\",\n    \"312\": \"Ê\",\n    \"322\": \"Ò\",\n    \"332\": \"Ú\",\n    \"342\": \"â\",\n    \"352\": \"ê\",\n    \"362\": \"ò\",\n    \"372\": \"ú\",\n    \"243\": \"£\",\n    \"253\": \"«\",\n    \"263\": \"3\",\n    \"273\": \"»\",\n    \"303\": \"Ã\",\n    \"313\": \"Ë\",\n    \"323\": \"Ó\",\n    \"333\": \"Û\",\n    \"343\": \"ã\",\n    \"353\": \"ë\",\n    \"363\": \"ó\",\n    \"373\": \"û\",\n    \"244\": \"¤\",\n    \"254\": \"¬\",\n    \"264\": \"  ́\",\n    \"274\": \"1⁄4\",\n    \"304\": \"Ä\",\n    \"314\": \"Ì\",\n    \"324\": \"Ô\",\n    \"334\": \"Ü\",\n    \"344\": \"ä\",\n    \"354\": \"ì\",\n    \"364\": \"ô\",\n    \"374\": \"ü\",\n    \"245\": \"¥\",\n    \"255\": \"-\",\n    \"265\": \"μ\",\n    \"275\": \"1⁄2\",\n    \"305\": \"Å\",\n    \"315\": \"Í\",\n    \"325\": \"Õ\",\n    \"335\": \"Ý\",\n    \"345\": \"å\",\n    \"355\": \"í\",\n    \"365\": \"õ\",\n    \"375\": \"ý\",\n    \"246\": \"¦\",\n    \"256\": \"®\",\n    \"266\": \"¶\",\n    \"276\": \"3⁄4\",\n    \"306\": \"Æ\",\n    \"316\": \"Î\",\n    \"326\": \"Ö\",\n    \"336\": \"Þ\",\n    \"346\": \"æ\",\n    \"356\": \"î\",\n    \"366\": \"ö\",\n    \"376\": \"þ\",\n    \"247\": \"§\",\n    \"257\": \" ̄\",\n    \"267\": \"·\",\n    \"277\": \"¿\",\n    \"307\": \"Ç\",\n    \"317\": \"Ï\",\n    \"327\": \"×\",\n    \"337\": \"ß\",\n    \"347\": \"ç\",\n    \"357\": \"ï\",\n    \"367\": \"÷\",\n    \"377\": \"ÿ\",\n    \"250\": \" ̈\",\n    \"260\": \"°\",\n    \"270\": \" ̧\",\n    \"300\": \"À\",\n    \"310\": \"È\",\n    \"320\": \"Ð\",\n    \"330\": \"Ø\",\n    \"340\": \"à\",\n    \"350\": \"è\",\n    \"360\": \"ð\",\n    \"370\": \"ø\",\n    \"251\": \"©\",\n    \"261\": \"±\",\n    \"271\": \"1\",\n    \"301\": \"Á\",\n    \"311\": \"É\",\n    \"321\": \"Ñ\",\n    \"331\": \"Ù\",\n    \"341\": \"á\",\n    \"351\": \"é\",\n    \"361\": \"ñ\",\n    \"371\": \"ù\"\n  };\n\n  this.translateString = function (str) {\n    var arr = str.split('\\\\');\n    if (arr.length === 1) return str;\n    var out = null;\n    parseCommon.each(arr, function (s) {\n      if (out === null) out = s;else {\n        var c = charMap[s.substring(0, 2)];\n        if (c !== undefined) out += c + s.substring(2);else {\n          c = charMap2[s.substring(0, 3)];\n          if (c !== undefined) out += c + s.substring(3);else {\n            c = charMap1[s.substring(0, 1)];\n            if (c !== undefined) out += c + s.substring(1);else out += \"\\\\\" + s;\n          }\n        }\n      }\n    });\n    return out;\n  };\n\n  this.getNumber = function (line, index) {\n    var num = 0;\n\n    while (index < line.length) {\n      switch (line.charAt(index)) {\n        case '0':\n          num = num * 10;\n          index++;\n          break;\n\n        case '1':\n          num = num * 10 + 1;\n          index++;\n          break;\n\n        case '2':\n          num = num * 10 + 2;\n          index++;\n          break;\n\n        case '3':\n          num = num * 10 + 3;\n          index++;\n          break;\n\n        case '4':\n          num = num * 10 + 4;\n          index++;\n          break;\n\n        case '5':\n          num = num * 10 + 5;\n          index++;\n          break;\n\n        case '6':\n          num = num * 10 + 6;\n          index++;\n          break;\n\n        case '7':\n          num = num * 10 + 7;\n          index++;\n          break;\n\n        case '8':\n          num = num * 10 + 8;\n          index++;\n          break;\n\n        case '9':\n          num = num * 10 + 9;\n          index++;\n          break;\n\n        default:\n          return {\n            num: num,\n            index: index\n          };\n      }\n    }\n\n    return {\n      num: num,\n      index: index\n    };\n  };\n\n  this.getFraction = function (line, index) {\n    var num = 1;\n    var den = 1;\n\n    if (line.charAt(index) !== '/') {\n      var ret = this.getNumber(line, index);\n      num = ret.num;\n      index = ret.index;\n    }\n\n    if (line.charAt(index) === '/') {\n      index++;\n\n      if (line.charAt(index) === '/') {\n        var div = 0.5;\n\n        while (line.charAt(index++) === '/') div = div / 2;\n\n        return {\n          value: num * div,\n          index: index - 1\n        };\n      } else {\n        var iSave = index;\n        var ret2 = this.getNumber(line, index);\n        if (ret2.num === 0 && iSave === index) // If we didn't use any characters, it is an implied 2\n          ret2.num = 2;\n        if (ret2.num !== 0) den = ret2.num;\n        index = ret2.index;\n      }\n    }\n\n    return {\n      value: num / den,\n      index: index\n    };\n  };\n\n  this.theReverser = function (str) {\n    if (parseCommon.endsWith(str, \", The\")) return \"The \" + str.substring(0, str.length - 5);\n    if (parseCommon.endsWith(str, \", A\")) return \"A \" + str.substring(0, str.length - 3);\n    return str;\n  };\n\n  this.stripComment = function (str) {\n    var i = str.indexOf('%');\n    if (i >= 0) return parseCommon.strip(str.substring(0, i));\n    return parseCommon.strip(str);\n  };\n\n  this.getInt = function (str) {\n    // This parses the beginning of the string for a number and returns { value: num, digits: num }\n    // If digits is 0, then the string didn't point to a number.\n    var x = parseInt(str);\n    if (isNaN(x)) return {\n      digits: 0\n    };\n    var s = \"\" + x;\n    var i = str.indexOf(s); // This is to account for leading spaces\n\n    return {\n      value: x,\n      digits: i + s.length\n    };\n  };\n\n  this.getFloat = function (str) {\n    // This parses the beginning of the string for a number and returns { value: num, digits: num }\n    // If digits is 0, then the string didn't point to a number.\n    var x = parseFloat(str);\n    if (isNaN(x)) return {\n      digits: 0\n    };\n    var s = \"\" + x;\n    var i = str.indexOf(s); // This is to account for leading spaces\n\n    return {\n      value: x,\n      digits: i + s.length\n    };\n  };\n\n  this.getMeasurement = function (tokens) {\n    if (tokens.length === 0) return {\n      used: 0\n    };\n    var used = 1;\n    var num = '';\n\n    if (tokens[0].token === '-') {\n      tokens.shift();\n      num = '-';\n      used++;\n    } else if (tokens[0].type !== 'number') return {\n      used: 0\n    };\n\n    num += tokens.shift().token;\n    if (tokens.length === 0) return {\n      used: 1,\n      value: parseInt(num)\n    };\n    var x = tokens.shift();\n\n    if (x.token === '.') {\n      used++;\n      if (tokens.length === 0) return {\n        used: used,\n        value: parseInt(num)\n      };\n\n      if (tokens[0].type === 'number') {\n        x = tokens.shift();\n        num = num + '.' + x.token;\n        used++;\n        if (tokens.length === 0) return {\n          used: used,\n          value: parseFloat(num)\n        };\n      }\n\n      x = tokens.shift();\n    }\n\n    switch (x.token) {\n      case 'pt':\n        return {\n          used: used + 1,\n          value: parseFloat(num)\n        };\n\n      case 'cm':\n        return {\n          used: used + 1,\n          value: parseFloat(num) / 2.54 * 72\n        };\n\n      case 'in':\n        return {\n          used: used + 1,\n          value: parseFloat(num) * 72\n        };\n\n      default:\n        tokens.unshift(x);\n        return {\n          used: used,\n          value: parseFloat(num)\n        };\n    }\n\n    return {\n      used: 0\n    };\n  };\n\n  var substInChord = function (str) {\n    while (str.indexOf(\"\\\\n\") !== -1) {\n      str = str.replace(\"\\\\n\", \"\\n\");\n    }\n\n    return str;\n  };\n\n  this.getBrackettedSubstring = function (line, i, maxErrorChars, _matchChar) {\n    // This extracts the sub string by looking at the first character and searching for that\n    // character later in the line (or search for the optional _matchChar).\n    // For instance, if the first character is a quote it will look for\n    // the end quote. If the end of the line is reached, then only up to the default number\n    // of characters are returned, so that a missing end quote won't eat up the entire line.\n    // It returns the substring and the number of characters consumed.\n    // The number of characters consumed is normally two more than the size of the substring,\n    // but in the error case it might not be.\n    var matchChar = _matchChar || line.charAt(i);\n\n    var pos = i + 1;\n\n    while (pos < line.length && line.charAt(pos) !== matchChar) ++pos;\n\n    if (line.charAt(pos) === matchChar) return [pos - i + 1, substInChord(line.substring(i + 1, pos)), true];else // we hit the end of line, so we'll just pick an arbitrary num of chars so the line doesn't disappear.\n      {\n        pos = i + maxErrorChars;\n        if (pos > line.length - 1) pos = line.length - 1;\n        return [pos - i + 1, substInChord(line.substring(i + 1, pos)), false];\n      }\n  };\n};\n\nmodule.exports = Tokenizer;","map":{"version":3,"sources":["/Users/philbrockman/coding/MusicalGens/app/http/web/app/node_modules/abcjs/src/parse/abc_tokenizer.js"],"names":["parseCommon","require","Tokenizer","skipWhiteSpace","str","i","length","isWhiteSpace","charAt","finished","eatWhiteSpace","line","index","getKeyPitch","len","token","getSharpFlat","getMode","skipAlpha","start","firstThree","substring","toLowerCase","getClef","bExplicitOnly","strOrig","needsClef","strClef","startsWith","warn","j","name","isMatch","explicit","getBarLine","colons","getTokenOf","legalChars","indexOf","getToken","end","match","getPitchFromTokens","tokens","ret","pitches","A","B","C","D","E","F","G","a","b","c","d","e","f","g","position","undefined","shift","getKeyAccidentals2","accs","acc","push","note","getKeyAccidental","accTranslation","ch","getMeat","comment","isLetter","isNumber","tokenize","alphaUntilWhiteSpace","type","continueId","int2","float2","parseFloat","intt","floatt","parseInt","getVoiceToken","close","err","translateString","ii","charMap","charMap1","charMap2","arr","split","out","each","s","getNumber","num","getFraction","den","div","value","iSave","ret2","theReverser","endsWith","stripComment","strip","getInt","x","isNaN","digits","getFloat","getMeasurement","used","unshift","substInChord","replace","getBrackettedSubstring","maxErrorChars","_matchChar","matchChar","pos","module","exports"],"mappings":"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","sourcesContent":["//    abc_tokenizer.js: tokenizes an ABC Music Notation string to support abc_parse.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar parseCommon = require('./abc_common');\n\n// this is a series of functions that get a particular element out of the passed stream.\n// the return is the number of characters consumed, so 0 means that the element wasn't found.\n// also returned is the element found. This may be a different length because spaces may be consumed that aren't part of the string.\n// The return structure for most calls is { len: num_chars_consumed, token: str }\nvar Tokenizer = function() {\n\tthis.skipWhiteSpace = function(str) {\n\t\tfor (var i = 0; i < str.length; i++) {\n\t\t  if (!this.isWhiteSpace(str.charAt(i)))\n\t\t\t\treturn i;\n\t\t}\n\t\treturn str.length;\t// It must have been all white space\n\t};\n\tvar finished = function(str, i) {\n\t\treturn i >= str.length;\n\t};\n\tthis.eatWhiteSpace = function(line, index) {\n\t\tfor (var i = index; i < line.length; i++) {\n\t\t  if (!this.isWhiteSpace(line.charAt(i)))\n\t\t\t\treturn i-index;\n\t\t}\n\t\treturn i-index;\n\t};\n\n\t// This just gets the basic pitch letter, ignoring leading spaces, and normalizing it to a capital\n\tthis.getKeyPitch = function(str) {\n\t\tvar i = this.skipWhiteSpace(str);\n\t\tif (finished(str, i))\n\t\t\treturn {len: 0};\n\t\tswitch (str.charAt(i)) {\n\t\t\tcase 'A':return {len: i+1, token: 'A'};\n\t\t\tcase 'B':return {len: i+1, token: 'B'};\n\t\t\tcase 'C':return {len: i+1, token: 'C'};\n\t\t\tcase 'D':return {len: i+1, token: 'D'};\n\t\t\tcase 'E':return {len: i+1, token: 'E'};\n\t\t\tcase 'F':return {len: i+1, token: 'F'};\n\t\t\tcase 'G':return {len: i+1, token: 'G'};\n//\t\t\tcase 'a':return {len: i+1, token: 'A'};\n//\t\t\tcase 'b':return {len: i+1, token: 'B'};\n//\t\t\tcase 'c':return {len: i+1, token: 'C'};\n//\t\t\tcase 'd':return {len: i+1, token: 'D'};\n//\t\t\tcase 'e':return {len: i+1, token: 'E'};\n//\t\t\tcase 'f':return {len: i+1, token: 'F'};\n//\t\t\tcase 'g':return {len: i+1, token: 'G'};\n\t\t}\n\t\treturn {len: 0};\n\t};\n\n\t// This just gets the basic accidental, ignoring leading spaces, and only the ones that appear in a key\n\tthis.getSharpFlat = function(str) {\n\t\tif (str === 'bass')\n\t\t\treturn {len: 0};\n\t\tswitch (str.charAt(0)) {\n\t\t\tcase '#':return {len: 1, token: '#'};\n\t\t\tcase 'b':return {len: 1, token: 'b'};\n\t\t}\n\t\treturn {len: 0};\n\t};\n\n\tthis.getMode = function(str) {\n\t\tvar skipAlpha = function(str, start) {\n\t\t\t// This returns the index of the next non-alphabetic char, or the entire length of the string if not found.\n\t\t  while (start < str.length && ((str.charAt(start) >= 'a' && str.charAt(start) <= 'z') || (str.charAt(start) >= 'A' && str.charAt(start) <= 'Z')))\n\t\t\t\tstart++;\n\t\t\treturn start;\n\t\t};\n\n\t\tvar i = this.skipWhiteSpace(str);\n\t\tif (finished(str, i))\n\t\t\treturn {len: 0};\n\t\tvar firstThree = str.substring(i,i+3).toLowerCase();\n\t\tif (firstThree.length > 1 && firstThree.charAt(1) === ' ' || firstThree.charAt(1) === '^' || firstThree.charAt(1) === '_' || firstThree.charAt(1) === '=') firstThree = firstThree.charAt(0);\t// This will handle the case of 'm'\n\t\tswitch (firstThree) {\n\t\t\tcase 'mix':return {len: skipAlpha(str, i), token: 'Mix'};\n\t\t\tcase 'dor':return {len: skipAlpha(str, i), token: 'Dor'};\n\t\t\tcase 'phr':return {len: skipAlpha(str, i), token: 'Phr'};\n\t\t\tcase 'lyd':return {len: skipAlpha(str, i), token: 'Lyd'};\n\t\t\tcase 'loc':return {len: skipAlpha(str, i), token: 'Loc'};\n\t\t\tcase 'aeo':return {len: skipAlpha(str, i), token: 'm'};\n\t\t\tcase 'maj':return {len: skipAlpha(str, i), token: ''};\n\t\t\tcase 'ion':return {len: skipAlpha(str, i), token: ''};\n\t\t\tcase 'min':return {len: skipAlpha(str, i), token: 'm'};\n\t\t\tcase 'm':return {len: skipAlpha(str, i), token: 'm'};\n\t\t}\n\t\treturn {len: 0};\n\t};\n\n\tthis.getClef = function(str, bExplicitOnly) {\n\t\tvar strOrig = str;\n\t\tvar i = this.skipWhiteSpace(str);\n\t\tif (finished(str, i))\n\t\t\treturn {len: 0};\n\t\t// The word 'clef' is optional, but if it appears, a clef MUST appear\n\t\tvar needsClef = false;\n\t\tvar strClef = str.substring(i);\n\t\tif (parseCommon.startsWith(strClef, 'clef=')) {\n\t\t\tneedsClef = true;\n\t\t\tstrClef = strClef.substring(5);\n\t\t\ti += 5;\n\t\t}\n\t\tif (strClef.length === 0 && needsClef)\n\t\t\treturn {len: i+5, warn: \"No clef specified: \" + strOrig};\n\n\t\tvar j = this.skipWhiteSpace(strClef);\n\t\tif (finished(strClef, j))\n\t\t\treturn {len: 0};\n\t\tif (j > 0) {\n\t\t\ti += j;\n\t\t\tstrClef = strClef.substring(j);\n\t\t}\n\t\tvar name = null;\n\t\tif (parseCommon.startsWith(strClef, 'treble'))\n\t\t\tname = 'treble';\n\t\telse if (parseCommon.startsWith(strClef, 'bass3'))\n\t\t\tname = 'bass3';\n\t\telse if (parseCommon.startsWith(strClef, 'bass'))\n\t\t\tname = 'bass';\n\t\telse if (parseCommon.startsWith(strClef, 'tenor'))\n\t\t\tname = 'tenor';\n\t\telse if (parseCommon.startsWith(strClef, 'alto2'))\n\t\t\tname = 'alto2';\n\t\telse if (parseCommon.startsWith(strClef, 'alto1'))\n\t\t\tname = 'alto1';\n\t\telse if (parseCommon.startsWith(strClef, 'alto'))\n\t\t\tname = 'alto';\n\t\telse if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, 'none')))\n\t\t\tname = 'none';\n\t\telse if (parseCommon.startsWith(strClef, 'perc'))\n\t\t\tname = 'perc';\n\t\telse if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, 'C')))\n\t\t\tname = 'tenor';\n\t\telse if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, 'F')))\n\t\t\tname = 'bass';\n\t\telse if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, 'G')))\n\t\t\tname = 'treble';\n\t\telse\n\t\t\treturn {len: i+5, warn: \"Unknown clef specified: \" + strOrig};\n\n\t\tstrClef = strClef.substring(name.length);\n\t\tj = this.isMatch(strClef, '+8');\n\t\tif (j > 0)\n\t\t\tname += \"+8\";\n\t\telse {\n\t\t\tj = this.isMatch(strClef, '-8');\n\t\t\tif (j > 0)\n\t\t\t\tname += \"-8\";\n\t\t}\n\t\treturn {len: i+name.length, token: name, explicit: needsClef};\n\t};\n\n\t// This returns one of the legal bar lines\n\t// This is called alot and there is no obvious tokenable items, so this is broken apart.\n\tthis.getBarLine = function(line, i) {\n\t\tswitch (line.charAt(i)) {\n\t\t\tcase ']':\n\t\t\t\t++i;\n\t\t\t\tswitch (line.charAt(i)) {\n\t\t\t\t\tcase '|': return {len: 2, token: \"bar_thick_thin\"};\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\t++i;\n\t\t\t\t\t\tif ((line.charAt(i) >= '1' && line.charAt(i) <= '9') || line.charAt(i) === '\"')\n\t\t\t\t\t\t\treturn {len: 2, token: \"bar_invisible\"};\n\t\t\t\t\t\treturn {len: 1, warn: \"Unknown bar symbol\"};\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn {len: 1, token: \"bar_invisible\"};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ':':\n\t\t\t\t++i;\n\t\t\t\tswitch (line.charAt(i)) {\n\t\t\t\t\tcase ':': return {len: 2, token: \"bar_dbl_repeat\"};\n\t\t\t\t\tcase '|':\t// :|\n\t\t\t\t\t\t++i;\n\t\t\t\t\t\tswitch (line.charAt(i)) {\n\t\t\t\t\t\t\tcase ']':\t// :|]\n\t\t\t\t\t\t\t\t++i;\n\t\t\t\t\t\t\t\tswitch (line.charAt(i)) {\n\t\t\t\t\t\t\t\t\tcase '|':\t// :|]|\n\t\t\t\t\t\t\t\t\t\t++i;\n\t\t\t\t\t\t\t\t\t\tif (line.charAt(i) === ':')  return {len: 5, token: \"bar_dbl_repeat\"};\n\t\t\t\t\t\t\t\t\t\treturn {len: 3, token: \"bar_right_repeat\"};\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\treturn {len: 3, token: \"bar_right_repeat\"};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '|':\t// :||\n\t\t\t\t\t\t\t\t++i;\n\t\t\t\t\t\t\t\tif (line.charAt(i) === ':')  return {len: 4, token: \"bar_dbl_repeat\"};\n\t\t\t\t\t\t\t\treturn {len: 3, token: \"bar_right_repeat\"};\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn {len: 2, token: \"bar_right_repeat\"};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn {len: 1, warn: \"Unknown bar symbol\"};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '[':\t// [\n\t\t\t\t++i;\n\t\t\t\tif (line.charAt(i) === '|') {\t// [|\n\t\t\t\t\t++i;\n\t\t\t\t\tswitch (line.charAt(i)) {\n\t\t\t\t\t\tcase ':': return {len: 3, token: \"bar_left_repeat\"};\n\t\t\t\t\t\tcase ']': return {len: 3, token: \"bar_invisible\"};\n\t\t\t\t\t\tdefault: return {len: 2, token: \"bar_thick_thin\"};\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((line.charAt(i) >= '1' && line.charAt(i) <= '9') || line.charAt(i) === '\"')\n\t\t\t\t\t\treturn {len: 1, token: \"bar_invisible\"};\n\t\t\t\t\treturn {len: 0};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '|':\t// |\n\t\t\t\t++i;\n\t\t\t\tswitch (line.charAt(i)) {\n\t\t\t\t\tcase ']': return {len: 2, token: \"bar_thin_thick\"};\n\t\t\t\t\tcase '|': // ||\n\t\t\t\t\t\t++i;\n\t\t\t\t\t\tif (line.charAt(i) === ':') return {len: 3, token: \"bar_left_repeat\"};\n\t\t\t\t\t\treturn {len: 2, token: \"bar_thin_thin\"};\n\t\t\t\t\tcase ':':\t// |:\n\t\t\t\t\t\tvar colons = 0;\n\t\t\t\t\t\twhile (line.charAt(i+colons) === ':') colons++;\n\t\t\t\t\t\treturn { len: 1+colons, token: \"bar_left_repeat\"};\n\t\t\t\t\tdefault: return {len: 1, token: \"bar_thin\"};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\treturn {len: 0};\n\t};\n\n\t// this returns all the characters in the string that match one of the characters in the legalChars string\n\tthis.getTokenOf = function(str, legalChars) {\n\t\tfor (var i = 0; i < str.length; i++) {\n\t\t\tif (legalChars.indexOf(str.charAt(i)) < 0)\n\t\t\t\treturn {len: i, token: str.substring(0, i)};\n\t\t}\n\t\treturn {len: i, token: str};\n\t};\n\n\tthis.getToken = function(str, start, end) {\n\t\t// This returns the next set of chars that doesn't contain spaces\n\t\tvar i = start;\n\t\twhile (i < end && !this.isWhiteSpace(str.charAt(i)))\n\t\t\ti++;\n\t\treturn str.substring(start, i);\n\t};\n\n\t// This just sees if the next token is the word passed in, with possible leading spaces\n\tthis.isMatch = function(str, match) {\n\t\tvar i = this.skipWhiteSpace(str);\n\t\tif (finished(str, i))\n\t\t\treturn 0;\n\t\tif (parseCommon.startsWith(str.substring(i), match))\n\t\t\treturn i+match.length;\n\t\treturn 0;\n\t};\n\n\tthis.getPitchFromTokens = function(tokens) {\n\t\tvar ret = { };\n\t\tvar pitches = {A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11};\n\t\tret.position = pitches[tokens[0].token];\n\t\tif (ret.position === undefined)\n\t\t\treturn { warn: \"Pitch expected. Found: \" + tokens[0].token };\n\t\ttokens.shift();\n\t\twhile (tokens.length) {\n\t\t\tswitch (tokens[0].token) {\n\t\t\t\tcase ',': ret.position -= 7; tokens.shift(); break;\n\t\t\t\tcase '\\'': ret.position += 7; tokens.shift(); break;\n\t\t\t\tdefault: return ret;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\tthis.getKeyAccidentals2 = function(tokens) {\n\t\tvar accs;\n\t\t// find and strip off all accidentals in the token list\n\t\twhile (tokens.length > 0) {\n\t\t\tvar acc;\n\t\t\tif (tokens[0].token === '^') {\n\t\t\t\tacc = 'sharp';\n\t\t\t\ttokens.shift();\n\t\t\t\tif (tokens.length === 0) return {accs: accs, warn: 'Expected note name after ' + acc};\n\t\t\t\tswitch (tokens[0].token) {\n\t\t\t\t\tcase '^': acc = 'dblsharp'; tokens.shift(); break;\n\t\t\t\t\tcase '/': acc = 'quartersharp'; tokens.shift(); break;\n\t\t\t\t}\n\t\t\t} else if (tokens[0].token === '=') {\n\t\t\t\tacc = 'natural';\n\t\t\t\ttokens.shift();\n\t\t\t} else if (tokens[0].token === '_') {\n\t\t\t\tacc = 'flat';\n\t\t\t\ttokens.shift();\n\t\t\t\tif (tokens.length === 0) return {accs: accs, warn: 'Expected note name after ' + acc};\n\t\t\t\tswitch (tokens[0].token) {\n\t\t\t\t\tcase '_': acc = 'dblflat'; tokens.shift(); break;\n\t\t\t\t\tcase '/': acc = 'quarterflat'; tokens.shift(); break;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Not an accidental, we'll assume that a later parse will recognize it.\n\t\t\t\treturn { accs: accs };\n\t\t\t}\n\t\t\tif (tokens.length === 0) return {accs: accs, warn: 'Expected note name after ' + acc};\n\t\t\tswitch (tokens[0].token.charAt(0))\n\t\t\t{\n\t\t\t\tcase 'a':\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'e':\n\t\t\t\tcase 'f':\n\t\t\t\tcase 'g':\n\t\t\t\tcase 'A':\n\t\t\t\tcase 'B':\n\t\t\t\tcase 'C':\n\t\t\t\tcase 'D':\n\t\t\t\tcase 'E':\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'G':\n\t\t\t\t\tif (accs === undefined)\n\t\t\t\t\t\taccs = [];\n\t\t\t\t\taccs.push({ acc: acc, note: tokens[0].token.charAt(0) });\n\t\t\t\t\tif (tokens[0].token.length === 1)\n\t\t\t\t\t\ttokens.shift();\n\t\t\t\t\telse\n\t\t\t\t\t\ttokens[0].token = tokens[0].token.substring(1);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn {accs: accs, warn: 'Expected note name after ' + acc + ' Found: ' + tokens[0].token };\n\t\t\t}\n\t\t}\n\t\treturn { accs: accs };\n\t};\n\n\t// This gets an accidental marking for the key signature. It has the accidental then the pitch letter.\n\tthis.getKeyAccidental = function(str) {\n\t\tvar accTranslation = {\n\t\t\t'^': 'sharp',\n\t\t\t'^^': 'dblsharp',\n\t\t\t'=': 'natural',\n\t\t\t'_': 'flat',\n\t\t\t'__': 'dblflat',\n\t\t\t'_/': 'quarterflat',\n\t\t\t'^/': 'quartersharp'\n\t\t};\n\t\tvar i = this.skipWhiteSpace(str);\n\t\tif (finished(str, i))\n\t\t\treturn {len: 0};\n\t\tvar acc = null;\n\t\tswitch (str.charAt(i))\n\t\t{\n\t\t\tcase '^':\n\t\t\tcase '_':\n\t\t\tcase '=':\n\t\t\t\tacc = str.charAt(i);\n\t\t\t\tbreak;\n\t\t\tdefault:return {len: 0};\n\t\t}\n\t\ti++;\n\t\tif (finished(str, i))\n\t\t\treturn {len: 1, warn: 'Expected note name after accidental'};\n\t\tswitch (str.charAt(i))\n\t\t{\n\t\t\tcase 'a':\n\t\t\tcase 'b':\n\t\t\tcase 'c':\n\t\t\tcase 'd':\n\t\t\tcase 'e':\n\t\t\tcase 'f':\n\t\t\tcase 'g':\n\t\t\tcase 'A':\n\t\t\tcase 'B':\n\t\t\tcase 'C':\n\t\t\tcase 'D':\n\t\t\tcase 'E':\n\t\t\tcase 'F':\n\t\t\tcase 'G':\n\t\t\t\treturn {len: i+1, token: {acc: accTranslation[acc], note: str.charAt(i)}};\n\t\t\tcase '^':\n\t\t\tcase '_':\n\t\t\tcase '/':\n\t\t\t\tacc += str.charAt(i);\n\t\t\t\ti++;\n\t\t\t\tif (finished(str, i))\n\t\t\t\t\treturn {len: 2, warn: 'Expected note name after accidental'};\n\t\t\t\tswitch (str.charAt(i))\n\t\t\t\t{\n\t\t\t\t\tcase 'a':\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\tcase 'd':\n\t\t\t\t\tcase 'e':\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'g':\n\t\t\t\t\tcase 'A':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'D':\n\t\t\t\t\tcase 'E':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\tcase 'G':\n\t\t\t\t\t\treturn {len: i+1, token: {acc: accTranslation[acc], note: str.charAt(i)}};\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn {len: 2, warn: 'Expected note name after accidental'};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn {len: 1, warn: 'Expected note name after accidental'};\n\t\t}\n\t};\n\n\tthis.isWhiteSpace = function(ch) {\n\t\treturn ch === ' ' || ch === '\\t' || ch === '\\x12';\n\t};\n\n\tthis.getMeat = function(line, start, end) {\n\t\t// This removes any comments starting with '%' and trims the ends of the string so that there are no leading or trailing spaces.\n\t\t// it returns just the start and end characters that contain the meat.\n\t\tvar comment = line.indexOf('%', start);\n\t\tif (comment >= 0 && comment < end)\n\t\t\tend = comment;\n\t\twhile (start < end && (line.charAt(start) === ' ' || line.charAt(start) === '\\t' || line.charAt(start) === '\\x12'))\n\t\t\tstart++;\n\t\twhile (start < end && (line.charAt(end-1) === ' ' || line.charAt(end-1) === '\\t' || line.charAt(end-1) === '\\x12'))\n\t\t\tend--;\n\t\treturn {start: start, end: end};\n\t};\n\n\tvar isLetter = function(ch) {\n\t\treturn (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n\t};\n\n\tvar isNumber = function(ch) {\n\t\treturn (ch >= '0' && ch <= '9');\n\t};\n\n\tthis.tokenize = function(line, start, end, alphaUntilWhiteSpace) {\n\t\t// this returns all the tokens inside the passed string. A token is a punctuation mark, a string of digits, a string of letters.\n\t\t//  Quoted strings are one token.\n\t\t//  If there is a minus sign next to a number, then it is included in the number.\n\t\t// If there is a period immediately after a number, with a number immediately following, then a float is returned.\n\t\t// The type of token is returned: quote, alpha, number, punct\n\t\t// If alphaUntilWhiteSpace is true, then the behavior of the alpha token changes.\n\n\t\tvar ret = this.getMeat(line, start, end);\n\t\tstart = ret.start;\n\t\tend = ret.end;\n\t\tvar tokens = [];\n\t\tvar i;\n\t\twhile (start < end) {\n\t\t\tif (line.charAt(start) === '\"') {\n\t\t\t\ti = start+1;\n\t\t\t\twhile (i < end && line.charAt(i) !== '\"') i++;\n\t\t\t\ttokens.push({ type: 'quote', token: line.substring(start+1, i), start: start+1, end: i});\n\t\t\t\ti++;\n\t\t\t} else if (isLetter(line.charAt(start))) {\n\t\t\t\ti = start+1;\n\t\t\t\tif (alphaUntilWhiteSpace)\n\t\t\t\t\twhile (i < end && !this.isWhiteSpace(line.charAt(i))) i++;\n\t\t\t\telse\n\t\t\t\t\twhile (i < end && isLetter(line.charAt(i))) i++;\n\t\t\t\ttokens.push({ type: 'alpha', token: line.substring(start, i), continueId: isNumber(line.charAt(i)), start: start, end: i});\n\t\t\t\tstart = i + 1;\n\t\t\t} else if (line.charAt(start) === '.' && isNumber(line.charAt(i+1))) {\n\t\t\t\ti = start+1;\n\t\t\t\tvar int2 = null;\n\t\t\t\tvar float2 = null;\n\t\t\t\twhile (i < end && isNumber(line.charAt(i))) i++;\n\n\t\t\t\tfloat2 = parseFloat(line.substring(start, i));\n\t\t\t\ttokens.push({ type: 'number', token: line.substring(start, i), intt: int2, floatt: float2, continueId: isLetter(line.charAt(i)), start: start, end: i});\n\t\t\t\tstart = i + 1;\n\t\t\t} else if (isNumber(line.charAt(start)) || (line.charAt(start) === '-' && isNumber(line.charAt(i+1)))) {\n\t\t\t\ti = start+1;\n\t\t\t\tvar intt = null;\n\t\t\t\tvar floatt = null;\n\t\t\t\twhile (i < end && isNumber(line.charAt(i))) i++;\n\t\t\t\tif (line.charAt(i) === '.' && isNumber(line.charAt(i+1))) {\n\t\t\t\t\ti++;\n\t\t\t\t\twhile (i < end && isNumber(line.charAt(i))) i++;\n\t\t\t\t} else\n\t\t\t\t\tintt = parseInt(line.substring(start, i));\n\n\t\t\t\tfloatt = parseFloat(line.substring(start, i));\n\t\t\t\ttokens.push({ type: 'number', token: line.substring(start, i), intt: intt, floatt: floatt, continueId: isLetter(line.charAt(i)), start: start, end: i});\n\t\t\t\tstart = i + 1;\n\t\t\t} else if (line.charAt(start) === ' ' || line.charAt(start) === '\\t') {\n\t\t\t\ti = start+1;\n\t\t\t} else {\n\t\t\t\ttokens.push({ type: 'punct', token: line.charAt(start), start: start, end: start+1});\n\t\t\t\ti = start+1;\n\t\t\t}\n\t\t\tstart = i;\n\t\t}\n\t\treturn tokens;\n\t};\n\n\tthis.getVoiceToken = function(line, start, end) {\n\t\t// This finds the next token. A token is delimited by a space or an equal sign. If it starts with a quote, then the portion between the quotes is returned.\n\t\tvar i = start;\n\t\twhile (i < end && this.isWhiteSpace(line.charAt(i)) || line.charAt(i) === '=')\n\t\t\ti++;\n\n\t\tif (line.charAt(i) === '\"') {\n\t\t\tvar close = line.indexOf('\"', i+1);\n\t\t\tif (close === -1 || close >= end)\n\t\t\t\treturn {len: 1, err: \"Missing close quote\"};\n\t\t\treturn {len: close-start+1, token: this.translateString(line.substring(i+1, close))};\n\t\t} else {\n\t\t\tvar ii = i;\n\t\t\twhile (ii < end && !this.isWhiteSpace(line.charAt(ii)) && line.charAt(ii) !== '=')\n\t\t\t\tii++;\n\t\t\treturn {len: ii-start+1, token: line.substring(i, ii)};\n\t\t}\n\t};\n\n\tvar charMap = {\n\t\t\"`a\": 'à', \"'a\": \"á\", \"^a\": \"â\", \"~a\": \"ã\", \"\\\"a\": \"ä\", \"oa\": \"å\", \"aa\": \"å\", \"=a\": \"ā\", \"ua\": \"ă\", \";a\": \"ą\",\n\t\t\"`e\": 'è', \"'e\": \"é\", \"^e\": \"ê\", \"\\\"e\": \"ë\", \"=e\": \"ē\", \"ue\": \"ĕ\", \";e\": \"ę\", \".e\": \"ė\",\n\t\t\"`i\": 'ì', \"'i\": \"í\", \"^i\": \"î\", \"\\\"i\": \"ï\", \"=i\": \"ī\", \"ui\": \"ĭ\", \";i\": \"į\",\n\t\t\"`o\": 'ò', \"'o\": \"ó\", \"^o\": \"ô\", \"~o\": \"õ\", \"\\\"o\": \"ö\", \"=o\": \"ō\", \"uo\": \"ŏ\", \"/o\": \"ø\",\n\t\t\"`u\": 'ù', \"'u\": \"ú\", \"^u\": \"û\", \"~u\": \"ũ\", \"\\\"u\": \"ü\", \"ou\": \"ů\", \"=u\": \"ū\", \"uu\": \"ŭ\", \";u\": \"ų\",\n\t\t\"`A\": 'À', \"'A\": \"Á\", \"^A\": \"Â\", \"~A\": \"Ã\", \"\\\"A\": \"Ä\", \"oA\": \"Å\", \"AA\": \"Å\", \"=A\": \"Ā\", \"uA\": \"Ă\", \";A\": \"Ą\",\n\t\t\"`E\": 'È', \"'E\": \"É\", \"^E\": \"Ê\", \"\\\"E\": \"Ë\", \"=E\": \"Ē\", \"uE\": \"Ĕ\", \";E\": \"Ę\", \".E\": \"Ė\",\n\t\t\"`I\": 'Ì', \"'I\": \"Í\", \"^I\": \"Î\", \"~I\": \"Ĩ\", \"\\\"I\": \"Ï\", \"=I\": \"Ī\", \"uI\": \"Ĭ\", \";I\": \"Į\", \".I\": \"İ\",\n\t\t\"`O\": 'Ò', \"'O\": \"Ó\", \"^O\": \"Ô\", \"~O\": \"Õ\", \"\\\"O\": \"Ö\", \"=O\": \"Ō\", \"uO\": \"Ŏ\", \"/O\": \"Ø\",\n\t\t\"`U\": 'Ù', \"'U\": \"Ú\", \"^U\": \"Û\", \"~U\": \"Ũ\", \"\\\"U\": \"Ü\", \"oU\": \"Ů\", \"=U\": \"Ū\", \"uU\": \"Ŭ\", \";U\": \"Ų\",\n\t\t\"ae\": \"æ\", \"AE\": \"Æ\", \"oe\": \"œ\", \"OE\": \"Œ\", \"ss\": \"ß\",\n\t\t\"'c\": \"ć\", \"^c\": \"ĉ\", \"uc\": \"č\", \"cc\": \"ç\", \".c\": \"ċ\", \"cC\": \"Ç\", \"'C\": \"Ć\", \"^C\": \"Ĉ\", \"uC\": \"Č\", \".C\": \"Ċ\",\n\t\t\"~N\": \"Ñ\", \"~n\": \"ñ\",\n\t\t\"=s\": \"š\", \"vs\": \"š\",\n\t\t\"DH\": \"Ð\", \"dh\": \"ð\",\n\t\t\"HO\": \"Ő\", \"Ho\": \"ő\", \"HU\": \"Ű\", \"Hu\": \"ű\",\n\t\t\"'Y\": \"Ý\", \"'y\": \"ý\", \"^Y\": \"Ŷ\", \"^y\": \"ŷ\", \"\\\"Y\": \"Ÿ\", \"\\\"y\": \"ÿ\",\n\t\t\"vS\": \"Š\", \"vZ\": \"Ž\", \"vz\": 'ž'\n\n// More chars: Ĳ ĳ Ď ď Đ đ Ĝ ĝ Ğ ğ Ġ ġ Ģ ģ Ĥ ĥ Ħ ħ Ĵ ĵ Ķ ķ ĸ Ĺ ĺ Ļ ļ Ľ ľ Ŀ ŀ Ł ł Ń ń Ņ ņ Ň ň ŉ Ŋ ŋ Ŕ ŕ Ŗ ŗ Ř ř Ś ś Ŝ ŝ Ş ş Š Ţ ţ Ť ť Ŧ ŧ Ŵ ŵ Ź ź Ż ż Ž\n\t};\n\tvar charMap1 = {\n\t\t\"#\": \"♯\",\n\t\t\"b\": \"♭\",\n\t\t\"=\": \"♮\"\n\t};\n\tvar charMap2 = {\n\t\t\"201\": \"♯\",\n\t\t\"202\": \"♭\",\n\t\t\"203\": \"♮\",\n\t\t\"241\": \"¡\",\n\t\t\"242\": \"¢\", \"252\": \"a\", \"262\": \"2\", \"272\": \"o\", \"302\": \"Â\", \"312\": \"Ê\", \"322\": \"Ò\", \"332\": \"Ú\", \"342\": \"â\", \"352\": \"ê\", \"362\": \"ò\", \"372\": \"ú\",\n\t\t\"243\": \"£\", \"253\": \"«\", \"263\": \"3\", \"273\": \"»\", \"303\": \"Ã\", \"313\": \"Ë\", \"323\": \"Ó\", \"333\": \"Û\", \"343\": \"ã\", \"353\": \"ë\", \"363\": \"ó\", \"373\": \"û\",\n\t\t\"244\": \"¤\", \"254\": \"¬\", \"264\": \"  ́\", \"274\": \"1⁄4\", \"304\": \"Ä\", \"314\": \"Ì\", \"324\": \"Ô\", \"334\": \"Ü\", \"344\": \"ä\", \"354\": \"ì\", \"364\": \"ô\", \"374\": \"ü\",\n\t\t\"245\": \"¥\", \"255\": \"-\", \"265\": \"μ\", \"275\": \"1⁄2\", \"305\": \"Å\", \"315\": \"Í\", \"325\": \"Õ\", \"335\": \"Ý\",  \"345\": \"å\", \"355\": \"í\", \"365\": \"õ\", \"375\": \"ý\",\n\t\t\"246\": \"¦\", \"256\": \"®\", \"266\": \"¶\", \"276\": \"3⁄4\", \"306\": \"Æ\", \"316\": \"Î\", \"326\": \"Ö\", \"336\": \"Þ\", \"346\": \"æ\", \"356\": \"î\", \"366\": \"ö\", \"376\": \"þ\",\n\t\t\"247\": \"§\", \"257\": \" ̄\", \"267\": \"·\", \"277\": \"¿\", \"307\": \"Ç\", \"317\": \"Ï\", \"327\": \"×\", \"337\": \"ß\", \"347\": \"ç\", \"357\": \"ï\", \"367\": \"÷\", \"377\": \"ÿ\",\n\t\t\"250\": \" ̈\", \"260\": \"°\", \"270\": \" ̧\", \"300\": \"À\", \"310\": \"È\", \"320\": \"Ð\", \"330\": \"Ø\", \"340\": \"à\", \"350\": \"è\", \"360\": \"ð\", \"370\": \"ø\",\n\t\t\"251\": \"©\", \"261\": \"±\", \"271\": \"1\", \"301\": \"Á\", \"311\": \"É\", \"321\": \"Ñ\", \"331\": \"Ù\", \"341\": \"á\", \"351\": \"é\", \"361\": \"ñ\", \"371\": \"ù\" };\n\tthis.translateString = function(str) {\n\t\tvar arr = str.split('\\\\');\n\t\tif (arr.length === 1) return str;\n\t\tvar out = null;\n\t\tparseCommon.each(arr, function(s) {\n\t\t\tif (out === null)\n\t\t\t\tout = s;\n\t\t\telse {\n\t\t\t\tvar c = charMap[s.substring(0, 2)];\n\t\t\t\tif (c !== undefined)\n\t\t\t\t\tout += c + s.substring(2);\n\t\t\t\telse {\n\t\t\t\t\tc = charMap2[s.substring(0, 3)];\n\t\t\t\t\tif (c !== undefined)\n\t\t\t\t\t\tout += c + s.substring(3);\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = charMap1[s.substring(0, 1)];\n\t\t\t\t\t\tif (c !== undefined)\n\t\t\t\t\t\t\tout += c + s.substring(1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tout += \"\\\\\" + s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn out;\n\t};\n\tthis.getNumber = function(line, index) {\n\t\tvar num = 0;\n\t\twhile (index < line.length) {\n\t\t\tswitch (line.charAt(index)) {\n\t\t\t\tcase '0':num = num*10;index++;break;\n\t\t\t\tcase '1':num = num*10+1;index++;break;\n\t\t\t\tcase '2':num = num*10+2;index++;break;\n\t\t\t\tcase '3':num = num*10+3;index++;break;\n\t\t\t\tcase '4':num = num*10+4;index++;break;\n\t\t\t\tcase '5':num = num*10+5;index++;break;\n\t\t\t\tcase '6':num = num*10+6;index++;break;\n\t\t\t\tcase '7':num = num*10+7;index++;break;\n\t\t\t\tcase '8':num = num*10+8;index++;break;\n\t\t\t\tcase '9':num = num*10+9;index++;break;\n\t\t\t\tdefault:\n\t\t\t\t\treturn {num: num, index: index};\n\t\t\t}\n\t\t}\n\t\treturn {num: num, index: index};\n\t};\n\n\tthis.getFraction = function(line, index) {\n\t\tvar num = 1;\n\t\tvar den = 1;\n\t\tif (line.charAt(index) !== '/') {\n\t\t\tvar ret = this.getNumber(line, index);\n\t\t\tnum = ret.num;\n\t\t\tindex = ret.index;\n\t\t}\n\t\tif (line.charAt(index) === '/') {\n\t\t\tindex++;\n\t\t\tif (line.charAt(index) === '/') {\n\t\t\t\tvar div = 0.5;\n\t\t\t\twhile (line.charAt(index++) === '/')\n\t\t\t\t\tdiv = div /2;\n\t\t\t\treturn {value: num * div, index: index-1};\n\t\t\t} else {\n\t\t\t\tvar iSave = index;\n\t\t\t\tvar ret2 = this.getNumber(line, index);\n\t\t\t\tif (ret2.num === 0 && iSave === index)\t// If we didn't use any characters, it is an implied 2\n\t\t\t\t\tret2.num = 2;\n\t\t\t\tif (ret2.num !== 0)\n\t\t\t\t\tden = ret2.num;\n\t\t\t\tindex = ret2.index;\n\t\t\t}\n\t\t}\n\n\t\treturn {value: num/den, index: index};\n\t};\n\n\tthis.theReverser = function(str) {\n\t\tif (parseCommon.endsWith(str, \", The\"))\n\t\t\treturn \"The \" + str.substring(0, str.length-5);\n\t\tif (parseCommon.endsWith(str, \", A\"))\n\t\t\treturn \"A \" + str.substring(0, str.length-3);\n\t\treturn str;\n\t};\n\n\tthis.stripComment = function(str) {\n\t\tvar i = str.indexOf('%');\n\t\tif (i >= 0)\n\t\t\treturn parseCommon.strip(str.substring(0, i));\n\t\treturn parseCommon.strip(str);\n\t};\n\n\tthis.getInt = function(str) {\n\t\t// This parses the beginning of the string for a number and returns { value: num, digits: num }\n\t\t// If digits is 0, then the string didn't point to a number.\n\t\tvar x = parseInt(str);\n\t\tif (isNaN(x))\n\t\t\treturn {digits: 0};\n\t\tvar s = \"\" + x;\n\t\tvar i = str.indexOf(s);\t// This is to account for leading spaces\n\t\treturn {value: x, digits: i+s.length};\n\t};\n\n\tthis.getFloat = function(str) {\n\t\t// This parses the beginning of the string for a number and returns { value: num, digits: num }\n\t\t// If digits is 0, then the string didn't point to a number.\n\t\tvar x = parseFloat(str);\n\t\tif (isNaN(x))\n\t\t\treturn {digits: 0};\n\t\tvar s = \"\" + x;\n\t\tvar i = str.indexOf(s);\t// This is to account for leading spaces\n\t\treturn {value: x, digits: i+s.length};\n\t};\n\n\tthis.getMeasurement = function(tokens) {\n\t\tif (tokens.length === 0) return { used: 0 };\n\t\tvar used = 1;\n\t\tvar num = '';\n\t\tif (tokens[0].token === '-') {\n\t\t\ttokens.shift();\n\t\t\tnum = '-';\n\t\t\tused++;\n\t\t}\n\t\telse if (tokens[0].type !== 'number') return { used: 0 };\n\t\tnum += tokens.shift().token;\n\t\tif (tokens.length === 0) return { used: 1, value: parseInt(num) };\n\t\tvar x = tokens.shift();\n\t\tif (x.token === '.') {\n\t\t\tused++;\n\t\t\tif (tokens.length === 0) return { used: used, value: parseInt(num) };\n\t\t\tif (tokens[0].type === 'number') {\n\t\t\t\tx = tokens.shift();\n\t\t\t\tnum = num + '.' + x.token;\n\t\t\t\tused++;\n\t\t\t\tif (tokens.length === 0) return { used: used, value: parseFloat(num) };\n\t\t\t}\n\t\t\tx = tokens.shift();\n\t\t}\n\t\tswitch (x.token) {\n\t\t\tcase 'pt': return { used: used+1, value: parseFloat(num) };\n\t\t\tcase 'cm': return { used: used+1, value: parseFloat(num)/2.54*72 };\n\t\t\tcase 'in': return { used: used+1, value: parseFloat(num)*72 };\n\t\t\tdefault: tokens.unshift(x); return { used: used, value: parseFloat(num) };\n\t\t}\n\t\treturn { used: 0 };\n\t};\n\tvar substInChord = function(str)\n\t{\n\t\twhile ( str.indexOf(\"\\\\n\") !== -1)\n\t\t{\n\t\t\tstr = str.replace(\"\\\\n\", \"\\n\");\n\t\t}\n\t\treturn str;\n\t};\n\tthis.getBrackettedSubstring = function(line, i, maxErrorChars, _matchChar)\n\t{\n\t\t// This extracts the sub string by looking at the first character and searching for that\n\t\t// character later in the line (or search for the optional _matchChar).\n\t\t// For instance, if the first character is a quote it will look for\n\t\t// the end quote. If the end of the line is reached, then only up to the default number\n\t\t// of characters are returned, so that a missing end quote won't eat up the entire line.\n\t\t// It returns the substring and the number of characters consumed.\n\t\t// The number of characters consumed is normally two more than the size of the substring,\n\t\t// but in the error case it might not be.\n\t\tvar matchChar = _matchChar || line.charAt(i);\n\t\tvar pos = i+1;\n\t\twhile ((pos < line.length) && (line.charAt(pos) !== matchChar))\n\t\t\t++pos;\n\t\tif (line.charAt(pos) === matchChar)\n\t\t\treturn [pos-i+1,substInChord(line.substring(i+1, pos)), true];\n\t\telse\t// we hit the end of line, so we'll just pick an arbitrary num of chars so the line doesn't disappear.\n\t\t{\n\t\t\tpos = i+maxErrorChars;\n\t\t\tif (pos > line.length-1)\n\t\t\t\tpos = line.length-1;\n\t\t\treturn [pos-i+1, substInChord(line.substring(i+1, pos)), false];\n\t\t}\n\t};\n};\n\nmodule.exports = Tokenizer;\n"]},"metadata":{},"sourceType":"script"}