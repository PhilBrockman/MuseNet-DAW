{"ast":null,"code":"//    abc_animation.js: handles animating the music in real time.\n//    Copyright (C) 2014-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*global console */\nvar spacing = require('../write/abc_spacing');\n\nvar parseCommon = require('../parse/abc_common');\n\nvar animation = {};\n\n(function () {\n  \"use strict\";\n\n  function hasClass(element, cls) {\n    var elClass = element.getAttribute(\"class\");\n    var rclass = /[\\t\\r\\n\\f]/g;\n    var className = \" \" + cls + \" \";\n    return element.nodeType === 1 && (\" \" + elClass + \" \").replace(rclass, \" \").indexOf(className) >= 0;\n  }\n\n  function getAllElementsByClasses(startingEl, class1, class2) {\n    var els = startingEl.getElementsByClassName(class1);\n    var ret = [];\n\n    for (var i = 0; i < els.length; i++) {\n      if (hasClass(els[i], class2)) ret.push(els[i]);\n    }\n\n    return ret;\n  } // This finds the place in the stylesheets that contain the rule that matches the selector.\n  // If that selector is not found, then it creates the rule.\n  // We are doing this so that we can use a transition for animating the scrolling.\n\n\n  function getCssRule(selector) {\n    var rule;\n\n    for (var i = 0; i < document.styleSheets.length && rule === undefined; i++) {\n      var css = document.styleSheets[i];\n      var rules = css.rules;\n\n      if (rules) {\n        for (var j = 0; j < rules.length && rule === undefined; j++) {\n          if (rules[j].selectorText && rules[j].selectorText === selector) rule = rules[j];\n        }\n      }\n    }\n\n    if (!rule) {\n      document.styleSheets[0].insertRule(selector + \" { }\", 1);\n      return getCssRule(selector);\n    }\n\n    return rule;\n  }\n\n  function getBeatsPerMinute(tune, options) {\n    // We either want to run the timer once per measure or once per beat. If we run it once per beat we need a multiplier for the measures.\n    // So, first we figure out the beats per minute and the beats per measure, then depending on the type of animation, we can\n    // calculate the desired interval (ret.tick) and the number of ticks before we want to run the measure\n    var bpm;\n    if (options.bpm) bpm = options.bpm;else {\n      if (tune && tune.metaText && tune.metaText.tempo && tune.metaText.tempo.bpm) bpm = tune.metaText.tempo.bpm;else bpm = 120; // Just set it to something. The user should have set this.\n    }\n    return bpm;\n  }\n\n  var scrollTimer;\n  var animateTimer;\n  var cssRule;\n  var currentMargin;\n  var animationTarget;\n  var shouldResetOverflow; // This is a way to manipulate the written music on a timer. Their are two ways to manipulate the music: turn off each measure as it goes by,\n  // and put a vertical cursor before the next note to play. The timer works at the speed of the original tempo of the music unless it is overwritten\n  // in the options parameter.\n  //\n  // parameters:\n  // paper: the output div that the music is in.\n  // tune: the tune object returned by renderAbc.\n  // options: a hash containing the following:\n  //    hideFinishedMeasures: true or false [ false is the default ]\n  //    hideCurrentMeasure: true or false [ false is the default ]\n  //    showCursor: true or false [ false is the default ]\n  //    bpm: number of beats per minute [ the default is whatever is in the Q: field ]\n  //    scrollHorizontal: true or false [ false is the default ]\n  //    scrollVertical: true or false [ false is the default ]\n  //    scrollHint: true or false [ false is the default ]\n  //\n  // If scrollHorizontal is present, then we expect that the music was rendered with the viewportHorizontal parameter so there is a viewport wrapping the music div. (Note that this only works when there is a single line of music and there are no repeats, signo, or codas.)\n  // If scrollVertical or scrollHint is present, then we expect that the music was rendered with the viewportVertical parameter so there is a viewport wrapping the music div.\n  // If the music is larger than the viewport, then it scrolls as the music is being played.\n\n  var stopNextTime = false;\n  var cursor;\n  var startTime;\n  var isPaused;\n  var pausedTime;\n  var pausedDifference;\n  var processNext;\n\n  function setMargin(margin) {\n    cssRule.style.marginTop = -margin + \"px\";\n    currentMargin = margin;\n  }\n\n  animation.startAnimation = function (paper, tune, options) {\n    if (paper.getElementsByClassName === undefined) {\n      console.error(\"ABCJS.startAnimation: The first parameter must be a regular DOM element. (Did you pass a jQuery object or an ID?)\");\n      return;\n    }\n\n    if (tune.getBeatLength === undefined) {\n      console.error(\"ABCJS.startAnimation: The second parameter must be a single tune. (Did you pass the entire array of tunes?)\");\n      return;\n    }\n\n    if (options.scrollHorizontal || options.scrollVertical || options.scrollHint) {\n      // We assume that there is an extra div in this case, so adjust the paper if needed.\n      // This can be called either with the outer div or the inner div.\n      if (!hasClass(paper, 'abcjs-inner')) {\n        // Must be the outer div; hide the scrollbar and move in.\n        paper.scrollTop = 0; // In case the user has repositioned the scrollbar.\n\n        paper.style.overflow = \"hidden\";\n        paper = paper.children[0];\n      }\n\n      if (!hasClass(paper, 'abcjs-inner')) {\n        console.error(\"ABCJS.startAnimation: When using scrollHorizontal/scrollVertical/scrollHint, the music must have been rendered using viewportHorizontal/viewportVertical.\");\n        return;\n      }\n    } // Can only have one animation at a time, so make sure that it has been stopped.\n\n\n    animation.stopAnimation();\n    animationTarget = paper;\n    shouldResetOverflow = options.scrollVertical || options.scrollHint;\n\n    if (options.showCursor) {\n      cursor = document.createElement('DIV');\n      cursor.className = 'abcjs-cursor cursor';\n      cursor.style.position = 'absolute';\n      paper.appendChild(cursor);\n      paper.style.position = 'relative';\n    }\n\n    stopNextTime = false;\n    var beatsPerMinute = getBeatsPerMinute(tune, options);\n    var beatsPerMillisecond = beatsPerMinute / 60000;\n    var beatLength = tune.getBeatLength(); // This is the same units as the duration is stored in.\n\n    var totalBeats = 0;\n    var millisecondsPerHalfMeasure;\n\n    if (options.scrollVertical) {\n      var millisecondsPerBeat = 1 / beatsPerMillisecond;\n      var beatsPerMeasure = 1 / beatLength;\n      var millisecondsPerMeasure = millisecondsPerBeat * beatsPerMeasure;\n      millisecondsPerHalfMeasure = millisecondsPerMeasure / 2;\n      cssRule = getCssRule(\".abcjs-inner\");\n    }\n\n    isPaused = false;\n    var initialWait = 2700;\n    var interval = 11;\n    var distance = 1;\n    var outer = paper.parentNode;\n\n    function scrolling() {\n      var currentPosition = paper.style.marginLeft;\n      if (currentPosition === \"\") currentPosition = 0;else currentPosition = parseInt(currentPosition);\n      currentPosition -= distance;\n      paper.style.marginLeft = currentPosition + \"px\";\n      if (currentPosition > outer.offsetWidth - paper.scrollWidth) scrollTimer = setTimeout(scrolling, interval);\n    }\n\n    if (options.scrollHorizontal) {\n      paper.style.marginLeft = \"0px\";\n      scrollTimer = setTimeout(scrolling, initialWait);\n    }\n\n    function nextMeasure(lineNum, measureNum) {\n      lineNum = parseInt(lineNum, 10);\n      measureNum = parseInt(measureNum, 10);\n      measureNum++;\n      var els = getAllElementsByClasses(paper, \"l\" + lineNum, \"m\" + measureNum);\n      if (els.length > 0) return [lineNum, measureNum];\n      lineNum++;\n      measureNum = 0;\n      els = getAllElementsByClasses(paper, \"l\" + lineNum, \"m\" + measureNum);\n      if (els.length > 0) return [lineNum, measureNum];\n      return null;\n    }\n\n    function processMeasureHider(lineNum, measureNum) {\n      var els = getAllElementsByClasses(paper, \"l\" + lineNum, \"m\" + measureNum);\n\n      if (els.length > 0) {\n        for (var i = 0; i < els.length; i++) {\n          var el = els[i];\n          if (!hasClass(el, \"bar\")) el.style.display = \"none\";\n        }\n      }\n    }\n\n    function addVerticalInfo(timingEvents) {\n      // Add vertical info to the bar events: put the next event's top, and the event after the next measure's top.\n      var lastBarTop;\n      var lastBarBottom;\n      var lastEventTop;\n      var lastEventBottom;\n\n      for (var e = timingEvents.length - 1; e >= 0; e--) {\n        var ev = timingEvents[e];\n\n        if (ev.type === 'bar') {\n          ev.top = lastEventTop;\n          ev.nextTop = lastBarTop;\n          lastBarTop = lastEventTop;\n          ev.bottom = lastEventBottom;\n          ev.nextBottom = lastBarBottom;\n          lastBarBottom = lastEventBottom;\n        } else if (ev.type === 'event') {\n          lastEventTop = ev.top;\n          lastEventBottom = ev.top + ev.height;\n        }\n      }\n    }\n\n    function makeSortedArray(hash) {\n      var arr = [];\n\n      for (var k in hash) {\n        if (hash.hasOwnProperty(k)) arr.push(hash[k]);\n      }\n\n      arr = arr.sort(function (a, b) {\n        var diff = a.time - b.time; // if the events have the same time, make sure a bar comes before a note\n\n        if (diff !== 0) {\n          return diff;\n        } else {\n          return a.type === \"bar\" ? -1 : 1;\n        }\n      });\n      return arr;\n    } // Gets the line and measure number from the element's classes\n\n\n    function getLineAndMeasure(element) {\n      var klass = element.elemset[0].attrs['class'];\n      var arr = klass.split(' ');\n      var lineNum;\n      var measureNum;\n\n      for (var i = 0; i < arr.length; i++) {\n        var match = /m(\\d+)/.exec(arr[i]);\n        if (match) measureNum = match[1];\n        match = /l(\\d+)/.exec(arr[i]);\n        if (match) lineNum = match[1];\n      }\n\n      return {\n        lineNum: lineNum,\n        measureNum: measureNum\n      };\n    } // Switches the music from line-based to voice-based.\n\n\n    function convertToVoices(staffGroups) {\n      var voices = [];\n\n      for (var line = 0; line < staffGroups.length; line++) {\n        var group = staffGroups[line];\n        var firstStaff = group.staffs[0];\n        var middleC = firstStaff.absoluteY;\n        var top = middleC - firstStaff.top * spacing.STEP;\n        var lastStaff = group.staffs[group.staffs.length - 1];\n        middleC = lastStaff.absoluteY;\n        var bottom = middleC - lastStaff.bottom * spacing.STEP; // Put in the notes for all voices, then sort them, then remove duplicates\n\n        for (var v = 0; v < group.voices.length; v++) {\n          if (v >= voices.length) voices.push([]);\n          var elements = group.voices[v].children;\n\n          for (var elem = 0; elem < elements.length; elem++) {\n            var element = elements[elem];\n            if (element.hint) break;\n\n            if (element.duration > 0) {\n              voices[v].push({\n                type: \"event\",\n                top: top,\n                height: bottom - top,\n                left: element.x,\n                width: element.w,\n                duration: element.durationClass ? element.durationClass : element.duration,\n                isTiedToNext: element.startTie !== undefined\n              });\n            } // Only add a bar if it is not repeated; that is, we don't want two bars in a row.\n\n\n            if (element.type === 'bar') {\n              if (voices[v].length === 0 || voices[v][voices[v].length - 1].type !== 'bar') {\n                if (element.elemset && element.elemset.length > 0 && element.elemset[0].attrs) {\n                  var obj = getLineAndMeasure(element);\n                  voices[v].push({\n                    type: \"bar\",\n                    barType: element.abcelem.type,\n                    startEnding: element.abcelem.startEnding === \"1\",\n                    lineNum: obj.lineNum,\n                    measureNum: obj.measureNum\n                  });\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return voices;\n    } // Duplicates the elements that are repeated.\n\n\n    function spreadVoices(voices) {\n      var ret = [];\n\n      for (var i = 0; i < voices.length; i++) {\n        var voice = voices[i];\n        ret.push([]);\n        var startRepeatIndex = 0; // If there is no explicit start repeat, then it starts at the beginning.\n\n        var endRepeatIndex = -1;\n\n        for (var j = 0; j < voice.length; j++) {\n          var elem = voice[j];\n          ret[i].push(voice[j]);\n          var endRepeat = elem.barType === \"bar_right_repeat\" || elem.barType === \"bar_dbl_repeat\";\n          var startEnding = elem.startEnding;\n          var startRepeat = elem.barType === \"bar_left_repeat\" || elem.barType === \"bar_dbl_repeat\" || elem.barType === \"bar_thick_thin\" || elem.barType === \"bar_thin_thick\" || elem.barType === \"bar_thin_thin\" || elem.barType === \"bar_right_repeat\";\n\n          if (endRepeat) {\n            if (endRepeatIndex === -1) endRepeatIndex = j;\n\n            for (var k = startRepeatIndex; k <= endRepeatIndex; k++) {\n              ret[i].push(parseCommon.clone(voice[k]));\n            }\n          }\n\n          if (startEnding) endRepeatIndex = j;\n          if (startRepeat) startRepeatIndex = j + 1;\n        }\n      }\n\n      return ret;\n    }\n\n    function combineVoices(voiceList) {\n      var eventHash = {};\n\n      for (var v = 0; v < voiceList.length; v++) {\n        var time = 0;\n        var isTiedState = false;\n\n        for (var i = 0; i < voiceList[v].length; i++) {\n          var item = voiceList[v][i];\n          item.time = time;\n\n          if (item.type === \"event\") {\n            var isTiedToNext = item.isTiedToNext;\n\n            if (isTiedState) {\n              if (!isTiedToNext) isTiedState = false; // If the note is tied on both sides it can just be ignored.\n            } else {\n              // the last note wasn't tied.\n              if (!eventHash[\"event\" + time]) eventHash[\"event\" + time] = item;else {\n                // If there is more than one voice then two notes can fall at the same time. Usually they would be lined up in the same place, but if it is a whole rest, then it is placed funny. In any case, the left most element wins.\n                eventHash[\"event\" + time].left = Math.min(eventHash[\"event\" + time].left, item.left);\n              }\n              if (isTiedToNext) isTiedState = true;\n            }\n\n            time += item.duration;\n          } else {\n            eventHash[\"bar\" + time] = item;\n          }\n        }\n      }\n\n      return eventHash;\n    }\n\n    var timingEvents = [];\n\n    function setupEvents(engraver) {\n      // First, rearrange the elements to be in voice order (that is, remove the lines.)\n      // Then, for each voice, duplicate the events needed for the repeats.\n      // Then go through each event array and fill in the timingEvents.\n      var voiceList = convertToVoices(engraver.staffgroups);\n      voiceList = spreadVoices(voiceList);\n      var eventHash = combineVoices(voiceList); // now we have all the events, but if there are multiple voices then there may be events out of order or duplicated, so normalize it.\n\n      timingEvents = makeSortedArray(eventHash);\n      totalBeats = timingEvents[timingEvents.length - 1].time / beatLength;\n\n      if (options.scrollVertical) {\n        addVerticalInfo(timingEvents);\n      }\n    }\n\n    setupEvents(tune.engraver);\n\n    function isEndOfLine(currentNote) {\n      return currentNote.top !== currentNote.nextTop && currentNote.nextTop !== undefined;\n    }\n\n    function shouldScroll(outer, scrollPos, currentNote) {\n      var height = parseInt(outer.clientHeight, 10);\n      var isVisible = currentNote.nextBottom - scrollPos < height; //console.log(\"SCROLL: \", height, scrollPos, currentNote.nextTop, currentNote.nextBottom, isVisible);\n\n      return !isVisible;\n    }\n\n    var lastTop = -1; // var inner = outer.querySelectorAll('.abcjs-inner');\n\n    currentMargin = 0;\n\n    if (options.scrollVertical) {\n      setMargin(0); // In case we are calling this a second time.\n    }\n\n    function processShowCursor() {\n      var currentNote = timingEvents.shift();\n\n      if (!currentNote) {\n        stopNextTime = true;\n        return 0;\n      }\n\n      if (currentNote.type === \"bar\") {\n        if (options.scrollVertical) {\n          if (isEndOfLine(currentNote) && shouldScroll(outer, currentMargin, currentNote)) {\n            setTimeout(function () {\n              setMargin(currentNote.nextTop);\n            }, millisecondsPerHalfMeasure);\n          }\n        }\n\n        if (options.hideCurrentMeasure) {\n          var next = nextMeasure(currentNote.lineNum, currentNote.measureNum);\n          if (next) processMeasureHider(next[0], next[1]);\n        } else if (options.hideFinishedMeasures) processMeasureHider(currentNote.lineNum, currentNote.measureNum);\n\n        if (timingEvents.length > 0) return timingEvents[0].time / beatLength;\n        return 0;\n      }\n\n      if (options.scrollHint && lastTop !== currentNote.top) {\n        lastTop = currentNote.top;\n        setMargin(lastTop);\n      }\n\n      if (options.showCursor && cursor && cursor.style) {\n        cursor.style.left = currentNote.left + \"px\";\n        cursor.style.top = currentNote.top + \"px\";\n        cursor.style.width = currentNote.width + \"px\";\n        cursor.style.height = currentNote.height + \"px\";\n      }\n\n      if (timingEvents.length > 0) return timingEvents[0].time / beatLength;\n      stopNextTime = true;\n      return 0;\n    }\n\n    processNext = function () {\n      if (stopNextTime) {\n        animation.stopAnimation();\n        return;\n      }\n\n      var currentTime = new Date().getTime();\n\n      if (isPaused) {\n        // The isPaused flag must have just turned on. If it had been encountered before, we wouldn't be calling processNext.\n        // pausedTime contains the moment that pause was called. There is a delay until here, so the timing will be off by the distance.\n        pausedDifference = currentTime - pausedTime;\n        return;\n      }\n\n      var nextTimeInBeats = processShowCursor();\n      var nextTimeInMilliseconds = nextTimeInBeats / beatsPerMillisecond;\n      var interval = startTime + nextTimeInMilliseconds - currentTime;\n      if (interval <= 0) processNext();else animateTimer = setTimeout(processNext, interval);\n    };\n\n    startTime = new Date();\n    startTime = startTime.getTime();\n    isPaused = false;\n\n    if (options.hideCurrentMeasure) {\n      var next = nextMeasure(0, -1);\n      if (next) processMeasureHider(next[0], next[1]);\n    }\n\n    processNext();\n  };\n\n  animation.pauseAnimation = function (pause) {\n    if (!processNext) {\n      console.warn(\"Cannot call pauseAnimation before calling startAnimation\");\n      return;\n    }\n\n    if (pause && !isPaused) {\n      isPaused = true;\n      pausedTime = new Date().getTime();\n    } else if (!pause && isPaused) {\n      var nowTime = new Date().getTime();\n      var elapsedTimeWhenPaused = nowTime - pausedTime;\n      startTime += elapsedTimeWhenPaused;\n      pausedTime = undefined;\n      isPaused = false;\n      animateTimer = setTimeout(processNext, pausedDifference);\n      pausedDifference = undefined;\n    }\n  };\n\n  animation.stopAnimation = function () {\n    clearTimeout(animateTimer);\n    clearTimeout(scrollTimer);\n\n    if (cursor) {\n      cursor.remove();\n      cursor = null;\n    }\n\n    if (shouldResetOverflow) {\n      if (animationTarget && animationTarget.parentNode) // If the music was redrawn or otherwise disappeared before the animation was finished, this might be null.\n        animationTarget.parentNode.style.overflowY = \"auto\";\n      setMargin(0);\n    }\n  };\n})();\n\nmodule.exports = animation;","map":{"version":3,"sources":["/Users/philbrockman/coding/MusicalGens/app/http/web/app/node_modules/abcjs/src/api/abc_animation.js"],"names":["spacing","require","parseCommon","animation","hasClass","element","cls","elClass","getAttribute","rclass","className","nodeType","replace","indexOf","getAllElementsByClasses","startingEl","class1","class2","els","getElementsByClassName","ret","i","length","push","getCssRule","selector","rule","document","styleSheets","undefined","css","rules","j","selectorText","insertRule","getBeatsPerMinute","tune","options","bpm","metaText","tempo","scrollTimer","animateTimer","cssRule","currentMargin","animationTarget","shouldResetOverflow","stopNextTime","cursor","startTime","isPaused","pausedTime","pausedDifference","processNext","setMargin","margin","style","marginTop","startAnimation","paper","console","error","getBeatLength","scrollHorizontal","scrollVertical","scrollHint","scrollTop","overflow","children","stopAnimation","showCursor","createElement","position","appendChild","beatsPerMinute","beatsPerMillisecond","beatLength","totalBeats","millisecondsPerHalfMeasure","millisecondsPerBeat","beatsPerMeasure","millisecondsPerMeasure","initialWait","interval","distance","outer","parentNode","scrolling","currentPosition","marginLeft","parseInt","offsetWidth","scrollWidth","setTimeout","nextMeasure","lineNum","measureNum","processMeasureHider","el","display","addVerticalInfo","timingEvents","lastBarTop","lastBarBottom","lastEventTop","lastEventBottom","e","ev","type","top","nextTop","bottom","nextBottom","height","makeSortedArray","hash","arr","k","hasOwnProperty","sort","a","b","diff","time","getLineAndMeasure","klass","elemset","attrs","split","match","exec","convertToVoices","staffGroups","voices","line","group","firstStaff","staffs","middleC","absoluteY","STEP","lastStaff","v","elements","elem","hint","duration","left","x","width","w","durationClass","isTiedToNext","startTie","obj","barType","abcelem","startEnding","spreadVoices","voice","startRepeatIndex","endRepeatIndex","endRepeat","startRepeat","clone","combineVoices","voiceList","eventHash","isTiedState","item","Math","min","setupEvents","engraver","staffgroups","isEndOfLine","currentNote","shouldScroll","scrollPos","clientHeight","isVisible","lastTop","processShowCursor","shift","hideCurrentMeasure","next","hideFinishedMeasures","currentTime","Date","getTime","nextTimeInBeats","nextTimeInMilliseconds","pauseAnimation","pause","warn","nowTime","elapsedTimeWhenPaused","clearTimeout","remove","overflowY","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,sBAAD,CAArB;;AACA,IAAIC,WAAW,GAAGD,OAAO,CAAC,qBAAD,CAAzB;;AAEA,IAAIE,SAAS,GAAG,EAAhB;;AAEA,CAAC,YAAW;AACX;;AAEA,WAASC,QAAT,CAAkBC,OAAlB,EAA2BC,GAA3B,EAAgC;AAC/B,QAAIC,OAAO,GAAGF,OAAO,CAACG,YAAR,CAAqB,OAArB,CAAd;AACA,QAAIC,MAAM,GAAG,aAAb;AACA,QAAIC,SAAS,GAAG,MAAMJ,GAAN,GAAY,GAA5B;AACA,WAAQD,OAAO,CAACM,QAAR,KAAqB,CAArB,IAA0B,CAAC,MAAMJ,OAAN,GAAgB,GAAjB,EAAsBK,OAAtB,CAA8BH,MAA9B,EAAsC,GAAtC,EAA2CI,OAA3C,CAAmDH,SAAnD,KAAiE,CAAnG;AACA;;AAED,WAASI,uBAAT,CAAiCC,UAAjC,EAA6CC,MAA7C,EAAqDC,MAArD,EAA6D;AAC5D,QAAIC,GAAG,GAAGH,UAAU,CAACI,sBAAX,CAAkCH,MAAlC,CAAV;AACA,QAAII,GAAG,GAAG,EAAV;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAACI,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACpC,UAAIjB,QAAQ,CAACc,GAAG,CAACG,CAAD,CAAJ,EAASJ,MAAT,CAAZ,EACCG,GAAG,CAACG,IAAJ,CAASL,GAAG,CAACG,CAAD,CAAZ;AACD;;AACD,WAAOD,GAAP;AACA,GAlBU,CAoBX;AACA;AACA;;;AACA,WAASI,UAAT,CAAoBC,QAApB,EAA8B;AAC7B,QAAIC,IAAJ;;AACA,SAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,QAAQ,CAACC,WAAT,CAAqBN,MAAzB,IAAmCI,IAAI,KAAKG,SAA5D,EAAuER,CAAC,EAAxE,EAA4E;AAC3E,UAAIS,GAAG,GAAGH,QAAQ,CAACC,WAAT,CAAqBP,CAArB,CAAV;AACA,UAAIU,KAAK,GAAGD,GAAG,CAACC,KAAhB;;AACA,UAAIA,KAAJ,EAAW;AACV,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACT,MAAV,IAAoBI,IAAI,KAAKG,SAA7C,EAAwDG,CAAC,EAAzD,EAA6D;AAC5D,cAAID,KAAK,CAACC,CAAD,CAAL,CAASC,YAAT,IAAyBF,KAAK,CAACC,CAAD,CAAL,CAASC,YAAT,KAA0BR,QAAvD,EACCC,IAAI,GAAGK,KAAK,CAACC,CAAD,CAAZ;AACD;AACD;AACD;;AACD,QAAI,CAACN,IAAL,EAAW;AACVC,MAAAA,QAAQ,CAACC,WAAT,CAAqB,CAArB,EAAwBM,UAAxB,CAAmCT,QAAQ,GAAG,MAA9C,EAAsD,CAAtD;AACA,aAAOD,UAAU,CAACC,QAAD,CAAjB;AACA;;AACD,WAAOC,IAAP;AACA;;AAED,WAASS,iBAAT,CAA2BC,IAA3B,EAAiCC,OAAjC,EAA0C;AACzC;AACA;AACA;AACA,QAAIC,GAAJ;AACA,QAAID,OAAO,CAACC,GAAZ,EACCA,GAAG,GAAGD,OAAO,CAACC,GAAd,CADD,KAEK;AACJ,UAAIF,IAAI,IAAIA,IAAI,CAACG,QAAb,IAAyBH,IAAI,CAACG,QAAL,CAAcC,KAAvC,IAAgDJ,IAAI,CAACG,QAAL,CAAcC,KAAd,CAAoBF,GAAxE,EACCA,GAAG,GAAGF,IAAI,CAACG,QAAL,CAAcC,KAAd,CAAoBF,GAA1B,CADD,KAGCA,GAAG,GAAG,GAAN,CAJG,CAIQ;AACZ;AACD,WAAOA,GAAP;AACA;;AAED,MAAIG,WAAJ;AACA,MAAIC,YAAJ;AACA,MAAIC,OAAJ;AACA,MAAIC,aAAJ;AACA,MAAIC,eAAJ;AACA,MAAIC,mBAAJ,CA/DW,CAiEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIC,YAAY,GAAG,KAAnB;AACA,MAAIC,MAAJ;AAEA,MAAIC,SAAJ;AACA,MAAIC,QAAJ;AACA,MAAIC,UAAJ;AACA,MAAIC,gBAAJ;AACA,MAAIC,WAAJ;;AAEA,WAASC,SAAT,CAAmBC,MAAnB,EAA2B;AAC1BZ,IAAAA,OAAO,CAACa,KAAR,CAAcC,SAAd,GAA0B,CAACF,MAAD,GAAU,IAApC;AACAX,IAAAA,aAAa,GAAGW,MAAhB;AACA;;AACDpD,EAAAA,SAAS,CAACuD,cAAV,GAA2B,UAASC,KAAT,EAAgBvB,IAAhB,EAAsBC,OAAtB,EAA+B;AACzD,QAAIsB,KAAK,CAACxC,sBAAN,KAAiCU,SAArC,EAAgD;AAC/C+B,MAAAA,OAAO,CAACC,KAAR,CAAc,mHAAd;AACA;AACA;;AACD,QAAIzB,IAAI,CAAC0B,aAAL,KAAuBjC,SAA3B,EAAsC;AACrC+B,MAAAA,OAAO,CAACC,KAAR,CAAc,6GAAd;AACA;AACA;;AACD,QAAIxB,OAAO,CAAC0B,gBAAR,IAA4B1B,OAAO,CAAC2B,cAApC,IAAsD3B,OAAO,CAAC4B,UAAlE,EAA8E;AAC7E;AACA;AACA,UAAI,CAAC7D,QAAQ,CAACuD,KAAD,EAAQ,aAAR,CAAb,EAAqC;AACpC;AACAA,QAAAA,KAAK,CAACO,SAAN,GAAkB,CAAlB,CAFoC,CAEf;;AACrBP,QAAAA,KAAK,CAACH,KAAN,CAAYW,QAAZ,GAAuB,QAAvB;AACAR,QAAAA,KAAK,GAAGA,KAAK,CAACS,QAAN,CAAe,CAAf,CAAR;AACA;;AACD,UAAI,CAAChE,QAAQ,CAACuD,KAAD,EAAQ,aAAR,CAAb,EAAqC;AACpCC,QAAAA,OAAO,CAACC,KAAR,CAAc,2JAAd;AACA;AACA;AACD,KAtBwD,CAuBzD;;;AACA1D,IAAAA,SAAS,CAACkE,aAAV;AACAxB,IAAAA,eAAe,GAAGc,KAAlB;AACAb,IAAAA,mBAAmB,GAAGT,OAAO,CAAC2B,cAAR,IAA0B3B,OAAO,CAAC4B,UAAxD;;AAEA,QAAI5B,OAAO,CAACiC,UAAZ,EAAwB;AACvBtB,MAAAA,MAAM,GAAGrB,QAAQ,CAAC4C,aAAT,CAAuB,KAAvB,CAAT;AACAvB,MAAAA,MAAM,CAACtC,SAAP,GAAmB,qBAAnB;AACAsC,MAAAA,MAAM,CAACQ,KAAP,CAAagB,QAAb,GAAwB,UAAxB;AAEAb,MAAAA,KAAK,CAACc,WAAN,CAAkBzB,MAAlB;AACAW,MAAAA,KAAK,CAACH,KAAN,CAAYgB,QAAZ,GAAuB,UAAvB;AACA;;AAEDzB,IAAAA,YAAY,GAAG,KAAf;AACA,QAAI2B,cAAc,GAAGvC,iBAAiB,CAACC,IAAD,EAAOC,OAAP,CAAtC;AACA,QAAIsC,mBAAmB,GAAGD,cAAc,GAAG,KAA3C;AACA,QAAIE,UAAU,GAAGxC,IAAI,CAAC0B,aAAL,EAAjB,CAxCyD,CAwClB;;AACvC,QAAIe,UAAU,GAAG,CAAjB;AAEA,QAAIC,0BAAJ;;AACA,QAAIzC,OAAO,CAAC2B,cAAZ,EAA4B;AAC3B,UAAIe,mBAAmB,GAAG,IAAEJ,mBAA5B;AACA,UAAIK,eAAe,GAAG,IAAEJ,UAAxB;AACA,UAAIK,sBAAsB,GAAGF,mBAAmB,GAAGC,eAAnD;AACAF,MAAAA,0BAA0B,GAAGG,sBAAsB,GAAG,CAAtD;AACAtC,MAAAA,OAAO,GAAGnB,UAAU,CAAC,cAAD,CAApB;AACA;;AAED0B,IAAAA,QAAQ,GAAG,KAAX;AACA,QAAIgC,WAAW,GAAG,IAAlB;AACA,QAAIC,QAAQ,GAAG,EAAf;AACA,QAAIC,QAAQ,GAAG,CAAf;AACA,QAAIC,KAAK,GAAG1B,KAAK,CAAC2B,UAAlB;;AACA,aAASC,SAAT,GAAqB;AACpB,UAAIC,eAAe,GAAG7B,KAAK,CAACH,KAAN,CAAYiC,UAAlC;AACA,UAAID,eAAe,KAAK,EAAxB,EACCA,eAAe,GAAG,CAAlB,CADD,KAGCA,eAAe,GAAGE,QAAQ,CAACF,eAAD,CAA1B;AACDA,MAAAA,eAAe,IAAIJ,QAAnB;AACAzB,MAAAA,KAAK,CAACH,KAAN,CAAYiC,UAAZ,GAAyBD,eAAe,GAAG,IAA3C;AACA,UAAIA,eAAe,GAAGH,KAAK,CAACM,WAAN,GAAqBhC,KAAK,CAACiC,WAAjD,EACCnD,WAAW,GAAGoD,UAAU,CAACN,SAAD,EAAYJ,QAAZ,CAAxB;AACD;;AAED,QAAI9C,OAAO,CAAC0B,gBAAZ,EAA8B;AAC7BJ,MAAAA,KAAK,CAACH,KAAN,CAAYiC,UAAZ,GAAyB,KAAzB;AACAhD,MAAAA,WAAW,GAAGoD,UAAU,CAACN,SAAD,EAAYL,WAAZ,CAAxB;AACA;;AAED,aAASY,WAAT,CAAqBC,OAArB,EAA8BC,UAA9B,EAA0C;AACzCD,MAAAA,OAAO,GAAGL,QAAQ,CAACK,OAAD,EAAU,EAAV,CAAlB;AACAC,MAAAA,UAAU,GAAGN,QAAQ,CAACM,UAAD,EAAa,EAAb,CAArB;AACAA,MAAAA,UAAU;AACV,UAAI9E,GAAG,GAAGJ,uBAAuB,CAAC6C,KAAD,EAAQ,MAAIoC,OAAZ,EAAqB,MAAIC,UAAzB,CAAjC;AACA,UAAI9E,GAAG,CAACI,MAAJ,GAAa,CAAjB,EACC,OAAO,CAACyE,OAAD,EAAUC,UAAV,CAAP;AACDD,MAAAA,OAAO;AACPC,MAAAA,UAAU,GAAG,CAAb;AACA9E,MAAAA,GAAG,GAAGJ,uBAAuB,CAAC6C,KAAD,EAAQ,MAAIoC,OAAZ,EAAqB,MAAIC,UAAzB,CAA7B;AACA,UAAI9E,GAAG,CAACI,MAAJ,GAAa,CAAjB,EACC,OAAO,CAACyE,OAAD,EAAUC,UAAV,CAAP;AACD,aAAO,IAAP;AACA;;AAED,aAASC,mBAAT,CAA6BF,OAA7B,EAAsCC,UAAtC,EAAkD;AACjD,UAAI9E,GAAG,GAAGJ,uBAAuB,CAAC6C,KAAD,EAAQ,MAAIoC,OAAZ,EAAqB,MAAIC,UAAzB,CAAjC;;AAEA,UAAI9E,GAAG,CAACI,MAAJ,GAAa,CAAjB,EAAoB;AACnB,aAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAACI,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACpC,cAAI6E,EAAE,GAAGhF,GAAG,CAACG,CAAD,CAAZ;AACA,cAAI,CAACjB,QAAQ,CAAC8F,EAAD,EAAK,KAAL,CAAb,EACCA,EAAE,CAAC1C,KAAH,CAAS2C,OAAT,GAAmB,MAAnB;AACD;AACD;AACD;;AAED,aAASC,eAAT,CAAyBC,YAAzB,EAAuC;AACtC;AACA,UAAIC,UAAJ;AACA,UAAIC,aAAJ;AACA,UAAIC,YAAJ;AACA,UAAIC,eAAJ;;AACA,WAAK,IAAIC,CAAC,GAAGL,YAAY,CAAC/E,MAAb,GAAoB,CAAjC,EAAoCoF,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD;AAChD,YAAIC,EAAE,GAAGN,YAAY,CAACK,CAAD,CAArB;;AACA,YAAIC,EAAE,CAACC,IAAH,KAAY,KAAhB,EAAuB;AACtBD,UAAAA,EAAE,CAACE,GAAH,GAASL,YAAT;AACAG,UAAAA,EAAE,CAACG,OAAH,GAAaR,UAAb;AACAA,UAAAA,UAAU,GAAGE,YAAb;AAEAG,UAAAA,EAAE,CAACI,MAAH,GAAYN,eAAZ;AACAE,UAAAA,EAAE,CAACK,UAAH,GAAgBT,aAAhB;AACAA,UAAAA,aAAa,GAAGE,eAAhB;AACA,SARD,MAQO,IAAIE,EAAE,CAACC,IAAH,KAAY,OAAhB,EAAyB;AAC/BJ,UAAAA,YAAY,GAAGG,EAAE,CAACE,GAAlB;AACAJ,UAAAA,eAAe,GAAGE,EAAE,CAACE,GAAH,GAAQF,EAAE,CAACM,MAA7B;AACA;AACD;AACD;;AAED,aAASC,eAAT,CAAyBC,IAAzB,EAA+B;AAC9B,UAAIC,GAAG,GAAG,EAAV;;AACA,WAAK,IAAIC,CAAT,IAAcF,IAAd,EAAoB;AACnB,YAAIA,IAAI,CAACG,cAAL,CAAoBD,CAApB,CAAJ,EACCD,GAAG,CAAC7F,IAAJ,CAAS4F,IAAI,CAACE,CAAD,CAAb;AACD;;AACDD,MAAAA,GAAG,GAAGA,GAAG,CAACG,IAAJ,CAAS,UAASC,CAAT,EAAWC,CAAX,EAAc;AAC5B,YAAIC,IAAI,GAAGF,CAAC,CAACG,IAAF,GAASF,CAAC,CAACE,IAAtB,CAD4B,CAE5B;;AACA,YAAID,IAAI,KAAK,CAAb,EAAgB;AACf,iBAAOA,IAAP;AACA,SAFD,MAGK;AACJ,iBAAOF,CAAC,CAACZ,IAAF,KAAW,KAAX,GAAmB,CAAC,CAApB,GAAwB,CAA/B;AACA;AACD,OATK,CAAN;AAUA,aAAOQ,GAAP;AACA,KA7IwD,CA+IzD;;;AACA,aAASQ,iBAAT,CAA2BvH,OAA3B,EAAoC;AACnC,UAAIwH,KAAK,GAAGxH,OAAO,CAACyH,OAAR,CAAgB,CAAhB,EAAmBC,KAAnB,CAAyB,OAAzB,CAAZ;AACA,UAAIX,GAAG,GAAGS,KAAK,CAACG,KAAN,CAAY,GAAZ,CAAV;AACA,UAAIjC,OAAJ;AACA,UAAIC,UAAJ;;AACA,WAAK,IAAI3E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+F,GAAG,CAAC9F,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACpC,YAAI4G,KAAK,GAAG,SAASC,IAAT,CAAcd,GAAG,CAAC/F,CAAD,CAAjB,CAAZ;AACA,YAAI4G,KAAJ,EACCjC,UAAU,GAAGiC,KAAK,CAAC,CAAD,CAAlB;AACDA,QAAAA,KAAK,GAAG,SAASC,IAAT,CAAcd,GAAG,CAAC/F,CAAD,CAAjB,CAAR;AACA,YAAI4G,KAAJ,EACClC,OAAO,GAAGkC,KAAK,CAAC,CAAD,CAAf;AACD;;AACD,aAAO;AAAElC,QAAAA,OAAO,EAAEA,OAAX;AAAoBC,QAAAA,UAAU,EAAEA;AAAhC,OAAP;AACA,KA9JwD,CAgKzD;;;AACA,aAASmC,eAAT,CAAyBC,WAAzB,EAAsC;AACrC,UAAIC,MAAM,GAAG,EAAb;;AACA,WAAK,IAAIC,IAAI,GAAC,CAAd,EAAgBA,IAAI,GAACF,WAAW,CAAC9G,MAAjC,EAAyCgH,IAAI,EAA7C,EAAiD;AAChD,YAAIC,KAAK,GAAGH,WAAW,CAACE,IAAD,CAAvB;AACA,YAAIE,UAAU,GAAGD,KAAK,CAACE,MAAN,CAAa,CAAb,CAAjB;AACA,YAAIC,OAAO,GAAGF,UAAU,CAACG,SAAzB;AACA,YAAI9B,GAAG,GAAG6B,OAAO,GAAGF,UAAU,CAAC3B,GAAX,GAAiB7G,OAAO,CAAC4I,IAA7C;AACA,YAAIC,SAAS,GAAGN,KAAK,CAACE,MAAN,CAAaF,KAAK,CAACE,MAAN,CAAanH,MAAb,GAAsB,CAAnC,CAAhB;AACAoH,QAAAA,OAAO,GAAGG,SAAS,CAACF,SAApB;AACA,YAAI5B,MAAM,GAAG2B,OAAO,GAAGG,SAAS,CAAC9B,MAAV,GAAmB/G,OAAO,CAAC4I,IAAlD,CAPgD,CAQhD;;AACA,aAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,KAAK,CAACF,MAAN,CAAa/G,MAAjC,EAAyCwH,CAAC,EAA1C,EAA8C;AAC7C,cAAIA,CAAC,IAAIT,MAAM,CAAC/G,MAAhB,EACC+G,MAAM,CAAC9G,IAAP,CAAY,EAAZ;AACD,cAAIwH,QAAQ,GAAGR,KAAK,CAACF,MAAN,CAAaS,CAAb,EAAgB1E,QAA/B;;AACA,eAAK,IAAI4E,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGD,QAAQ,CAACzH,MAAnC,EAA2C0H,IAAI,EAA/C,EAAmD;AAClD,gBAAI3I,OAAO,GAAG0I,QAAQ,CAACC,IAAD,CAAtB;AACA,gBAAI3I,OAAO,CAAC4I,IAAZ,EACC;;AACD,gBAAI5I,OAAO,CAAC6I,QAAR,GAAmB,CAAvB,EAA0B;AACzBb,cAAAA,MAAM,CAACS,CAAD,CAAN,CAAUvH,IAAV,CAAe;AAAEqF,gBAAAA,IAAI,EAAE,OAAR;AACdC,gBAAAA,GAAG,EAAEA,GADS;AAEdI,gBAAAA,MAAM,EAAEF,MAAM,GAAGF,GAFH;AAGdsC,gBAAAA,IAAI,EAAE9I,OAAO,CAAC+I,CAHA;AAIdC,gBAAAA,KAAK,EAAEhJ,OAAO,CAACiJ,CAJD;AAKdJ,gBAAAA,QAAQ,EAAE7I,OAAO,CAACkJ,aAAR,GAAwBlJ,OAAO,CAACkJ,aAAhC,GAAgDlJ,OAAO,CAAC6I,QALpD;AAMdM,gBAAAA,YAAY,EAAEnJ,OAAO,CAACoJ,QAAR,KAAqB5H;AANrB,eAAf;AAQA,aAbiD,CAclD;;;AACA,gBAAIxB,OAAO,CAACuG,IAAR,KAAiB,KAArB,EAA4B;AAC3B,kBAAIyB,MAAM,CAACS,CAAD,CAAN,CAAUxH,MAAV,KAAqB,CAArB,IAA0B+G,MAAM,CAACS,CAAD,CAAN,CAAUT,MAAM,CAACS,CAAD,CAAN,CAAUxH,MAAV,GAAiB,CAA3B,EAA8BsF,IAA9B,KAAuC,KAArE,EAA4E;AAC3E,oBAAIvG,OAAO,CAACyH,OAAR,IAAmBzH,OAAO,CAACyH,OAAR,CAAgBxG,MAAhB,GAAyB,CAA5C,IAAiDjB,OAAO,CAACyH,OAAR,CAAgB,CAAhB,EAAmBC,KAAxE,EAA+E;AAC9E,sBAAI2B,GAAG,GAAG9B,iBAAiB,CAACvH,OAAD,CAA3B;AACAgI,kBAAAA,MAAM,CAACS,CAAD,CAAN,CAAUvH,IAAV,CAAe;AAAEqF,oBAAAA,IAAI,EAAE,KAAR;AACd+C,oBAAAA,OAAO,EAAEtJ,OAAO,CAACuJ,OAAR,CAAgBhD,IADX;AAEdiD,oBAAAA,WAAW,EAAExJ,OAAO,CAACuJ,OAAR,CAAgBC,WAAhB,KAAgC,GAF/B;AAGd9D,oBAAAA,OAAO,EAAE2D,GAAG,CAAC3D,OAHC;AAIdC,oBAAAA,UAAU,EAAE0D,GAAG,CAAC1D;AAJF,mBAAf;AAMA;AACD;AACD;AACD;AACD;AACD;;AACD,aAAOqC,MAAP;AACA,KAhNwD,CAkNzD;;;AACA,aAASyB,YAAT,CAAsBzB,MAAtB,EAA8B;AAC7B,UAAIjH,GAAG,GAAG,EAAV;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgH,MAAM,CAAC/G,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACvC,YAAI0I,KAAK,GAAG1B,MAAM,CAAChH,CAAD,CAAlB;AACAD,QAAAA,GAAG,CAACG,IAAJ,CAAS,EAAT;AACA,YAAIyI,gBAAgB,GAAG,CAAvB,CAHuC,CAGb;;AAC1B,YAAIC,cAAc,GAAG,CAAC,CAAtB;;AACA,aAAK,IAAIjI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+H,KAAK,CAACzI,MAA1B,EAAkCU,CAAC,EAAnC,EAAuC;AACtC,cAAIgH,IAAI,GAAGe,KAAK,CAAC/H,CAAD,CAAhB;AACAZ,UAAAA,GAAG,CAACC,CAAD,CAAH,CAAOE,IAAP,CAAYwI,KAAK,CAAC/H,CAAD,CAAjB;AACA,cAAIkI,SAAS,GAAIlB,IAAI,CAACW,OAAL,KAAiB,kBAAjB,IAAuCX,IAAI,CAACW,OAAL,KAAiB,gBAAzE;AACA,cAAIE,WAAW,GAAGb,IAAI,CAACa,WAAvB;AACA,cAAIM,WAAW,GAAInB,IAAI,CAACW,OAAL,KAAiB,iBAAjB,IAAsCX,IAAI,CAACW,OAAL,KAAiB,gBAAvD,IAA2EX,IAAI,CAACW,OAAL,KAAiB,gBAA5F,IAAgHX,IAAI,CAACW,OAAL,KAAiB,gBAAjI,IAAqJX,IAAI,CAACW,OAAL,KAAiB,eAAtK,IAAyLX,IAAI,CAACW,OAAL,KAAiB,kBAA7N;;AACA,cAAIO,SAAJ,EAAe;AACd,gBAAID,cAAc,KAAK,CAAC,CAAxB,EACCA,cAAc,GAAGjI,CAAjB;;AACD,iBAAK,IAAIqF,CAAC,GAAG2C,gBAAb,EAA+B3C,CAAC,IAAI4C,cAApC,EAAoD5C,CAAC,EAArD,EAAyD;AACxDjG,cAAAA,GAAG,CAACC,CAAD,CAAH,CAAOE,IAAP,CAAYrB,WAAW,CAACkK,KAAZ,CAAkBL,KAAK,CAAC1C,CAAD,CAAvB,CAAZ;AACA;AACD;;AACD,cAAIwC,WAAJ,EACCI,cAAc,GAAGjI,CAAjB;AACD,cAAImI,WAAJ,EACCH,gBAAgB,GAAGhI,CAAC,GAAC,CAArB;AACD;AACD;;AACD,aAAOZ,GAAP;AACA;;AAED,aAASiJ,aAAT,CAAuBC,SAAvB,EAAkC;AACjC,UAAIC,SAAS,GAAG,EAAhB;;AACA,WAAK,IAAIzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwB,SAAS,CAAChJ,MAA9B,EAAsCwH,CAAC,EAAvC,EAA2C;AAC1C,YAAInB,IAAI,GAAG,CAAX;AACA,YAAI6C,WAAW,GAAG,KAAlB;;AACA,aAAK,IAAInJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiJ,SAAS,CAACxB,CAAD,CAAT,CAAaxH,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;AAC7C,cAAIoJ,IAAI,GAAGH,SAAS,CAACxB,CAAD,CAAT,CAAazH,CAAb,CAAX;AACAoJ,UAAAA,IAAI,CAAC9C,IAAL,GAAYA,IAAZ;;AACA,cAAI8C,IAAI,CAAC7D,IAAL,KAAc,OAAlB,EAA2B;AAC1B,gBAAI4C,YAAY,GAAGiB,IAAI,CAACjB,YAAxB;;AACA,gBAAIgB,WAAJ,EAAiB;AAChB,kBAAI,CAAChB,YAAL,EACCgB,WAAW,GAAG,KAAd,CAFe,CAGhB;AACA,aAJD,MAIO;AACN;AACA,kBAAI,CAACD,SAAS,CAAC,UAAQ5C,IAAT,CAAd,EACC4C,SAAS,CAAC,UAAQ5C,IAAT,CAAT,GAA0B8C,IAA1B,CADD,KAEK;AACJ;AACAF,gBAAAA,SAAS,CAAC,UAAQ5C,IAAT,CAAT,CAAwBwB,IAAxB,GAA+BuB,IAAI,CAACC,GAAL,CAASJ,SAAS,CAAC,UAAQ5C,IAAT,CAAT,CAAwBwB,IAAjC,EAAuCsB,IAAI,CAACtB,IAA5C,CAA/B;AACA;AACD,kBAAIK,YAAJ,EACCgB,WAAW,GAAG,IAAd;AACD;;AACD7C,YAAAA,IAAI,IAAI8C,IAAI,CAACvB,QAAb;AACA,WAlBD,MAkBO;AACNqB,YAAAA,SAAS,CAAC,QAAM5C,IAAP,CAAT,GAAwB8C,IAAxB;AACA;AACD;AACD;;AACD,aAAOF,SAAP;AACA;;AAED,QAAIlE,YAAY,GAAG,EAAnB;;AACA,aAASuE,WAAT,CAAqBC,QAArB,EAA+B;AAC9B;AACA;AACA;AACA,UAAIP,SAAS,GAAGnC,eAAe,CAAC0C,QAAQ,CAACC,WAAV,CAA/B;AACAR,MAAAA,SAAS,GAAGR,YAAY,CAACQ,SAAD,CAAxB;AAEA,UAAIC,SAAS,GAAGF,aAAa,CAACC,SAAD,CAA7B,CAP8B,CAS9B;;AACAjE,MAAAA,YAAY,GAAGa,eAAe,CAACqD,SAAD,CAA9B;AACA1F,MAAAA,UAAU,GAAGwB,YAAY,CAACA,YAAY,CAAC/E,MAAb,GAAoB,CAArB,CAAZ,CAAoCqG,IAApC,GAA2C/C,UAAxD;;AACA,UAAIvC,OAAO,CAAC2B,cAAZ,EAA4B;AAC3BoC,QAAAA,eAAe,CAACC,YAAD,CAAf;AACA;AACD;;AACDuE,IAAAA,WAAW,CAACxI,IAAI,CAACyI,QAAN,CAAX;;AAEA,aAASE,WAAT,CAAqBC,WAArB,EAAkC;AACjC,aAAOA,WAAW,CAACnE,GAAZ,KAAoBmE,WAAW,CAAClE,OAAhC,IAA2CkE,WAAW,CAAClE,OAAZ,KAAwBjF,SAA1E;AACA;;AAED,aAASoJ,YAAT,CAAsB5F,KAAtB,EAA6B6F,SAA7B,EAAwCF,WAAxC,EAAqD;AACpD,UAAI/D,MAAM,GAAGvB,QAAQ,CAACL,KAAK,CAAC8F,YAAP,EAAqB,EAArB,CAArB;AACA,UAAIC,SAAS,GAAGJ,WAAW,CAAChE,UAAZ,GAAyBkE,SAAzB,GAAqCjE,MAArD,CAFoD,CAGpD;;AACA,aAAO,CAACmE,SAAR;AACA;;AAED,QAAIC,OAAO,GAAG,CAAC,CAAf,CAhTyD,CAiTzD;;AACAzI,IAAAA,aAAa,GAAG,CAAhB;;AAEA,QAAIP,OAAO,CAAC2B,cAAZ,EAA4B;AAC3BV,MAAAA,SAAS,CAAC,CAAD,CAAT,CAD2B,CACb;AACd;;AAED,aAASgI,iBAAT,GAA6B;AAC5B,UAAIN,WAAW,GAAG3E,YAAY,CAACkF,KAAb,EAAlB;;AACA,UAAI,CAACP,WAAL,EAAkB;AACjBjI,QAAAA,YAAY,GAAG,IAAf;AACA,eAAO,CAAP;AACA;;AACD,UAAIiI,WAAW,CAACpE,IAAZ,KAAqB,KAAzB,EAAgC;AAC/B,YAAIvE,OAAO,CAAC2B,cAAZ,EAA4B;AAC3B,cAAI+G,WAAW,CAACC,WAAD,CAAX,IAA4BC,YAAY,CAAC5F,KAAD,EAAQzC,aAAR,EAAuBoI,WAAvB,CAA5C,EAAiF;AAChFnF,YAAAA,UAAU,CAAC,YAAW;AACrBvC,cAAAA,SAAS,CAAC0H,WAAW,CAAClE,OAAb,CAAT;AACA,aAFS,EAEPhC,0BAFO,CAAV;AAGA;AACD;;AACD,YAAIzC,OAAO,CAACmJ,kBAAZ,EAAgC;AAC/B,cAAIC,IAAI,GAAG3F,WAAW,CAACkF,WAAW,CAACjF,OAAb,EAAsBiF,WAAW,CAAChF,UAAlC,CAAtB;AACA,cAAIyF,IAAJ,EACCxF,mBAAmB,CAACwF,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAAnB;AACD,SAJD,MAIO,IAAIpJ,OAAO,CAACqJ,oBAAZ,EACNzF,mBAAmB,CAAC+E,WAAW,CAACjF,OAAb,EAAsBiF,WAAW,CAAChF,UAAlC,CAAnB;;AACD,YAAIK,YAAY,CAAC/E,MAAb,GAAsB,CAA1B,EACC,OAAO+E,YAAY,CAAC,CAAD,CAAZ,CAAgBsB,IAAhB,GAAuB/C,UAA9B;AACD,eAAO,CAAP;AACA;;AACD,UAAIvC,OAAO,CAAC4B,UAAR,IAAsBoH,OAAO,KAAKL,WAAW,CAACnE,GAAlD,EAAuD;AACtDwE,QAAAA,OAAO,GAAGL,WAAW,CAACnE,GAAtB;AACAvD,QAAAA,SAAS,CAAC+H,OAAD,CAAT;AACA;;AACD,UAAIhJ,OAAO,CAACiC,UAAR,IAAsBtB,MAAtB,IAAgCA,MAAM,CAACQ,KAA3C,EAAkD;AACjDR,QAAAA,MAAM,CAACQ,KAAP,CAAa2F,IAAb,GAAoB6B,WAAW,CAAC7B,IAAZ,GAAmB,IAAvC;AACAnG,QAAAA,MAAM,CAACQ,KAAP,CAAaqD,GAAb,GAAmBmE,WAAW,CAACnE,GAAZ,GAAkB,IAArC;AACA7D,QAAAA,MAAM,CAACQ,KAAP,CAAa6F,KAAb,GAAqB2B,WAAW,CAAC3B,KAAZ,GAAoB,IAAzC;AACArG,QAAAA,MAAM,CAACQ,KAAP,CAAayD,MAAb,GAAsB+D,WAAW,CAAC/D,MAAZ,GAAqB,IAA3C;AACA;;AACD,UAAIZ,YAAY,CAAC/E,MAAb,GAAsB,CAA1B,EACC,OAAO+E,YAAY,CAAC,CAAD,CAAZ,CAAgBsB,IAAhB,GAAuB/C,UAA9B;AACD7B,MAAAA,YAAY,GAAG,IAAf;AACA,aAAO,CAAP;AACA;;AAEDM,IAAAA,WAAW,GAAG,YAAW;AACxB,UAAIN,YAAJ,EAAkB;AACjB5C,QAAAA,SAAS,CAACkE,aAAV;AACA;AACA;;AACD,UAAIsH,WAAW,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAlB;;AACA,UAAI3I,QAAJ,EAAc;AACb;AACA;AACAE,QAAAA,gBAAgB,GAAGuI,WAAW,GAAGxI,UAAjC;AACA;AACA;;AACD,UAAI2I,eAAe,GAAGR,iBAAiB,EAAvC;AACA,UAAIS,sBAAsB,GAAGD,eAAe,GAAGnH,mBAA/C;AACA,UAAIQ,QAAQ,GAAGlC,SAAS,GAAG8I,sBAAZ,GAAqCJ,WAApD;AACA,UAAIxG,QAAQ,IAAI,CAAhB,EACC9B,WAAW,GADZ,KAGCX,YAAY,GAAGmD,UAAU,CAACxC,WAAD,EAAc8B,QAAd,CAAzB;AACD,KAnBD;;AAoBAlC,IAAAA,SAAS,GAAG,IAAI2I,IAAJ,EAAZ;AACA3I,IAAAA,SAAS,GAAGA,SAAS,CAAC4I,OAAV,EAAZ;AACA3I,IAAAA,QAAQ,GAAG,KAAX;;AACA,QAAIb,OAAO,CAACmJ,kBAAZ,EAAgC;AAC/B,UAAIC,IAAI,GAAG3F,WAAW,CAAC,CAAD,EAAI,CAAC,CAAL,CAAtB;AACA,UAAI2F,IAAJ,EACCxF,mBAAmB,CAACwF,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAAnB;AACD;;AACDpI,IAAAA,WAAW;AAEX,GA9XD;;AAgYAlD,EAAAA,SAAS,CAAC6L,cAAV,GAA2B,UAASC,KAAT,EAAgB;AAC1C,QAAI,CAAC5I,WAAL,EAAkB;AACjBO,MAAAA,OAAO,CAACsI,IAAR,CAAa,0DAAb;AACA;AACA;;AAED,QAAID,KAAK,IAAI,CAAC/I,QAAd,EAAwB;AACvBA,MAAAA,QAAQ,GAAG,IAAX;AACAC,MAAAA,UAAU,GAAG,IAAIyI,IAAJ,GAAWC,OAAX,EAAb;AACA,KAHD,MAGO,IAAI,CAACI,KAAD,IAAU/I,QAAd,EAAwB;AAC9B,UAAIiJ,OAAO,GAAG,IAAIP,IAAJ,GAAWC,OAAX,EAAd;AACA,UAAIO,qBAAqB,GAAGD,OAAO,GAAGhJ,UAAtC;AACAF,MAAAA,SAAS,IAAImJ,qBAAb;AACAjJ,MAAAA,UAAU,GAAGtB,SAAb;AACAqB,MAAAA,QAAQ,GAAG,KAAX;AACAR,MAAAA,YAAY,GAAGmD,UAAU,CAACxC,WAAD,EAAcD,gBAAd,CAAzB;AACAA,MAAAA,gBAAgB,GAAGvB,SAAnB;AACA;AACD,GAlBD;;AAoBA1B,EAAAA,SAAS,CAACkE,aAAV,GAA0B,YAAW;AACpCgI,IAAAA,YAAY,CAAC3J,YAAD,CAAZ;AACA2J,IAAAA,YAAY,CAAC5J,WAAD,CAAZ;;AACA,QAAIO,MAAJ,EAAY;AACXA,MAAAA,MAAM,CAACsJ,MAAP;AACAtJ,MAAAA,MAAM,GAAG,IAAT;AACA;;AACD,QAAIF,mBAAJ,EAAyB;AACxB,UAAID,eAAe,IAAIA,eAAe,CAACyC,UAAvC,EAAmD;AAClDzC,QAAAA,eAAe,CAACyC,UAAhB,CAA2B9B,KAA3B,CAAiC+I,SAAjC,GAA6C,MAA7C;AACDjJ,MAAAA,SAAS,CAAC,CAAD,CAAT;AACA;AACD,GAZD;AAaA,CAlgBD;;AAogBAkJ,MAAM,CAACC,OAAP,GAAiBtM,SAAjB","sourcesContent":["//    abc_animation.js: handles animating the music in real time.\n//    Copyright (C) 2014-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*global console */\n\nvar spacing = require('../write/abc_spacing');\nvar parseCommon = require('../parse/abc_common');\n\nvar animation = {};\n\n(function() {\n\t\"use strict\";\n\n\tfunction hasClass(element, cls) {\n\t\tvar elClass = element.getAttribute(\"class\");\n\t\tvar rclass = /[\\t\\r\\n\\f]/g;\n\t\tvar className = \" \" + cls + \" \";\n\t\treturn (element.nodeType === 1 && (\" \" + elClass + \" \").replace(rclass, \" \").indexOf(className) >= 0);\n\t}\n\n\tfunction getAllElementsByClasses(startingEl, class1, class2) {\n\t\tvar els = startingEl.getElementsByClassName(class1);\n\t\tvar ret = [];\n\t\tfor (var i = 0; i < els.length; i++) {\n\t\t\tif (hasClass(els[i], class2))\n\t\t\t\tret.push(els[i]);\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// This finds the place in the stylesheets that contain the rule that matches the selector.\n\t// If that selector is not found, then it creates the rule.\n\t// We are doing this so that we can use a transition for animating the scrolling.\n\tfunction getCssRule(selector) {\n\t\tvar rule;\n\t\tfor (var i = 0; i < document.styleSheets.length && rule === undefined; i++) {\n\t\t\tvar css = document.styleSheets[i];\n\t\t\tvar rules = css.rules;\n\t\t\tif (rules) {\n\t\t\t\tfor (var j = 0; j < rules.length && rule === undefined; j++) {\n\t\t\t\t\tif (rules[j].selectorText && rules[j].selectorText === selector)\n\t\t\t\t\t\trule = rules[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!rule) {\n\t\t\tdocument.styleSheets[0].insertRule(selector + \" { }\", 1);\n\t\t\treturn getCssRule(selector);\n\t\t}\n\t\treturn rule;\n\t}\n\n\tfunction getBeatsPerMinute(tune, options) {\n\t\t// We either want to run the timer once per measure or once per beat. If we run it once per beat we need a multiplier for the measures.\n\t\t// So, first we figure out the beats per minute and the beats per measure, then depending on the type of animation, we can\n\t\t// calculate the desired interval (ret.tick) and the number of ticks before we want to run the measure\n\t\tvar bpm;\n\t\tif (options.bpm)\n\t\t\tbpm = options.bpm;\n\t\telse {\n\t\t\tif (tune && tune.metaText && tune.metaText.tempo && tune.metaText.tempo.bpm)\n\t\t\t\tbpm = tune.metaText.tempo.bpm;\n\t\t\telse\n\t\t\t\tbpm = 120; // Just set it to something. The user should have set this.\n\t\t}\n\t\treturn bpm;\n\t}\n\n\tvar scrollTimer;\n\tvar animateTimer;\n\tvar cssRule;\n\tvar currentMargin;\n\tvar animationTarget;\n\tvar shouldResetOverflow;\n\n\t// This is a way to manipulate the written music on a timer. Their are two ways to manipulate the music: turn off each measure as it goes by,\n\t// and put a vertical cursor before the next note to play. The timer works at the speed of the original tempo of the music unless it is overwritten\n\t// in the options parameter.\n\t//\n\t// parameters:\n\t// paper: the output div that the music is in.\n\t// tune: the tune object returned by renderAbc.\n\t// options: a hash containing the following:\n\t//    hideFinishedMeasures: true or false [ false is the default ]\n\t//    hideCurrentMeasure: true or false [ false is the default ]\n\t//    showCursor: true or false [ false is the default ]\n\t//    bpm: number of beats per minute [ the default is whatever is in the Q: field ]\n\t//    scrollHorizontal: true or false [ false is the default ]\n\t//    scrollVertical: true or false [ false is the default ]\n\t//    scrollHint: true or false [ false is the default ]\n\t//\n\t// If scrollHorizontal is present, then we expect that the music was rendered with the viewportHorizontal parameter so there is a viewport wrapping the music div. (Note that this only works when there is a single line of music and there are no repeats, signo, or codas.)\n\t// If scrollVertical or scrollHint is present, then we expect that the music was rendered with the viewportVertical parameter so there is a viewport wrapping the music div.\n\t// If the music is larger than the viewport, then it scrolls as the music is being played.\n\tvar stopNextTime = false;\n\tvar cursor;\n\n\tvar startTime;\n\tvar isPaused;\n\tvar pausedTime;\n\tvar pausedDifference;\n\tvar processNext;\n\n\tfunction setMargin(margin) {\n\t\tcssRule.style.marginTop = -margin + \"px\";\n\t\tcurrentMargin = margin;\n\t}\n\tanimation.startAnimation = function(paper, tune, options) {\n\t\tif (paper.getElementsByClassName === undefined) {\n\t\t\tconsole.error(\"ABCJS.startAnimation: The first parameter must be a regular DOM element. (Did you pass a jQuery object or an ID?)\");\n\t\t\treturn;\n\t\t}\n\t\tif (tune.getBeatLength === undefined) {\n\t\t\tconsole.error(\"ABCJS.startAnimation: The second parameter must be a single tune. (Did you pass the entire array of tunes?)\");\n\t\t\treturn;\n\t\t}\n\t\tif (options.scrollHorizontal || options.scrollVertical || options.scrollHint) {\n\t\t\t// We assume that there is an extra div in this case, so adjust the paper if needed.\n\t\t\t// This can be called either with the outer div or the inner div.\n\t\t\tif (!hasClass(paper, 'abcjs-inner')) {\n\t\t\t\t// Must be the outer div; hide the scrollbar and move in.\n\t\t\t\tpaper.scrollTop = 0; // In case the user has repositioned the scrollbar.\n\t\t\t\tpaper.style.overflow = \"hidden\";\n\t\t\t\tpaper = paper.children[0];\n\t\t\t}\n\t\t\tif (!hasClass(paper, 'abcjs-inner')) {\n\t\t\t\tconsole.error(\"ABCJS.startAnimation: When using scrollHorizontal/scrollVertical/scrollHint, the music must have been rendered using viewportHorizontal/viewportVertical.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Can only have one animation at a time, so make sure that it has been stopped.\n\t\tanimation.stopAnimation();\n\t\tanimationTarget = paper;\n\t\tshouldResetOverflow = options.scrollVertical || options.scrollHint;\n\n\t\tif (options.showCursor) {\n\t\t\tcursor = document.createElement('DIV');\n\t\t\tcursor.className = 'abcjs-cursor cursor';\n\t\t\tcursor.style.position = 'absolute';\n\n\t\t\tpaper.appendChild(cursor);\n\t\t\tpaper.style.position = 'relative';\n\t\t}\n\n\t\tstopNextTime = false;\n\t\tvar beatsPerMinute = getBeatsPerMinute(tune, options);\n\t\tvar beatsPerMillisecond = beatsPerMinute / 60000;\n\t\tvar beatLength = tune.getBeatLength(); // This is the same units as the duration is stored in.\n\t\tvar totalBeats = 0;\n\n\t\tvar millisecondsPerHalfMeasure;\n\t\tif (options.scrollVertical) {\n\t\t\tvar millisecondsPerBeat = 1/beatsPerMillisecond;\n\t\t\tvar beatsPerMeasure = 1/beatLength;\n\t\t\tvar millisecondsPerMeasure = millisecondsPerBeat * beatsPerMeasure;\n\t\t\tmillisecondsPerHalfMeasure = millisecondsPerMeasure / 2;\n\t\t\tcssRule = getCssRule(\".abcjs-inner\");\n\t\t}\n\n\t\tisPaused = false;\n\t\tvar initialWait = 2700;\n\t\tvar interval = 11;\n\t\tvar distance = 1;\n\t\tvar outer = paper.parentNode;\n\t\tfunction scrolling() {\n\t\t\tvar currentPosition = paper.style.marginLeft;\n\t\t\tif (currentPosition === \"\")\n\t\t\t\tcurrentPosition = 0;\n\t\t\telse\n\t\t\t\tcurrentPosition = parseInt(currentPosition);\n\t\t\tcurrentPosition -= distance;\n\t\t\tpaper.style.marginLeft = currentPosition + \"px\";\n\t\t\tif (currentPosition > outer.offsetWidth -  paper.scrollWidth)\n\t\t\t\tscrollTimer = setTimeout(scrolling, interval);\n\t\t}\n\n\t\tif (options.scrollHorizontal) {\n\t\t\tpaper.style.marginLeft = \"0px\";\n\t\t\tscrollTimer = setTimeout(scrolling, initialWait);\n\t\t}\n\n\t\tfunction nextMeasure(lineNum, measureNum) {\n\t\t\tlineNum = parseInt(lineNum, 10);\n\t\t\tmeasureNum = parseInt(measureNum, 10);\n\t\t\tmeasureNum++;\n\t\t\tvar els = getAllElementsByClasses(paper, \"l\"+lineNum, \"m\"+measureNum);\n\t\t\tif (els.length > 0)\n\t\t\t\treturn [lineNum, measureNum];\n\t\t\tlineNum++;\n\t\t\tmeasureNum = 0;\n\t\t\tels = getAllElementsByClasses(paper, \"l\"+lineNum, \"m\"+measureNum);\n\t\t\tif (els.length > 0)\n\t\t\t\treturn [lineNum, measureNum];\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction processMeasureHider(lineNum, measureNum) {\n\t\t\tvar els = getAllElementsByClasses(paper, \"l\"+lineNum, \"m\"+measureNum);\n\n\t\t\tif (els.length > 0) {\n\t\t\t\tfor (var i = 0; i < els.length; i++) {\n\t\t\t\t\tvar el = els[i];\n\t\t\t\t\tif (!hasClass(el, \"bar\"))\n\t\t\t\t\t\tel.style.display = \"none\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction addVerticalInfo(timingEvents) {\n\t\t\t// Add vertical info to the bar events: put the next event's top, and the event after the next measure's top.\n\t\t\tvar lastBarTop;\n\t\t\tvar lastBarBottom;\n\t\t\tvar lastEventTop;\n\t\t\tvar lastEventBottom;\n\t\t\tfor (var e = timingEvents.length-1; e >= 0; e--) {\n\t\t\t\tvar ev = timingEvents[e];\n\t\t\t\tif (ev.type === 'bar') {\n\t\t\t\t\tev.top = lastEventTop;\n\t\t\t\t\tev.nextTop = lastBarTop;\n\t\t\t\t\tlastBarTop = lastEventTop;\n\n\t\t\t\t\tev.bottom = lastEventBottom;\n\t\t\t\t\tev.nextBottom = lastBarBottom;\n\t\t\t\t\tlastBarBottom = lastEventBottom;\n\t\t\t\t} else if (ev.type === 'event') {\n\t\t\t\t\tlastEventTop = ev.top;\n\t\t\t\t\tlastEventBottom = ev.top +ev.height;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction makeSortedArray(hash) {\n\t\t\tvar arr = [];\n\t\t\tfor (var k in hash) {\n\t\t\t\tif (hash.hasOwnProperty(k))\n\t\t\t\t\tarr.push(hash[k]);\n\t\t\t}\n\t\t\tarr = arr.sort(function(a,b) {\n\t\t\t\tvar diff = a.time - b.time;\n\t\t\t\t// if the events have the same time, make sure a bar comes before a note\n\t\t\t\tif (diff !== 0) {\n\t\t\t\t\treturn diff;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn a.type === \"bar\" ? -1 : 1;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn arr;\n\t\t}\n\n\t\t// Gets the line and measure number from the element's classes\n\t\tfunction getLineAndMeasure(element) {\n\t\t\tvar klass = element.elemset[0].attrs['class'];\n\t\t\tvar arr = klass.split(' ');\n\t\t\tvar lineNum;\n\t\t\tvar measureNum;\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tvar match = /m(\\d+)/.exec(arr[i]);\n\t\t\t\tif (match)\n\t\t\t\t\tmeasureNum = match[1];\n\t\t\t\tmatch = /l(\\d+)/.exec(arr[i]);\n\t\t\t\tif (match)\n\t\t\t\t\tlineNum = match[1];\n\t\t\t}\n\t\t\treturn { lineNum: lineNum, measureNum: measureNum };\n\t\t}\n\n\t\t// Switches the music from line-based to voice-based.\n\t\tfunction convertToVoices(staffGroups) {\n\t\t\tvar voices = [];\n\t\t\tfor (var line=0;line<staffGroups.length; line++) {\n\t\t\t\tvar group = staffGroups[line];\n\t\t\t\tvar firstStaff = group.staffs[0];\n\t\t\t\tvar middleC = firstStaff.absoluteY;\n\t\t\t\tvar top = middleC - firstStaff.top * spacing.STEP;\n\t\t\t\tvar lastStaff = group.staffs[group.staffs.length - 1];\n\t\t\t\tmiddleC = lastStaff.absoluteY;\n\t\t\t\tvar bottom = middleC - lastStaff.bottom * spacing.STEP;\n\t\t\t\t// Put in the notes for all voices, then sort them, then remove duplicates\n\t\t\t\tfor (var v = 0; v < group.voices.length; v++) {\n\t\t\t\t\tif (v >= voices.length)\n\t\t\t\t\t\tvoices.push([]);\n\t\t\t\t\tvar elements = group.voices[v].children;\n\t\t\t\t\tfor (var elem = 0; elem < elements.length; elem++) {\n\t\t\t\t\t\tvar element = elements[elem];\n\t\t\t\t\t\tif (element.hint)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (element.duration > 0) {\n\t\t\t\t\t\t\tvoices[v].push({ type: \"event\",\n\t\t\t\t\t\t\t\ttop: top,\n\t\t\t\t\t\t\t\theight: bottom - top,\n\t\t\t\t\t\t\t\tleft: element.x,\n\t\t\t\t\t\t\t\twidth: element.w,\n\t\t\t\t\t\t\t\tduration: element.durationClass ? element.durationClass : element.duration,\n\t\t\t\t\t\t\t\tisTiedToNext: element.startTie !== undefined,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Only add a bar if it is not repeated; that is, we don't want two bars in a row.\n\t\t\t\t\t\tif (element.type === 'bar') {\n\t\t\t\t\t\t\tif (voices[v].length === 0 || voices[v][voices[v].length-1].type !== 'bar') {\n\t\t\t\t\t\t\t\tif (element.elemset && element.elemset.length > 0 && element.elemset[0].attrs) {\n\t\t\t\t\t\t\t\t\tvar obj = getLineAndMeasure(element);\n\t\t\t\t\t\t\t\t\tvoices[v].push({ type: \"bar\",\n\t\t\t\t\t\t\t\t\t\tbarType: element.abcelem.type,\n\t\t\t\t\t\t\t\t\t\tstartEnding: element.abcelem.startEnding === \"1\",\n\t\t\t\t\t\t\t\t\t\tlineNum: obj.lineNum,\n\t\t\t\t\t\t\t\t\t\tmeasureNum: obj.measureNum\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn voices;\n\t\t}\n\n\t\t// Duplicates the elements that are repeated.\n\t\tfunction spreadVoices(voices) {\n\t\t\tvar ret = [];\n\t\t\tfor (var i = 0; i < voices.length; i++) {\n\t\t\t\tvar voice = voices[i];\n\t\t\t\tret.push([]);\n\t\t\t\tvar startRepeatIndex = 0; // If there is no explicit start repeat, then it starts at the beginning.\n\t\t\t\tvar endRepeatIndex = -1;\n\t\t\t\tfor (var j = 0; j < voice.length; j++) {\n\t\t\t\t\tvar elem = voice[j];\n\t\t\t\t\tret[i].push(voice[j]);\n\t\t\t\t\tvar endRepeat = (elem.barType === \"bar_right_repeat\" || elem.barType === \"bar_dbl_repeat\");\n\t\t\t\t\tvar startEnding = elem.startEnding;\n\t\t\t\t\tvar startRepeat = (elem.barType === \"bar_left_repeat\" || elem.barType === \"bar_dbl_repeat\" || elem.barType === \"bar_thick_thin\" || elem.barType === \"bar_thin_thick\" || elem.barType === \"bar_thin_thin\" || elem.barType === \"bar_right_repeat\");\n\t\t\t\t\tif (endRepeat) {\n\t\t\t\t\t\tif (endRepeatIndex === -1)\n\t\t\t\t\t\t\tendRepeatIndex = j;\n\t\t\t\t\t\tfor (var k = startRepeatIndex; k <= endRepeatIndex; k++) {\n\t\t\t\t\t\t\tret[i].push(parseCommon.clone(voice[k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (startEnding)\n\t\t\t\t\t\tendRepeatIndex = j;\n\t\t\t\t\tif (startRepeat)\n\t\t\t\t\t\tstartRepeatIndex = j+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tfunction combineVoices(voiceList) {\n\t\t\tvar eventHash = {};\n\t\t\tfor (var v = 0; v < voiceList.length; v++) {\n\t\t\t\tvar time = 0;\n\t\t\t\tvar isTiedState = false;\n\t\t\t\tfor (var i = 0; i < voiceList[v].length; i++) {\n\t\t\t\t\tvar item = voiceList[v][i];\n\t\t\t\t\titem.time = time;\n\t\t\t\t\tif (item.type === \"event\") {\n\t\t\t\t\t\tvar isTiedToNext = item.isTiedToNext;\n\t\t\t\t\t\tif (isTiedState) {\n\t\t\t\t\t\t\tif (!isTiedToNext)\n\t\t\t\t\t\t\t\tisTiedState = false;\n\t\t\t\t\t\t\t// If the note is tied on both sides it can just be ignored.\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// the last note wasn't tied.\n\t\t\t\t\t\t\tif (!eventHash[\"event\"+time])\n\t\t\t\t\t\t\t\teventHash[\"event\"+time] = item;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// If there is more than one voice then two notes can fall at the same time. Usually they would be lined up in the same place, but if it is a whole rest, then it is placed funny. In any case, the left most element wins.\n\t\t\t\t\t\t\t\teventHash[\"event\"+time].left = Math.min(eventHash[\"event\"+time].left, item.left);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isTiedToNext)\n\t\t\t\t\t\t\t\tisTiedState = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime += item.duration;\n\t\t\t\t\t} else {\n\t\t\t\t\t\teventHash[\"bar\"+time] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn eventHash;\n\t\t}\n\n\t\tvar timingEvents = [];\n\t\tfunction setupEvents(engraver) {\n\t\t\t// First, rearrange the elements to be in voice order (that is, remove the lines.)\n\t\t\t// Then, for each voice, duplicate the events needed for the repeats.\n\t\t\t// Then go through each event array and fill in the timingEvents.\n\t\t\tvar voiceList = convertToVoices(engraver.staffgroups);\n\t\t\tvoiceList = spreadVoices(voiceList);\n\n\t\t\tvar eventHash = combineVoices(voiceList);\n\n\t\t\t// now we have all the events, but if there are multiple voices then there may be events out of order or duplicated, so normalize it.\n\t\t\ttimingEvents = makeSortedArray(eventHash);\n\t\t\ttotalBeats = timingEvents[timingEvents.length-1].time / beatLength;\n\t\t\tif (options.scrollVertical) {\n\t\t\t\taddVerticalInfo(timingEvents);\n\t\t\t}\n\t\t}\n\t\tsetupEvents(tune.engraver);\n\n\t\tfunction isEndOfLine(currentNote) {\n\t\t\treturn currentNote.top !== currentNote.nextTop && currentNote.nextTop !== undefined;\n\t\t}\n\n\t\tfunction shouldScroll(outer, scrollPos, currentNote) {\n\t\t\tvar height = parseInt(outer.clientHeight, 10);\n\t\t\tvar isVisible = currentNote.nextBottom - scrollPos < height;\n\t\t\t//console.log(\"SCROLL: \", height, scrollPos, currentNote.nextTop, currentNote.nextBottom, isVisible);\n\t\t\treturn !isVisible;\n\t\t}\n\n\t\tvar lastTop = -1;\n\t\t// var inner = outer.querySelectorAll('.abcjs-inner');\n\t\tcurrentMargin = 0;\n\n\t\tif (options.scrollVertical) {\n\t\t\tsetMargin(0); // In case we are calling this a second time.\n\t\t}\n\n\t\tfunction processShowCursor() {\n\t\t\tvar currentNote = timingEvents.shift();\n\t\t\tif (!currentNote) {\n\t\t\t\tstopNextTime = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (currentNote.type === \"bar\") {\n\t\t\t\tif (options.scrollVertical) {\n\t\t\t\t\tif (isEndOfLine(currentNote) && shouldScroll(outer, currentMargin, currentNote)) {\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tsetMargin(currentNote.nextTop);\n\t\t\t\t\t\t}, millisecondsPerHalfMeasure);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (options.hideCurrentMeasure) {\n\t\t\t\t\tvar next = nextMeasure(currentNote.lineNum, currentNote.measureNum);\n\t\t\t\t\tif (next)\n\t\t\t\t\t\tprocessMeasureHider(next[0], next[1]);\n\t\t\t\t} else if (options.hideFinishedMeasures)\n\t\t\t\t\tprocessMeasureHider(currentNote.lineNum, currentNote.measureNum);\n\t\t\t\tif (timingEvents.length > 0)\n\t\t\t\t\treturn timingEvents[0].time / beatLength;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (options.scrollHint && lastTop !== currentNote.top) {\n\t\t\t\tlastTop = currentNote.top;\n\t\t\t\tsetMargin(lastTop);\n\t\t\t}\n\t\t\tif (options.showCursor && cursor && cursor.style) {\n\t\t\t\tcursor.style.left = currentNote.left + \"px\";\n\t\t\t\tcursor.style.top = currentNote.top + \"px\";\n\t\t\t\tcursor.style.width = currentNote.width + \"px\";\n\t\t\t\tcursor.style.height = currentNote.height + \"px\";\n\t\t\t}\n\t\t\tif (timingEvents.length > 0)\n\t\t\t\treturn timingEvents[0].time / beatLength;\n\t\t\tstopNextTime = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tprocessNext = function() {\n\t\t\tif (stopNextTime) {\n\t\t\t\tanimation.stopAnimation();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar currentTime = new Date().getTime();\n\t\t\tif (isPaused) {\n\t\t\t\t// The isPaused flag must have just turned on. If it had been encountered before, we wouldn't be calling processNext.\n\t\t\t\t// pausedTime contains the moment that pause was called. There is a delay until here, so the timing will be off by the distance.\n\t\t\t\tpausedDifference = currentTime - pausedTime;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar nextTimeInBeats = processShowCursor();\n\t\t\tvar nextTimeInMilliseconds = nextTimeInBeats / beatsPerMillisecond;\n\t\t\tvar interval = startTime + nextTimeInMilliseconds - currentTime;\n\t\t\tif (interval <= 0)\n\t\t\t\tprocessNext();\n\t\t\telse\n\t\t\t\tanimateTimer = setTimeout(processNext, interval);\n\t\t}\n\t\tstartTime = new Date();\n\t\tstartTime = startTime.getTime();\n\t\tisPaused = false;\n\t\tif (options.hideCurrentMeasure) {\n\t\t\tvar next = nextMeasure(0, -1);\n\t\t\tif (next)\n\t\t\t\tprocessMeasureHider(next[0], next[1]);\n\t\t}\n\t\tprocessNext();\n\n\t};\n\n\tanimation.pauseAnimation = function(pause) {\n\t\tif (!processNext) {\n\t\t\tconsole.warn(\"Cannot call pauseAnimation before calling startAnimation\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (pause && !isPaused) {\n\t\t\tisPaused = true;\n\t\t\tpausedTime = new Date().getTime();\n\t\t} else if (!pause && isPaused) {\n\t\t\tvar nowTime = new Date().getTime();\n\t\t\tvar elapsedTimeWhenPaused = nowTime - pausedTime;\n\t\t\tstartTime += elapsedTimeWhenPaused;\n\t\t\tpausedTime = undefined;\n\t\t\tisPaused = false;\n\t\t\tanimateTimer = setTimeout(processNext, pausedDifference);\n\t\t\tpausedDifference = undefined;\n\t\t}\n\t};\n\n\tanimation.stopAnimation = function() {\n\t\tclearTimeout(animateTimer);\n\t\tclearTimeout(scrollTimer);\n\t\tif (cursor) {\n\t\t\tcursor.remove();\n\t\t\tcursor = null;\n\t\t}\n\t\tif (shouldResetOverflow) {\n\t\t\tif (animationTarget && animationTarget.parentNode) // If the music was redrawn or otherwise disappeared before the animation was finished, this might be null.\n\t\t\t\tanimationTarget.parentNode.style.overflowY = \"auto\";\n\t\t\tsetMargin(0);\n\t\t}\n\t};\n})();\n\nmodule.exports = animation;\n"]},"metadata":{},"sourceType":"script"}