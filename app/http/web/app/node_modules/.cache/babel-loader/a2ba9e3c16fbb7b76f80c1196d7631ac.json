{"ast":null,"code":"//    abc_tune.js: a computer usable internal structure representing one tune.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar parseCommon = require('../parse/abc_common');\n\nvar parseKeyVoice = require('../parse/abc_parse_key_voice');\n\nvar spacing = require('../write/abc_spacing');\n/**\n * This is the data for a single ABC tune. It is created and populated by the window.ABCJS.parse.Parse class.\n * Also known as the ABCJS Abstract Syntax Tree\n * @alternateClassName ABCJS.Tune\n */\n\n\nvar Tune = function () {\n  // The structure consists of a hash with the following two items:\n  // metaText: a hash of {key, value}, where key is one of: title, author, rhythm, source, transcription, unalignedWords, etc...\n  // tempo: { noteLength: number (e.g. .125), bpm: number }\n  // lines: an array of elements, or one of the following:\n  //\n  // STAFF: array of elements\n  // SUBTITLE: string\n  //\n  // TODO: actually, the start and end char should modify each part of the note type\n  // The elements all have a type field and a start and end char\n  // field. The rest of the fields depend on the type and are listed below:\n  // REST: duration=1,2,4,8; chord: string\n  // NOTE: accidental=none,dbl_flat,flat,natural,sharp,dbl_sharp\n  //\t\tpitch: \"C\" is 0. The numbers refer to the pitch letter.\n  //\t\tduration: .5 (sixteenth), .75 (dotted sixteenth), 1 (eighth), 1.5 (dotted eighth)\n  //\t\t\t2 (quarter), 3 (dotted quarter), 4 (half), 6 (dotted half) 8 (whole)\n  //\t\tchord: { name:chord, position: one of 'default', 'above', 'below' }\n  //\t\tend_beam = true or undefined if this is the last note in a beam.\n  //\t\tlyric: array of { syllable: xxx, divider: one of \" -_\" }\n  //\t\tstartTie = true|undefined\n  //\t\tendTie = true|undefined\n  //\t\tstartTriplet = num <- that is the number to print\n  //\t\tendTriplet = true|undefined (the last note of the triplet)\n  // TODO: actually, decoration should be an array.\n  //\t\tdecoration: upbow, downbow, accent\n  // BAR: type=bar_thin, bar_thin_thick, bar_thin_thin, bar_thick_thin, bar_right_repeat, bar_left_repeat, bar_double_repeat\n  //\tnumber: 1 or 2: if it is the start of a first or second ending\n  // CLEF: type=treble,bass\n  // KEY-SIG:\n  //\t\taccidentals[]: { acc:sharp|dblsharp|natural|flat|dblflat,  note:a|b|c|d|e|f|g }\n  // METER: type: common_time,cut_time,specified\n  //\t\tif specified, { num: 99, den: 99 }\n  this.getBeatLength = function () {\n    for (var i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff) {\n        for (var j = 0; j < this.lines[i].staff.length; j++) {\n          if (this.lines[i].staff[j].meter) {\n            var meter = this.lines[i].staff[j].meter;\n\n            if (meter.type === \"specified\") {\n              if (meter.value.length > 0) {\n                var num = parseInt(meter.value[0].num, 10);\n                var den = parseInt(meter.value[0].den, 10);\n                if (num === 6 && den === 8) return 3 / 8;\n                if (num === 9 && den === 8) return 3 / 8;\n                if (num === 12 && den === 8) return 3 / 8;\n                return 1 / den;\n              } else return 1 / 4; // No meter was specified, so use this default\n\n            } else if (meter.type === 'cut_time') {\n              return 1 / 2;\n            } else {\n              return 1 / 4; // TODO-PER: this works for common time, but not for the ancient meters.\n            }\n          }\n        }\n      }\n    }\n\n    return 1 / 4; // No meter was specified, so use this default\n  };\n\n  this.getPickupLength = function () {\n    var pickupLength = 0;\n\n    for (var i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff) {\n        for (var j = 0; j < this.lines[i].staff.length; j++) {\n          for (var v = 0; v < this.lines[i].staff[j].voices.length; v++) {\n            var voice = this.lines[i].staff[j].voices[v];\n            var hasNote = false;\n\n            for (var el = 0; el < voice.length; el++) {\n              if (voice[el].duration) pickupLength += voice[el].duration;\n              if (pickupLength >= this.getBarLength()) pickupLength -= this.getBarLength();\n              if (voice[el].el_type === 'bar') return pickupLength;\n            }\n          }\n        }\n      }\n    }\n\n    return pickupLength;\n  };\n\n  this.getBarLength = function () {\n    var meter = this.getMeter();\n    var measureLength;\n\n    switch (meter.type) {\n      case \"common_time\":\n        measureLength = 1;\n        this.meter = {\n          num: 4,\n          den: 4\n        };\n        break;\n\n      case \"cut_time\":\n        measureLength = 1;\n        this.meter = {\n          num: 2,\n          den: 2\n        };\n        break;\n\n      default:\n        measureLength = meter.value[0].num / meter.value[0].den;\n        this.meter = {\n          num: parseInt(meter.value[0].num, 10),\n          den: parseInt(meter.value[0].den, 10)\n        };\n    }\n\n    return measureLength;\n  };\n\n  this.reset = function () {\n    this.version = \"1.0.1\";\n    this.media = \"screen\";\n    this.metaText = {};\n    this.formatting = {};\n    this.lines = [];\n    this.staffNum = 0;\n    this.voiceNum = 0;\n    this.lineNum = 0;\n  };\n\n  this.resolveOverlays = function () {\n    for (var i = 0; i < this.lines.length; i++) {\n      var line = this.lines[i];\n\n      if (line.staff) {\n        for (var j = 0; j < line.staff.length; j++) {\n          var staff = line.staff[j];\n          var overlayVoice = [];\n\n          for (var k = 0; k < staff.voices.length; k++) {\n            var voice = staff.voices[k];\n            overlayVoice.push({\n              hasOverlay: false,\n              voice: [],\n              snip: []\n            });\n            var durationThisBar = 0;\n            var inOverlay = false;\n            var snipStart = -1;\n\n            for (var kk = 0; kk < voice.length; kk++) {\n              var event = voice[kk];\n\n              if (event.el_type === \"overlay\") {\n                inOverlay = true;\n                snipStart = kk;\n                overlayVoice[k].hasOverlay = true;\n              } else if (event.el_type === \"bar\") {\n                if (inOverlay) {\n                  // delete the overlay events from this array without messing up this loop.\n                  inOverlay = false;\n                  overlayVoice[k].snip.push({\n                    start: snipStart,\n                    len: kk - snipStart\n                  });\n                } else {\n                  overlayVoice[k].voice.push({\n                    el_type: \"note\",\n                    duration: durationThisBar,\n                    rest: {\n                      type: \"invisible\"\n                    },\n                    startChar: event.startChar,\n                    endChar: event.endChar\n                  });\n                  overlayVoice[k].voice.push(event);\n                }\n\n                durationThisBar = 0;\n              } else if (event.el_type === \"note\") {\n                if (inOverlay) {\n                  overlayVoice[k].voice.push(event);\n                } else {\n                  durationThisBar += event.duration;\n                }\n              } else if (event.el_type === \"scale\" || event.el_type === \"stem\" || event.el_type === \"style\" || event.el_type === \"transpose\") {\n                // These types of events are duplicated on the overlay layer.\n                overlayVoice[k].voice.push(event);\n              }\n            }\n          }\n\n          for (k = 0; k < overlayVoice.length; k++) {\n            var ov = overlayVoice[k];\n\n            if (ov.hasOverlay) {\n              staff.voices.push(ov.voice);\n\n              for (var kkk = ov.snip.length - 1; kkk >= 0; kkk--) {\n                var snip = ov.snip[kkk];\n                staff.voices[k].splice(snip.start, snip.len);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  this.cleanUp = function (defWidth, defLength, barsperstaff, staffnonote, currSlur) {\n    this.closeLine(); // Close the last line.\n    // If the tempo was created with a string like \"Allegro\", then the duration of a beat needs to be set at the last moment, when it is most likely known.\n\n    if (this.metaText.tempo && this.metaText.tempo.bpm && !this.metaText.tempo.duration) this.metaText.tempo.duration = [this.getBeatLength()]; // Remove any blank lines\n\n    var anyDeleted = false;\n    var i, s, v;\n\n    for (i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff !== undefined) {\n        var hasAny = false;\n\n        for (s = 0; s < this.lines[i].staff.length; s++) {\n          if (this.lines[i].staff[s] === undefined) {\n            anyDeleted = true;\n            this.lines[i].staff[s] = null; //this.lines[i].staff[s] = { voices: []};\t// TODO-PER: There was a part missing in the abc music. How should we recover?\n          } else {\n            for (v = 0; v < this.lines[i].staff[s].voices.length; v++) {\n              if (this.lines[i].staff[s].voices[v] === undefined) this.lines[i].staff[s].voices[v] = []; // TODO-PER: There was a part missing in the abc music. How should we recover?\n              else if (this.containsNotes(this.lines[i].staff[s].voices[v])) hasAny = true;\n            }\n          }\n        }\n\n        if (!hasAny) {\n          this.lines[i] = null;\n          anyDeleted = true;\n        }\n      }\n    }\n\n    if (anyDeleted) {\n      this.lines = parseCommon.compact(this.lines);\n      parseCommon.each(this.lines, function (line) {\n        if (line.staff) line.staff = parseCommon.compact(line.staff);\n      });\n    } // if we exceeded the number of bars allowed on a line, then force a new line\n\n\n    if (barsperstaff) {\n      for (i = 0; i < this.lines.length; i++) {\n        if (this.lines[i].staff !== undefined) {\n          for (s = 0; s < this.lines[i].staff.length; s++) {\n            var permanentItems = [];\n\n            for (v = 0; v < this.lines[i].staff[s].voices.length; v++) {\n              var voice = this.lines[i].staff[s].voices[v];\n              var barNumThisLine = 0;\n\n              for (var n = 0; n < voice.length; n++) {\n                if (voice[n].el_type === 'bar') {\n                  barNumThisLine++;\n\n                  if (barNumThisLine >= barsperstaff) {\n                    // push everything else to the next line, if there is anything else,\n                    // and there is a next line. If there isn't a next line, create one.\n                    if (n < voice.length - 1) {\n                      if (i === this.lines.length - 1) {\n                        var cp = JSON.parse(JSON.stringify(this.lines[i]));\n                        this.lines.push(parseCommon.clone(cp));\n\n                        for (var ss = 0; ss < this.lines[i + 1].staff.length; ss++) {\n                          for (var vv = 0; vv < this.lines[i + 1].staff[ss].voices.length; vv++) this.lines[i + 1].staff[ss].voices[vv] = [];\n                        }\n                      }\n\n                      var startElement = n + 1;\n                      var section = this.lines[i].staff[s].voices[v].slice(startElement);\n                      this.lines[i].staff[s].voices[v] = this.lines[i].staff[s].voices[v].slice(0, startElement);\n                      this.lines[i + 1].staff[s].voices[v] = permanentItems.concat(section.concat(this.lines[i + 1].staff[s].voices[v]));\n                    }\n                  }\n                } else if (!voice[n].duration) {\n                  permanentItems.push(voice[n]);\n                }\n              }\n            }\n          }\n        }\n      }\n    } // If we were passed staffnonote, then we want to get rid of all staffs that contain only rests.\n\n\n    if (barsperstaff) {\n      anyDeleted = false;\n\n      for (i = 0; i < this.lines.length; i++) {\n        if (this.lines[i].staff !== undefined) {\n          for (s = 0; s < this.lines[i].staff.length; s++) {\n            var keepThis = false;\n\n            for (v = 0; v < this.lines[i].staff[s].voices.length; v++) {\n              if (this.containsNotesStrict(this.lines[i].staff[s].voices[v])) {\n                keepThis = true;\n              }\n            }\n\n            if (!keepThis) {\n              anyDeleted = true;\n              this.lines[i].staff[s] = null;\n            }\n          }\n        }\n      }\n\n      if (anyDeleted) {\n        parseCommon.each(this.lines, function (line) {\n          if (line.staff) line.staff = parseCommon.compact(line.staff);\n        });\n      }\n    } // Remove the temporary working variables\n\n\n    for (i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff) {\n        for (s = 0; s < this.lines[i].staff.length; s++) delete this.lines[i].staff[s].workingClef;\n      }\n    } // If there are overlays, create new voices for them.\n\n\n    this.resolveOverlays();\n\n    function cleanUpSlursInLine(line) {\n      var x; //\t\t\tvar lyr = null;\t// TODO-PER: debugging.\n\n      var addEndSlur = function (obj, num, chordPos) {\n        if (currSlur[chordPos] === undefined) {\n          // There isn't an exact match for note position, but we'll take any other open slur.\n          for (x = 0; x < currSlur.length; x++) {\n            if (currSlur[x] !== undefined) {\n              chordPos = x;\n              break;\n            }\n          }\n\n          if (currSlur[chordPos] === undefined) {\n            var offNum = chordPos * 100 + 1;\n            parseCommon.each(obj.endSlur, function (x) {\n              if (offNum === x) --offNum;\n            });\n            currSlur[chordPos] = [offNum];\n          }\n        }\n\n        var slurNum;\n\n        for (var i = 0; i < num; i++) {\n          slurNum = currSlur[chordPos].pop();\n          obj.endSlur.push(slurNum); //\t\t\t\t\tlyr.syllable += '<' + slurNum;\t// TODO-PER: debugging\n        }\n\n        if (currSlur[chordPos].length === 0) delete currSlur[chordPos];\n        return slurNum;\n      };\n\n      var addStartSlur = function (obj, num, chordPos, usedNums) {\n        obj.startSlur = [];\n\n        if (currSlur[chordPos] === undefined) {\n          currSlur[chordPos] = [];\n        }\n\n        var nextNum = chordPos * 100 + 1;\n\n        for (var i = 0; i < num; i++) {\n          if (usedNums) {\n            parseCommon.each(usedNums, function (x) {\n              if (nextNum === x) ++nextNum;\n            });\n            parseCommon.each(usedNums, function (x) {\n              if (nextNum === x) ++nextNum;\n            });\n            parseCommon.each(usedNums, function (x) {\n              if (nextNum === x) ++nextNum;\n            });\n          }\n\n          parseCommon.each(currSlur[chordPos], function (x) {\n            if (nextNum === x) ++nextNum;\n          });\n          parseCommon.each(currSlur[chordPos], function (x) {\n            if (nextNum === x) ++nextNum;\n          });\n          currSlur[chordPos].push(nextNum);\n          obj.startSlur.push({\n            label: nextNum\n          }); //\t\t\t\t\tlyr.syllable += ' ' + nextNum + '>';\t// TODO-PER:debugging\n\n          nextNum++;\n        }\n      };\n\n      for (var i = 0; i < line.length; i++) {\n        var el = line[i]; //\t\t\t\tif (el.lyric === undefined)\t// TODO-PER: debugging\n        //\t\t\t\t\tel.lyric = [{ divider: '-' }];\t// TODO-PER: debugging\n        //\t\t\t\tlyr = el.lyric[0];\t// TODO-PER: debugging\n        //\t\t\t\tlyr.syllable = '';\t// TODO-PER: debugging\n\n        if (el.el_type === 'note') {\n          if (el.gracenotes) {\n            for (var g = 0; g < el.gracenotes.length; g++) {\n              if (el.gracenotes[g].endSlur) {\n                var gg = el.gracenotes[g].endSlur;\n                el.gracenotes[g].endSlur = [];\n\n                for (var ggg = 0; ggg < gg; ggg++) addEndSlur(el.gracenotes[g], 1, 20);\n              }\n\n              if (el.gracenotes[g].startSlur) {\n                x = el.gracenotes[g].startSlur;\n                addStartSlur(el.gracenotes[g], x, 20);\n              }\n            }\n          }\n\n          if (el.endSlur) {\n            x = el.endSlur;\n            el.endSlur = [];\n            addEndSlur(el, x, 0);\n          }\n\n          if (el.startSlur) {\n            x = el.startSlur;\n            addStartSlur(el, x, 0);\n          }\n\n          if (el.pitches) {\n            var usedNums = [];\n\n            for (var p = 0; p < el.pitches.length; p++) {\n              if (el.pitches[p].endSlur) {\n                var k = el.pitches[p].endSlur;\n                el.pitches[p].endSlur = [];\n\n                for (var j = 0; j < k; j++) {\n                  var slurNum = addEndSlur(el.pitches[p], 1, p + 1);\n                  usedNums.push(slurNum);\n                }\n              }\n            }\n\n            for (p = 0; p < el.pitches.length; p++) {\n              if (el.pitches[p].startSlur) {\n                x = el.pitches[p].startSlur;\n                addStartSlur(el.pitches[p], x, p + 1, usedNums);\n              }\n            } // Correct for the weird gracenote case where ({g}a) should match.\n            // The end slur was already assigned to the note, and needs to be moved to the first note of the graces.\n\n\n            if (el.gracenotes && el.pitches[0].endSlur && el.pitches[0].endSlur[0] === 100 && el.pitches[0].startSlur) {\n              if (el.gracenotes[0].endSlur) el.gracenotes[0].endSlur.push(el.pitches[0].startSlur[0].label);else el.gracenotes[0].endSlur = [el.pitches[0].startSlur[0].label];\n              if (el.pitches[0].endSlur.length === 1) delete el.pitches[0].endSlur;else if (el.pitches[0].endSlur[0] === 100) el.pitches[0].endSlur.shift();else if (el.pitches[0].endSlur[el.pitches[0].endSlur.length - 1] === 100) el.pitches[0].endSlur.pop();\n              if (currSlur[1].length === 1) delete currSlur[1];else currSlur[1].pop();\n            }\n          }\n        }\n      }\n    } // TODO-PER: This could be done faster as we go instead of as the last step.\n\n\n    function fixClefPlacement(el) {\n      parseKeyVoice.fixClef(el); //if (el.el_type === 'clef') {\n      //\t\t\t\tvar min = -2;\n      //\t\t\t\tvar max = 5;\n      //\t\t\t\tswitch(el.type) {\n      //\t\t\t\t\tcase 'treble+8':\n      //\t\t\t\t\tcase 'treble-8':\n      //\t\t\t\t\t\tbreak;\n      //\t\t\t\t\tcase 'bass':\n      //\t\t\t\t\tcase 'bass+8':\n      //\t\t\t\t\tcase 'bass-8':\n      //\t\t\t\t\t\tel.verticalPos = 20 + el.verticalPos; min += 6; max += 6;\n      //\t\t\t\t\t\tbreak;\n      //\t\t\t\t\tcase 'tenor':\n      //\t\t\t\t\tcase 'tenor+8':\n      //\t\t\t\t\tcase 'tenor-8':\n      //\t\t\t\t\t\tel.verticalPos = - el.verticalPos; min = -40; max = 40;\n      ////\t\t\t\t\t\tel.verticalPos+=2; min += 6; max += 6;\n      //\t\t\t\t\t\tbreak;\n      //\t\t\t\t\tcase 'alto':\n      //\t\t\t\t\tcase 'alto+8':\n      //\t\t\t\t\tcase 'alto-8':\n      //\t\t\t\t\t\tel.verticalPos = - el.verticalPos; min = -40; max = 40;\n      ////\t\t\t\t\t\tel.verticalPos-=2; min += 4; max += 4;\n      //\t\t\t\t\t\tbreak;\n      //\t\t\t\t}\n      //\t\t\t\tif (el.verticalPos < min) {\n      //\t\t\t\t\twhile (el.verticalPos < min)\n      //\t\t\t\t\t\tel.verticalPos += 7;\n      //\t\t\t\t} else if (el.verticalPos > max) {\n      //\t\t\t\t\twhile (el.verticalPos > max)\n      //\t\t\t\t\t\tel.verticalPos -= 7;\n      //\t\t\t\t}\n      //}\n    }\n\n    function getNextMusicLine(lines, currentLine) {\n      currentLine++;\n\n      while (lines.length > currentLine) {\n        if (lines[currentLine].staff) return lines[currentLine];\n        currentLine++;\n      }\n\n      return null;\n    }\n\n    for (this.lineNum = 0; this.lineNum < this.lines.length; this.lineNum++) {\n      var staff = this.lines[this.lineNum].staff;\n\n      if (staff) {\n        for (this.staffNum = 0; this.staffNum < staff.length; this.staffNum++) {\n          if (staff[this.staffNum].clef) fixClefPlacement(staff[this.staffNum].clef);\n\n          for (this.voiceNum = 0; this.voiceNum < staff[this.staffNum].voices.length; this.voiceNum++) {\n            var voice = staff[this.staffNum].voices[this.voiceNum];\n            cleanUpSlursInLine(voice);\n\n            for (var j = 0; j < voice.length; j++) {\n              if (voice[j].el_type === 'clef') fixClefPlacement(voice[j]);\n            }\n\n            if (voice.length > 0 && voice[voice.length - 1].barNumber) {\n              // Don't hang a bar number on the last bar line: it should go on the next line.\n              var nextLine = getNextMusicLine(this.lines, this.lineNum);\n              if (nextLine) nextLine.staff[0].barNumber = voice[voice.length - 1].barNumber;\n              delete voice[voice.length - 1].barNumber;\n            }\n          }\n        }\n      }\n    }\n\n    if (!this.formatting.pagewidth) this.formatting.pagewidth = defWidth;\n    if (!this.formatting.pageheight) this.formatting.pageheight = defLength; // Remove temporary variables that the outside doesn't need to know about\n\n    delete this.staffNum;\n    delete this.voiceNum;\n    delete this.lineNum;\n    delete this.potentialStartBeam;\n    delete this.potentialEndBeam;\n    delete this.vskipPending;\n    return currSlur;\n  };\n\n  this.reset();\n\n  this.getLastNote = function () {\n    if (this.lines[this.lineNum] && this.lines[this.lineNum].staff && this.lines[this.lineNum].staff[this.staffNum] && this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum]) {\n      for (var i = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum].length - 1; i >= 0; i--) {\n        var el = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum][i];\n\n        if (el.el_type === 'note') {\n          return el;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  this.addTieToLastNote = function () {\n    // TODO-PER: if this is a chord, which note?\n    var el = this.getLastNote();\n\n    if (el && el.pitches && el.pitches.length > 0) {\n      el.pitches[0].startTie = {};\n      return true;\n    }\n\n    return false;\n  };\n\n  this.getDuration = function (el) {\n    if (el.duration) return el.duration; //if (el.pitches && el.pitches.length > 0) return el.pitches[0].duration;\n\n    return 0;\n  };\n\n  this.closeLine = function () {\n    if (this.potentialStartBeam && this.potentialEndBeam) {\n      this.potentialStartBeam.startBeam = true;\n      this.potentialEndBeam.endBeam = true;\n    }\n\n    delete this.potentialStartBeam;\n    delete this.potentialEndBeam;\n  };\n\n  this.appendElement = function (type, startChar, endChar, hashParams) {\n    var This = this;\n\n    var pushNote = function (hp) {\n      if (hp.pitches !== undefined) {\n        var mid = This.lines[This.lineNum].staff[This.staffNum].workingClef.verticalPos;\n        parseCommon.each(hp.pitches, function (p) {\n          p.verticalPos = p.pitch - mid;\n        });\n      }\n\n      if (hp.gracenotes !== undefined) {\n        var mid2 = This.lines[This.lineNum].staff[This.staffNum].workingClef.verticalPos;\n        parseCommon.each(hp.gracenotes, function (p) {\n          p.verticalPos = p.pitch - mid2;\n        });\n      }\n\n      This.lines[This.lineNum].staff[This.staffNum].voices[This.voiceNum].push(hp);\n    };\n\n    hashParams.el_type = type;\n    if (startChar !== null) hashParams.startChar = startChar;\n    if (endChar !== null) hashParams.endChar = endChar;\n\n    var endBeamHere = function () {\n      This.potentialStartBeam.startBeam = true;\n      hashParams.endBeam = true;\n      delete This.potentialStartBeam;\n      delete This.potentialEndBeam;\n    };\n\n    var endBeamLast = function () {\n      if (This.potentialStartBeam !== undefined && This.potentialEndBeam !== undefined) {\n        // Do we have a set of notes to beam?\n        This.potentialStartBeam.startBeam = true;\n        This.potentialEndBeam.endBeam = true;\n      }\n\n      delete This.potentialStartBeam;\n      delete This.potentialEndBeam;\n    };\n\n    if (type === 'note') {\n      // && (hashParams.rest !== undefined || hashParams.end_beam === undefined)) {\n      // Now, add the startBeam and endBeam where it is needed.\n      // end_beam is already set on the places where there is a forced end_beam. We'll remove that here after using that info.\n      // this.potentialStartBeam either points to null or the start beam.\n      // this.potentialEndBeam either points to null or the start beam.\n      // If we have a beam break (note is longer than a quarter, or an end_beam is on this element), then set the beam if we have one.\n      // reset the variables for the next notes.\n      var dur = This.getDuration(hashParams);\n\n      if (dur >= 0.25) {\n        // The beam ends on the note before this.\n        endBeamLast();\n      } else if (hashParams.force_end_beam_last && This.potentialStartBeam !== undefined) {\n        endBeamLast();\n      } else if (hashParams.end_beam && This.potentialStartBeam !== undefined) {\n        // the beam is forced to end on this note, probably because of a space in the ABC\n        if (hashParams.rest === undefined) endBeamHere();else endBeamLast();\n      } else if (hashParams.rest === undefined) {\n        // this a short note and we aren't about to end the beam\n        if (This.potentialStartBeam === undefined) {\n          // We aren't collecting notes for a beam, so start here.\n          if (!hashParams.end_beam) {\n            This.potentialStartBeam = hashParams;\n            delete This.potentialEndBeam;\n          }\n        } else {\n          This.potentialEndBeam = hashParams; // Continue the beaming, look for the end next note.\n        }\n      } //  end_beam goes on rests and notes which precede rests _except_ when a rest (or set of adjacent rests) has normal notes on both sides (no spaces)\n      //\t\t\tif (hashParams.rest !== undefined)\n      //\t\t\t{\n      //\t\t\t\thashParams.end_beam = true;\n      //\t\t\t\tvar el2 = this.getLastNote();\n      //\t\t\t\tif (el2) el2.end_beam = true;\n      //\t\t\t\t// TODO-PER: implement exception mentioned in the comment.\n      //\t\t\t}\n\n    } else {\n      // It's not a note, so there definitely isn't beaming after it.\n      endBeamLast();\n    }\n\n    delete hashParams.end_beam; // We don't want this temporary variable hanging around.\n\n    delete hashParams.force_end_beam_last; // We don't want this temporary variable hanging around.\n\n    pushNote(hashParams);\n  };\n\n  this.appendStartingElement = function (type, startChar, endChar, hashParams2) {\n    // If we're in the middle of beaming, then end the beam.\n    this.closeLine(); // We only ever want implied naturals the first time.\n\n    var impliedNaturals;\n\n    if (type === 'key') {\n      impliedNaturals = hashParams2.impliedNaturals;\n      delete hashParams2.impliedNaturals;\n      delete hashParams2.explicitAccidentals;\n    } // Clone the object because it will be sticking around for the next line and we don't want the extra fields in it.\n\n\n    var hashParams = parseCommon.clone(hashParams2);\n\n    if (this.lines[this.lineNum].staff) {\n      // be sure that we are on a music type line before doing the following.\n      // If this is a clef type, then we replace the working clef on the line. This is kept separate from\n      // the clef in case there is an inline clef field. We need to know what the current position for\n      // the note is.\n      if (type === 'clef') this.lines[this.lineNum].staff[this.staffNum].workingClef = hashParams; // If this is the first item in this staff, then we might have to initialize the staff, first.\n\n      if (this.lines[this.lineNum].staff.length <= this.staffNum) {\n        this.lines[this.lineNum].staff[this.staffNum] = {};\n        this.lines[this.lineNum].staff[this.staffNum].clef = parseCommon.clone(this.lines[this.lineNum].staff[0].clef);\n        this.lines[this.lineNum].staff[this.staffNum].key = parseCommon.clone(this.lines[this.lineNum].staff[0].key);\n        if (this.lines[this.lineNum].staff[0].meter) this.lines[this.lineNum].staff[this.staffNum].meter = parseCommon.clone(this.lines[this.lineNum].staff[0].meter);\n        this.lines[this.lineNum].staff[this.staffNum].workingClef = parseCommon.clone(this.lines[this.lineNum].staff[0].workingClef);\n        this.lines[this.lineNum].staff[this.staffNum].voices = [[]];\n      } // These elements should not be added twice, so if the element exists on this line without a note or bar before it, just replace the staff version.\n\n\n      var voice = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];\n\n      for (var i = 0; i < voice.length; i++) {\n        if (voice[i].el_type === 'note' || voice[i].el_type === 'bar') {\n          hashParams.el_type = type;\n          hashParams.startChar = startChar;\n          hashParams.endChar = endChar;\n          if (impliedNaturals) hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);\n          voice.push(hashParams);\n          return;\n        }\n\n        if (voice[i].el_type === type) {\n          hashParams.el_type = type;\n          hashParams.startChar = startChar;\n          hashParams.endChar = endChar;\n          if (impliedNaturals) hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);\n          voice[i] = hashParams;\n          return;\n        }\n      } // We didn't see either that type or a note, so replace the element to the staff.\n\n\n      this.lines[this.lineNum].staff[this.staffNum][type] = hashParams2;\n    }\n  };\n\n  this.getNumLines = function () {\n    return this.lines.length;\n  };\n\n  this.pushLine = function (hash) {\n    if (this.vskipPending) {\n      hash.vskip = this.vskipPending;\n      delete this.vskipPending;\n    }\n\n    this.lines.push(hash);\n  };\n\n  this.addSubtitle = function (str) {\n    this.pushLine({\n      subtitle: str\n    });\n  };\n\n  this.addSpacing = function (num) {\n    this.vskipPending = num;\n  };\n\n  this.addNewPage = function (num) {\n    this.pushLine({\n      newpage: num\n    });\n  };\n\n  this.addSeparator = function (spaceAbove, spaceBelow, lineLength) {\n    this.pushLine({\n      separator: {\n        spaceAbove: spaceAbove,\n        spaceBelow: spaceBelow,\n        lineLength: lineLength\n      }\n    });\n  };\n\n  this.addText = function (str) {\n    this.pushLine({\n      text: str\n    });\n  };\n\n  this.addCentered = function (str) {\n    this.pushLine({\n      text: [{\n        text: str,\n        center: true\n      }]\n    });\n  };\n\n  this.containsNotes = function (voice) {\n    for (var i = 0; i < voice.length; i++) {\n      if (voice[i].el_type === 'note' || voice[i].el_type === 'bar') return true;\n    }\n\n    return false;\n  };\n\n  this.containsNotesStrict = function (voice) {\n    for (var i = 0; i < voice.length; i++) {\n      if (voice[i].el_type === 'note' && voice[i].rest === undefined) return true;\n    }\n\n    return false;\n  }; //\tanyVoiceContainsNotes: function(line) {\n  //\t\tfor (var i = 0; i < line.staff.voices.length; i++) {\n  //\t\t\tif (this.containsNotes(line.staff.voices[i]))\n  //\t\t\t\treturn true;\n  //\t\t}\n  //\t\treturn false;\n  //\t},\n\n\n  this.startNewLine = function (params) {\n    // If the pointed to line doesn't exist, just create that. If the line does exist, but doesn't have any music on it, just use it.\n    // If it does exist and has music, then increment the line number. If the new element doesn't exist, create it.\n    var This = this;\n    this.closeLine(); // Close the previous line.\n\n    var createVoice = function (params) {\n      This.lines[This.lineNum].staff[This.staffNum].voices[This.voiceNum] = [];\n\n      if (This.isFirstLine(This.lineNum)) {\n        if (params.name) {\n          if (!This.lines[This.lineNum].staff[This.staffNum].title) This.lines[This.lineNum].staff[This.staffNum].title = [];\n          This.lines[This.lineNum].staff[This.staffNum].title[This.voiceNum] = params.name;\n        }\n      } else {\n        if (params.subname) {\n          if (!This.lines[This.lineNum].staff[This.staffNum].title) This.lines[This.lineNum].staff[This.staffNum].title = [];\n          This.lines[This.lineNum].staff[This.staffNum].title[This.voiceNum] = params.subname;\n        }\n      }\n\n      if (params.style) This.appendElement('style', null, null, {\n        head: params.style\n      });\n      if (params.stem) This.appendElement('stem', null, null, {\n        direction: params.stem\n      });else if (This.voiceNum > 0) {\n        if (This.lines[This.lineNum].staff[This.staffNum].voices[0] !== undefined) {\n          var found = false;\n\n          for (var i = 0; i < This.lines[This.lineNum].staff[This.staffNum].voices[0].length; i++) {\n            if (This.lines[This.lineNum].staff[This.staffNum].voices[0].el_type === 'stem') found = true;\n          }\n\n          if (!found) {\n            var stem = {\n              el_type: 'stem',\n              direction: 'up'\n            };\n            This.lines[This.lineNum].staff[This.staffNum].voices[0].splice(0, 0, stem);\n          }\n        }\n\n        This.appendElement('stem', null, null, {\n          direction: 'down'\n        });\n      }\n      if (params.scale) This.appendElement('scale', null, null, {\n        size: params.scale\n      });\n    };\n\n    var createStaff = function (params) {\n      if (params.key && params.key.impliedNaturals) {\n        params.key.accidentals = params.key.accidentals.concat(params.key.impliedNaturals);\n        delete params.key.impliedNaturals;\n      }\n\n      This.lines[This.lineNum].staff[This.staffNum] = {\n        voices: [],\n        clef: params.clef,\n        key: params.key,\n        workingClef: params.clef\n      };\n\n      if (params.stafflines !== undefined) {\n        This.lines[This.lineNum].staff[This.staffNum].clef.stafflines = params.stafflines;\n        This.lines[This.lineNum].staff[This.staffNum].workingClef.stafflines = params.stafflines;\n      }\n\n      if (params.staffscale) {\n        This.lines[This.lineNum].staff[This.staffNum].staffscale = params.staffscale;\n      }\n\n      if (params.vocalfont) This.lines[This.lineNum].staff[This.staffNum].vocalfont = params.vocalfont;\n      if (params.bracket) This.lines[This.lineNum].staff[This.staffNum].bracket = params.bracket;\n      if (params.brace) This.lines[This.lineNum].staff[This.staffNum].brace = params.brace;\n      if (params.connectBarLines) This.lines[This.lineNum].staff[This.staffNum].connectBarLines = params.connectBarLines;\n      if (params.barNumber) This.lines[This.lineNum].staff[This.staffNum].barNumber = params.barNumber;\n      createVoice(params); // Some stuff just happens for the first voice\n\n      if (params.part) This.appendElement('part', params.startChar, params.endChar, {\n        title: params.part\n      });\n      if (params.meter !== undefined) This.lines[This.lineNum].staff[This.staffNum].meter = params.meter;\n    };\n\n    var createLine = function (params) {\n      This.lines[This.lineNum] = {\n        staff: []\n      };\n      createStaff(params);\n    };\n\n    if (this.lines[this.lineNum] === undefined) createLine(params);else if (this.lines[this.lineNum].staff === undefined) {\n      this.lineNum++;\n      this.startNewLine(params);\n    } else if (this.lines[this.lineNum].staff[this.staffNum] === undefined) createStaff(params);else if (this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] === undefined) createVoice(params);else if (!this.containsNotes(this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum])) return;else {\n      this.lineNum++;\n      this.startNewLine(params);\n    }\n  };\n\n  this.hasBeginMusic = function () {\n    // return true if there exists at least one line that contains \"staff\"\n    for (var i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff) return true;\n    }\n\n    return false;\n  };\n\n  this.isFirstLine = function (index) {\n    for (var i = index - 1; i >= 0; i--) {\n      if (this.lines[i].staff !== undefined) return false;\n    }\n\n    return true;\n  };\n\n  this.getMeter = function () {\n    for (var i = 0; i < this.lines.length; i++) {\n      var line = this.lines[i];\n\n      if (line.staff) {\n        for (var j = 0; j < line.staff.length; j++) {\n          var meter = line.staff[j].meter;\n\n          if (meter) {\n            return meter;\n          }\n        }\n      }\n    }\n\n    return {\n      type: \"common_time\"\n    };\n  };\n\n  this.getCurrentVoice = function () {\n    if (this.lines[this.lineNum] !== undefined && this.lines[this.lineNum].staff[this.staffNum] !== undefined && this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] !== undefined) return this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];else return null;\n  };\n\n  this.setCurrentVoice = function (staffNum, voiceNum) {\n    this.staffNum = staffNum;\n    this.voiceNum = voiceNum;\n\n    for (var i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff) {\n        if (this.lines[i].staff[staffNum] === undefined || this.lines[i].staff[staffNum].voices[voiceNum] === undefined || !this.containsNotes(this.lines[i].staff[staffNum].voices[voiceNum])) {\n          this.lineNum = i;\n          return;\n        }\n      }\n    }\n\n    this.lineNum = i;\n  };\n\n  this.addMetaText = function (key, value) {\n    if (this.metaText[key] === undefined) this.metaText[key] = value;else this.metaText[key] += \"\\n\" + value;\n  };\n\n  this.addMetaTextArray = function (key, value) {\n    if (this.metaText[key] === undefined) this.metaText[key] = [value];else this.metaText[key].push(value);\n  };\n\n  this.addMetaTextObj = function (key, value) {\n    this.metaText[key] = value;\n  };\n\n  function addVerticalInfo(timingEvents) {\n    // Add vertical info to the bar events: put the next event's top, and the event after the next measure's top.\n    var lastBarTop;\n    var lastBarBottom;\n    var lastEventTop;\n    var lastEventBottom;\n\n    for (var e = timingEvents.length - 1; e >= 0; e--) {\n      var ev = timingEvents[e];\n\n      if (ev.type === 'bar') {\n        ev.top = lastEventTop;\n        ev.nextTop = lastBarTop;\n        lastBarTop = lastEventTop;\n        ev.bottom = lastEventBottom;\n        ev.nextBottom = lastBarBottom;\n        lastBarBottom = lastEventBottom;\n      } else if (ev.type === 'event') {\n        lastEventTop = ev.top;\n        lastEventBottom = ev.top + ev.height;\n      }\n    }\n  }\n\n  function makeSortedArray(hash) {\n    var arr = [];\n\n    for (var k in hash) {\n      if (hash.hasOwnProperty(k)) arr.push(hash[k]);\n    }\n\n    arr = arr.sort(function (a, b) {\n      var diff = a.milliseconds - b.milliseconds; // if the events have the same time, make sure a bar comes before a note\n\n      if (diff !== 0) {\n        return diff;\n      } else {\n        return a.type === \"bar\" ? -1 : 1;\n      }\n    });\n    return arr;\n  }\n\n  this.addElementToEvents = function (eventHash, element, voiceTimeMilliseconds, top, height, timeDivider, isTiedState) {\n    if (element.hint) return {\n      isTiedState: undefined,\n      duration: 0\n    };\n    var realDuration = element.durationClass ? element.durationClass : element.duration;\n    if (element.abcelem.rest && element.abcelem.rest.type === \"spacer\") realDuration = 0;\n\n    if (realDuration > 0) {\n      var isTiedToNext = element.startTie;\n\n      if (isTiedState !== undefined) {\n        eventHash[\"event\" + isTiedState].elements.push(element.elemset); // Add the tied note to the first note that it is tied to\n\n        if (!isTiedToNext) isTiedState = undefined;\n      } else {\n        // the last note wasn't tied.\n        if (!eventHash[\"event\" + voiceTimeMilliseconds]) eventHash[\"event\" + voiceTimeMilliseconds] = {\n          type: \"event\",\n          milliseconds: voiceTimeMilliseconds,\n          top: top,\n          height: height,\n          left: element.x,\n          width: element.w,\n          elements: [element.elemset],\n          startChar: element.abcelem.startChar,\n          endChar: element.abcelem.endChar\n        };else {\n          // If there is more than one voice then two notes can fall at the same time. Usually they would be lined up in the same place, but if it is a whole rest, then it is placed funny. In any case, the left most element wins.\n          eventHash[\"event\" + voiceTimeMilliseconds].left = Math.min(eventHash[\"event\" + voiceTimeMilliseconds].left, element.x);\n          eventHash[\"event\" + voiceTimeMilliseconds].elements.push(element.elemset);\n        }\n        if (isTiedToNext) isTiedState = voiceTimeMilliseconds;\n      }\n    }\n\n    return {\n      isTiedState: isTiedState,\n      duration: realDuration / timeDivider\n    };\n  };\n\n  this.makeVoicesArray = function () {\n    // First make a new array that is arranged by voice so that the repeats that span different lines are handled correctly.\n    var voicesArr = [];\n\n    for (var line = 0; line < this.engraver.staffgroups.length; line++) {\n      var group = this.engraver.staffgroups[line];\n      var firstStaff = group.staffs[0];\n      var middleC = firstStaff.absoluteY;\n      var top = middleC - firstStaff.top * spacing.STEP;\n      var lastStaff = group.staffs[group.staffs.length - 1];\n      middleC = lastStaff.absoluteY;\n      var bottom = middleC - lastStaff.bottom * spacing.STEP;\n      var height = bottom - top;\n      var voices = group.voices;\n\n      for (var v = 0; v < voices.length; v++) {\n        if (!voicesArr[v]) voicesArr[v] = [];\n        var elements = voices[v].children;\n\n        for (var elem = 0; elem < elements.length; elem++) {\n          voicesArr[v].push({\n            top: top,\n            height: height,\n            elem: elements[elem]\n          });\n        }\n      }\n    }\n\n    return voicesArr;\n  };\n\n  this.setupEvents = function (startingDelay, timeDivider) {\n    var timingEvents = [];\n    var eventHash = {}; // The time is the number of seconds from the beginning of the piece.\n    // The units we are scanning are in notation units (i.e. 0.25 is a quarter note)\n\n    var time = startingDelay;\n    var isTiedState;\n    var voices = this.makeVoicesArray();\n\n    for (var v = 0; v < voices.length; v++) {\n      var voiceTime = time;\n      var voiceTimeMilliseconds = Math.round(voiceTime * 1000);\n      var startingRepeatElem = 0;\n      var endingRepeatElem = -1;\n      var elements = voices[v];\n\n      for (var elem = 0; elem < elements.length; elem++) {\n        var element = elements[elem].elem;\n\n        if (element.abcelem.el_type === \"tempo\") {\n          var bpm = this.getBpm(element.abcelem);\n          var beatLength = this.getBeatLength();\n          var beatsPerSecond = bpm / 60;\n          timeDivider = beatLength * beatsPerSecond;\n        }\n\n        var ret = this.addElementToEvents(eventHash, element, voiceTimeMilliseconds, elements[elem].top, elements[elem].height, timeDivider, isTiedState);\n        isTiedState = ret.isTiedState;\n        voiceTime += ret.duration;\n        voiceTimeMilliseconds = Math.round(voiceTime * 1000);\n\n        if (element.type === 'bar') {\n          var barType = element.abcelem.type;\n          var endRepeat = barType === \"bar_right_repeat\" || barType === \"bar_dbl_repeat\";\n          var startEnding = element.abcelem.startEnding === '1';\n          var startRepeat = barType === \"bar_left_repeat\" || barType === \"bar_dbl_repeat\" || barType === \"bar_right_repeat\";\n\n          if (endRepeat) {\n            if (endingRepeatElem === -1) endingRepeatElem = elem;\n\n            for (var el2 = startingRepeatElem; el2 < endingRepeatElem; el2++) {\n              element = elements[el2].elem;\n              ret = this.addElementToEvents(eventHash, element, voiceTimeMilliseconds, elements[elem].top, elements[elem].height, timeDivider, isTiedState);\n              isTiedState = ret.isTiedState;\n              voiceTime += ret.duration;\n              voiceTimeMilliseconds = Math.round(voiceTime * 1000);\n            }\n\n            endingRepeatElem = -1;\n          }\n\n          if (startEnding) endingRepeatElem = elem;\n          if (startRepeat) startingRepeatElem = elem;\n        }\n      }\n    } // now we have all the events, but if there are multiple voices then there may be events out of order or duplicated, so normalize it.\n\n\n    timingEvents = makeSortedArray(eventHash);\n    addVerticalInfo(timingEvents);\n    return timingEvents;\n  };\n\n  function getVertical(group) {\n    var voices = group.voices;\n    var firstStaff = group.staffs[0];\n    var middleC = firstStaff.absoluteY;\n    var top = middleC - firstStaff.top * spacing.STEP;\n    var lastStaff = group.staffs[group.staffs.length - 1];\n    middleC = lastStaff.absoluteY;\n    var bottom = middleC - lastStaff.bottom * spacing.STEP;\n    var height = bottom - top;\n    return {\n      top: top,\n      height: height\n    };\n  }\n\n  this.getBpm = function (tempo) {\n    var bpm;\n\n    if (tempo) {\n      bpm = tempo.bpm;\n      var beatLength = this.getBeatLength();\n      var statedBeatLength = tempo.duration && tempo.duration.length > 0 ? tempo.duration[0] : beatLength;\n      bpm = bpm * statedBeatLength / beatLength;\n    }\n\n    if (!bpm) bpm = 180;\n    return bpm;\n  };\n\n  this.setTiming = function (bpm, measuresOfDelay) {\n    var tempo = this.metaText ? this.metaText.tempo : null;\n    if (!bpm) bpm = this.getBpm(tempo);\n    var beatLength = this.getBeatLength();\n    var beatsPerSecond = bpm / 60;\n    var measureLength = this.getBarLength();\n    var startingDelay = measureLength / beatLength * measuresOfDelay / beatsPerSecond;\n    if (startingDelay) startingDelay -= this.getPickupLength() / beatLength / beatsPerSecond;\n    var timeDivider = beatLength * beatsPerSecond;\n    this.noteTimings = this.setupEvents(startingDelay, timeDivider);\n  };\n};\n\nmodule.exports = Tune;","map":{"version":3,"sources":["/Users/philbrockman/coding/MusicalGens/app/http/web/app/node_modules/abcjs/src/data/abc_tune.js"],"names":["parseCommon","require","parseKeyVoice","spacing","Tune","getBeatLength","i","lines","length","staff","j","meter","type","value","num","parseInt","den","getPickupLength","pickupLength","v","voices","voice","hasNote","el","duration","getBarLength","el_type","getMeter","measureLength","reset","version","media","metaText","formatting","staffNum","voiceNum","lineNum","resolveOverlays","line","overlayVoice","k","push","hasOverlay","snip","durationThisBar","inOverlay","snipStart","kk","event","start","len","rest","startChar","endChar","ov","kkk","splice","cleanUp","defWidth","defLength","barsperstaff","staffnonote","currSlur","closeLine","tempo","bpm","anyDeleted","s","undefined","hasAny","containsNotes","compact","each","permanentItems","barNumThisLine","n","cp","JSON","parse","stringify","clone","ss","vv","startElement","section","slice","concat","keepThis","containsNotesStrict","workingClef","cleanUpSlursInLine","x","addEndSlur","obj","chordPos","offNum","endSlur","slurNum","pop","addStartSlur","usedNums","startSlur","nextNum","label","gracenotes","g","gg","ggg","pitches","p","shift","fixClefPlacement","fixClef","getNextMusicLine","currentLine","clef","barNumber","nextLine","pagewidth","pageheight","potentialStartBeam","potentialEndBeam","vskipPending","getLastNote","addTieToLastNote","startTie","getDuration","startBeam","endBeam","appendElement","hashParams","This","pushNote","hp","mid","verticalPos","pitch","mid2","endBeamHere","endBeamLast","dur","force_end_beam_last","end_beam","appendStartingElement","hashParams2","impliedNaturals","explicitAccidentals","key","accidentals","getNumLines","pushLine","hash","vskip","addSubtitle","str","subtitle","addSpacing","addNewPage","newpage","addSeparator","spaceAbove","spaceBelow","lineLength","separator","addText","text","addCentered","center","startNewLine","params","createVoice","isFirstLine","name","title","subname","style","head","stem","direction","found","scale","size","createStaff","stafflines","staffscale","vocalfont","bracket","brace","connectBarLines","part","createLine","hasBeginMusic","index","getCurrentVoice","setCurrentVoice","addMetaText","addMetaTextArray","addMetaTextObj","addVerticalInfo","timingEvents","lastBarTop","lastBarBottom","lastEventTop","lastEventBottom","e","ev","top","nextTop","bottom","nextBottom","height","makeSortedArray","arr","hasOwnProperty","sort","a","b","diff","milliseconds","addElementToEvents","eventHash","element","voiceTimeMilliseconds","timeDivider","isTiedState","hint","realDuration","durationClass","abcelem","isTiedToNext","elements","elemset","left","width","w","Math","min","makeVoicesArray","voicesArr","engraver","staffgroups","group","firstStaff","staffs","middleC","absoluteY","STEP","lastStaff","children","elem","setupEvents","startingDelay","time","voiceTime","round","startingRepeatElem","endingRepeatElem","getBpm","beatLength","beatsPerSecond","ret","barType","endRepeat","startEnding","startRepeat","el2","getVertical","statedBeatLength","setTiming","measuresOfDelay","noteTimings","module","exports"],"mappings":"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","sourcesContent":["//    abc_tune.js: a computer usable internal structure representing one tune.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar parseCommon = require('../parse/abc_common');\nvar parseKeyVoice = require('../parse/abc_parse_key_voice');\nvar spacing = require('../write/abc_spacing');\n\n/**\n * This is the data for a single ABC tune. It is created and populated by the window.ABCJS.parse.Parse class.\n * Also known as the ABCJS Abstract Syntax Tree\n * @alternateClassName ABCJS.Tune\n */\nvar Tune = function() {\n\t// The structure consists of a hash with the following two items:\n\t// metaText: a hash of {key, value}, where key is one of: title, author, rhythm, source, transcription, unalignedWords, etc...\n\t// tempo: { noteLength: number (e.g. .125), bpm: number }\n\t// lines: an array of elements, or one of the following:\n\t//\n\t// STAFF: array of elements\n\t// SUBTITLE: string\n\t//\n\t// TODO: actually, the start and end char should modify each part of the note type\n\t// The elements all have a type field and a start and end char\n\t// field. The rest of the fields depend on the type and are listed below:\n\t// REST: duration=1,2,4,8; chord: string\n\t// NOTE: accidental=none,dbl_flat,flat,natural,sharp,dbl_sharp\n\t//\t\tpitch: \"C\" is 0. The numbers refer to the pitch letter.\n\t//\t\tduration: .5 (sixteenth), .75 (dotted sixteenth), 1 (eighth), 1.5 (dotted eighth)\n\t//\t\t\t2 (quarter), 3 (dotted quarter), 4 (half), 6 (dotted half) 8 (whole)\n\t//\t\tchord: { name:chord, position: one of 'default', 'above', 'below' }\n\t//\t\tend_beam = true or undefined if this is the last note in a beam.\n\t//\t\tlyric: array of { syllable: xxx, divider: one of \" -_\" }\n\t//\t\tstartTie = true|undefined\n\t//\t\tendTie = true|undefined\n\t//\t\tstartTriplet = num <- that is the number to print\n\t//\t\tendTriplet = true|undefined (the last note of the triplet)\n\t// TODO: actually, decoration should be an array.\n\t//\t\tdecoration: upbow, downbow, accent\n\t// BAR: type=bar_thin, bar_thin_thick, bar_thin_thin, bar_thick_thin, bar_right_repeat, bar_left_repeat, bar_double_repeat\n\t//\tnumber: 1 or 2: if it is the start of a first or second ending\n\t// CLEF: type=treble,bass\n\t// KEY-SIG:\n\t//\t\taccidentals[]: { acc:sharp|dblsharp|natural|flat|dblflat,  note:a|b|c|d|e|f|g }\n\t// METER: type: common_time,cut_time,specified\n\t//\t\tif specified, { num: 99, den: 99 }\n\n\tthis.getBeatLength = function() {\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff) {\n\t\t\t\tfor (var j = 0; j < this.lines[i].staff.length; j++) {\n\t\t\t\t\tif (this.lines[i].staff[j].meter) {\n\t\t\t\t\t\tvar meter = this.lines[i].staff[j].meter;\n\t\t\t\t\t\tif (meter.type === \"specified\") {\n\t\t\t\t\t\t\tif (meter.value.length > 0) {\n\t\t\t\t\t\t\t\tvar num = parseInt(meter.value[0].num, 10);\n\t\t\t\t\t\t\t\tvar den = parseInt(meter.value[0].den, 10);\n\t\t\t\t\t\t\t\tif (num === 6 && den === 8) return 3/8;\n\t\t\t\t\t\t\t\tif (num === 9 && den === 8) return 3/8;\n\t\t\t\t\t\t\t\tif (num === 12 && den === 8) return 3/8;\n\t\t\t\t\t\t\t\treturn 1/den;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn 1/4; // No meter was specified, so use this default\n\t\t\t\t\t\t} else if (meter.type === 'cut_time') {\n\t\t\t\t\t\t\treturn 1/2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn 1/4; // TODO-PER: this works for common time, but not for the ancient meters.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 1/4; // No meter was specified, so use this default\n\t};\n\n\tthis.getPickupLength = function() {\n\t\tvar pickupLength = 0;\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff) {\n\t\t\t\tfor (var j = 0; j < this.lines[i].staff.length; j++) {\n\t\t\t\t\tfor (var v = 0; v < this.lines[i].staff[j].voices.length; v++) {\n\t\t\t\t\t\tvar voice = this.lines[i].staff[j].voices[v];\n\t\t\t\t\t\tvar hasNote = false;\n\t\t\t\t\t\tfor (var el = 0; el < voice.length; el++) {\n\t\t\t\t\t\t\tif (voice[el].duration)\n\t\t\t\t\t\t\t\tpickupLength += voice[el].duration;\n\t\t\t\t\t\t\tif (pickupLength >= this.getBarLength())\n\t\t\t\t\t\t\t\tpickupLength -= this.getBarLength();\n\t\t\t\t\t\t\tif (voice[el].el_type === 'bar')\n\t\t\t\t\t\t\t\treturn pickupLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn pickupLength;\n\t};\n\n\tthis.getBarLength = function() {\n\t\tvar meter = this.getMeter();\n\t\tvar measureLength;\n\t\tswitch(meter.type) {\n\t\t\tcase \"common_time\": measureLength = 1; this.meter = { num: 4, den: 4}; break;\n\t\t\tcase \"cut_time\": measureLength = 1; this.meter = { num: 2, den: 2}; break;\n\t\t\tdefault: measureLength = meter.value[0].num/meter.value[0].den; this.meter = { num: parseInt(meter.value[0].num, 10), den: parseInt(meter.value[0].den,10)};\n\t\t}\n\t\treturn measureLength;\n\t};\n\n\tthis.reset = function () {\n\t\tthis.version = \"1.0.1\";\n\t\tthis.media = \"screen\";\n\t\tthis.metaText = {};\n\t\tthis.formatting = {};\n\t\tthis.lines = [];\n\t\tthis.staffNum = 0;\n\t\tthis.voiceNum = 0;\n\t\tthis.lineNum = 0;\n\t};\n\n\tthis.resolveOverlays = function() {\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tvar line = this.lines[i];\n\t\t\tif (line.staff) {\n\t\t\t\tfor (var j = 0; j < line.staff.length; j++) {\n\t\t\t\t\tvar staff = line.staff[j];\n\t\t\t\t\tvar overlayVoice = [];\n\t\t\t\t\tfor (var k = 0; k < staff.voices.length; k++) {\n\t\t\t\t\t\tvar voice = staff.voices[k];\n\t\t\t\t\t\toverlayVoice.push({ hasOverlay: false, voice: [], snip: []});\n\t\t\t\t\t\tvar durationThisBar = 0;\n\t\t\t\t\t\tvar inOverlay = false;\n\t\t\t\t\t\tvar snipStart = -1;\n\t\t\t\t\t\tfor (var kk = 0; kk < voice.length; kk++) {\n\t\t\t\t\t\t\tvar event = voice[kk];\n\t\t\t\t\t\t\tif (event.el_type === \"overlay\") {\n\t\t\t\t\t\t\t\tinOverlay = true;\n\t\t\t\t\t\t\t\tsnipStart = kk;\n\t\t\t\t\t\t\t\toverlayVoice[k].hasOverlay = true;\n\t\t\t\t\t\t\t} else if (event.el_type === \"bar\") {\n\t\t\t\t\t\t\t\tif (inOverlay) {\n\t\t\t\t\t\t\t\t\t// delete the overlay events from this array without messing up this loop.\n\t\t\t\t\t\t\t\t\tinOverlay = false;\n\t\t\t\t\t\t\t\t\toverlayVoice[k].snip.push({ start: snipStart, len: kk - snipStart});\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\toverlayVoice[k].voice.push({ el_type: \"note\", duration: durationThisBar, rest: {type: \"invisible\"}, startChar: event.startChar, endChar: event.endChar });\n\t\t\t\t\t\t\t\t\toverlayVoice[k].voice.push(event);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdurationThisBar = 0;\n\t\t\t\t\t\t\t} else if (event.el_type === \"note\") {\n\t\t\t\t\t\t\t\tif (inOverlay) {\n\t\t\t\t\t\t\t\t\toverlayVoice[k].voice.push(event);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdurationThisBar += event.duration;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (event.el_type === \"scale\" || event.el_type === \"stem\" || event.el_type === \"style\" || event.el_type === \"transpose\") {\n\t\t\t\t\t\t\t\t// These types of events are duplicated on the overlay layer.\n\t\t\t\t\t\t\t\toverlayVoice[k].voice.push(event);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (k = 0; k < overlayVoice.length; k++) {\n\t\t\t\t\t\tvar ov = overlayVoice[k];\n\t\t\t\t\t\tif (ov.hasOverlay) {\n\t\t\t\t\t\t\tstaff.voices.push(ov.voice);\n\t\t\t\t\t\t\tfor (var kkk = ov.snip.length-1; kkk >= 0; kkk--) {\n\t\t\t\t\t\t\t\tvar snip = ov.snip[kkk];\n\t\t\t\t\t\t\t\tstaff.voices[k].splice(snip.start, snip.len);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.cleanUp = function(defWidth, defLength, barsperstaff, staffnonote, currSlur) {\n\t\tthis.closeLine();\t// Close the last line.\n\n\t\t// If the tempo was created with a string like \"Allegro\", then the duration of a beat needs to be set at the last moment, when it is most likely known.\n\t\tif (this.metaText.tempo && this.metaText.tempo.bpm && !this.metaText.tempo.duration)\n\t\t\tthis.metaText.tempo.duration = [ this.getBeatLength() ];\n\n\t\t// Remove any blank lines\n\t\tvar anyDeleted = false;\n\t\tvar i, s, v;\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff !== undefined) {\n\t\t\t\tvar hasAny = false;\n\t\t\t\tfor (s = 0; s < this.lines[i].staff.length; s++) {\n\t\t\t\t\tif (this.lines[i].staff[s] === undefined) {\n\t\t\t\t\t\tanyDeleted = true;\n\t\t\t\t\t\tthis.lines[i].staff[s] = null;\n\t\t\t\t\t\t//this.lines[i].staff[s] = { voices: []};\t// TODO-PER: There was a part missing in the abc music. How should we recover?\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (v = 0; v < this.lines[i].staff[s].voices.length; v++) {\n\t\t\t\t\t\t\tif (this.lines[i].staff[s].voices[v] === undefined)\n\t\t\t\t\t\t\t\tthis.lines[i].staff[s].voices[v] = [];\t// TODO-PER: There was a part missing in the abc music. How should we recover?\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tif (this.containsNotes(this.lines[i].staff[s].voices[v])) hasAny = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!hasAny) {\n\t\t\t\t\tthis.lines[i] = null;\n\t\t\t\t\tanyDeleted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anyDeleted) {\n\t\t\tthis.lines = parseCommon.compact(this.lines);\n\t\t\tparseCommon.each(this.lines, function(line) {\n\t\t\t\tif (line.staff)\n\t\t\t\t\tline.staff = parseCommon.compact(line.staff);\n\t\t\t});\n\t\t}\n\n\t\t// if we exceeded the number of bars allowed on a line, then force a new line\n\t\tif (barsperstaff) {\n\t\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\t\tif (this.lines[i].staff !== undefined) {\n\t\t\t\t\tfor (s = 0; s < this.lines[i].staff.length; s++) {\n\t\t\t\t\t\tvar permanentItems = [];\n\t\t\t\t\t\tfor (v = 0; v < this.lines[i].staff[s].voices.length; v++) {\n\t\t\t\t\t\t\tvar voice = this.lines[i].staff[s].voices[v];\n\t\t\t\t\t\t\tvar barNumThisLine = 0;\n\t\t\t\t\t\t\tfor (var n = 0; n < voice.length; n++) {\n\t\t\t\t\t\t\t\tif (voice[n].el_type === 'bar') {\n\t\t\t\t\t\t\t\t\tbarNumThisLine++;\n\t\t\t\t\t\t\t\t\tif (barNumThisLine >= barsperstaff) {\n\t\t\t\t\t\t\t\t\t\t// push everything else to the next line, if there is anything else,\n\t\t\t\t\t\t\t\t\t\t// and there is a next line. If there isn't a next line, create one.\n\t\t\t\t\t\t\t\t\t\tif (n < voice.length - 1) {\n\t\t\t\t\t\t\t\t\t\t\tif (i === this.lines.length - 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar cp = JSON.parse(JSON.stringify(this.lines[i]));\n\t\t\t\t\t\t\t\t\t\t\t\tthis.lines.push(parseCommon.clone(cp));\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var ss = 0; ss < this.lines[i+1].staff.length; ss++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var vv = 0; vv < this.lines[i+1].staff[ss].voices.length; vv++)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.lines[i+1].staff[ss].voices[vv] = [];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tvar startElement = n + 1;\n\t\t\t\t\t\t\t\t\t\t\tvar section = this.lines[i].staff[s].voices[v].slice(startElement);\n\t\t\t\t\t\t\t\t\t\t\tthis.lines[i].staff[s].voices[v] = this.lines[i].staff[s].voices[v].slice(0, startElement);\n\t\t\t\t\t\t\t\t\t\t\tthis.lines[i+1].staff[s].voices[v] = permanentItems.concat(section.concat(this.lines[i+1].staff[s].voices[v]));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (!voice[n].duration) {\n\t\t\t\t\t\t\t\t\tpermanentItems.push(voice[n]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we were passed staffnonote, then we want to get rid of all staffs that contain only rests.\n\t\tif (barsperstaff) {\n\t\t\tanyDeleted = false;\n\t\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\t\tif (this.lines[i].staff !== undefined) {\n\t\t\t\t\tfor (s = 0; s < this.lines[i].staff.length; s++) {\n\t\t\t\t\t\tvar keepThis = false;\n\t\t\t\t\t\tfor (v = 0; v < this.lines[i].staff[s].voices.length; v++) {\n\t\t\t\t\t\t\tif (this.containsNotesStrict(this.lines[i].staff[s].voices[v])) {\n\t\t\t\t\t\t\t\tkeepThis = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!keepThis) {\n\t\t\t\t\t\t\tanyDeleted = true;\n\t\t\t\t\t\t\tthis.lines[i].staff[s] = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (anyDeleted) {\n\t\t\t\tparseCommon.each(this.lines, function(line) {\n\t\t\t\t\tif (line.staff)\n\t\t\t\t\t\tline.staff = parseCommon.compact(line.staff);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Remove the temporary working variables\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff) {\n\t\t\t\tfor (s = 0; s < this.lines[i].staff.length; s++)\n\t\t\t\t\t\tdelete this.lines[i].staff[s].workingClef;\n\t\t\t}\n\t\t}\n\n\t\t// If there are overlays, create new voices for them.\n\t\tthis.resolveOverlays();\n\n\t\tfunction cleanUpSlursInLine(line) {\n\t\t\tvar x;\n//\t\t\tvar lyr = null;\t// TODO-PER: debugging.\n\n\t\t\tvar addEndSlur = function(obj, num, chordPos) {\n\t\t\t\tif (currSlur[chordPos] === undefined) {\n\t\t\t\t\t// There isn't an exact match for note position, but we'll take any other open slur.\n\t\t\t\t\tfor (x = 0; x < currSlur.length; x++) {\n\t\t\t\t\t\tif (currSlur[x] !== undefined) {\n\t\t\t\t\t\t\tchordPos = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (currSlur[chordPos] === undefined) {\n\t\t\t\t\t\tvar offNum = chordPos*100+1;\n\t\t\t\t\t\tparseCommon.each(obj.endSlur, function(x) { if (offNum === x) --offNum; });\n\t\t\t\t\t\tcurrSlur[chordPos] = [offNum];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar slurNum;\n\t\t\t\tfor (var i = 0; i < num; i++) {\n\t\t\t\t\tslurNum = currSlur[chordPos].pop();\n\t\t\t\t\tobj.endSlur.push(slurNum);\n//\t\t\t\t\tlyr.syllable += '<' + slurNum;\t// TODO-PER: debugging\n\t\t\t\t}\n\t\t\t\tif (currSlur[chordPos].length === 0)\n\t\t\t\t\tdelete currSlur[chordPos];\n\t\t\t\treturn slurNum;\n\t\t\t};\n\n\t\t\tvar addStartSlur = function(obj, num, chordPos, usedNums) {\n\t\t\t\tobj.startSlur = [];\n\t\t\t\tif (currSlur[chordPos] === undefined) {\n\t\t\t\t\tcurrSlur[chordPos] = [];\n\t\t\t\t}\n\t\t\t\tvar nextNum = chordPos*100+1;\n\t\t\t\tfor (var i = 0; i < num; i++) {\n\t\t\t\t\tif (usedNums) {\n\t\t\t\t\t\tparseCommon.each(usedNums, function(x) { if (nextNum === x) ++nextNum; });\n\t\t\t\t\t\tparseCommon.each(usedNums, function(x) { if (nextNum === x) ++nextNum; });\n\t\t\t\t\t\tparseCommon.each(usedNums, function(x) { if (nextNum === x) ++nextNum; });\n\t\t\t\t\t}\n\t\t\t\t\tparseCommon.each(currSlur[chordPos], function(x) { if (nextNum === x) ++nextNum; });\n\t\t\t\t\tparseCommon.each(currSlur[chordPos], function(x) { if (nextNum === x) ++nextNum; });\n\n\t\t\t\t\tcurrSlur[chordPos].push(nextNum);\n\t\t\t\t\tobj.startSlur.push({ label: nextNum });\n//\t\t\t\t\tlyr.syllable += ' ' + nextNum + '>';\t// TODO-PER:debugging\n\t\t\t\t\tnextNum++;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < line.length; i++) {\n\t\t\t\tvar el = line[i];\n//\t\t\t\tif (el.lyric === undefined)\t// TODO-PER: debugging\n//\t\t\t\t\tel.lyric = [{ divider: '-' }];\t// TODO-PER: debugging\n//\t\t\t\tlyr = el.lyric[0];\t// TODO-PER: debugging\n//\t\t\t\tlyr.syllable = '';\t// TODO-PER: debugging\n\t\t\t\tif (el.el_type === 'note') {\n\t\t\t\t\tif (el.gracenotes) {\n\t\t\t\t\t\tfor (var g = 0; g < el.gracenotes.length; g++) {\n\t\t\t\t\t\t\tif (el.gracenotes[g].endSlur) {\n\t\t\t\t\t\t\t\tvar gg = el.gracenotes[g].endSlur;\n\t\t\t\t\t\t\t\tel.gracenotes[g].endSlur = [];\n\t\t\t\t\t\t\t\tfor (var ggg = 0; ggg < gg; ggg++)\n\t\t\t\t\t\t\t\t\taddEndSlur(el.gracenotes[g], 1, 20);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (el.gracenotes[g].startSlur) {\n\t\t\t\t\t\t\t\tx = el.gracenotes[g].startSlur;\n\t\t\t\t\t\t\t\taddStartSlur(el.gracenotes[g], x, 20);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (el.endSlur) {\n\t\t\t\t\t\tx = el.endSlur;\n\t\t\t\t\t\tel.endSlur = [];\n\t\t\t\t\t\taddEndSlur(el, x, 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (el.startSlur) {\n\t\t\t\t\t\tx = el.startSlur;\n\t\t\t\t\t\taddStartSlur(el, x, 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (el.pitches) {\n\t\t\t\t\t\tvar usedNums = [];\n\t\t\t\t\t\tfor (var p = 0; p < el.pitches.length; p++) {\n\t\t\t\t\t\t\tif (el.pitches[p].endSlur) {\n\t\t\t\t\t\t\t\tvar k = el.pitches[p].endSlur;\n\t\t\t\t\t\t\t\tel.pitches[p].endSlur = [];\n\t\t\t\t\t\t\t\tfor (var j = 0; j < k; j++) {\n\t\t\t\t\t\t\t\t\tvar slurNum = addEndSlur(el.pitches[p], 1, p+1);\n\t\t\t\t\t\t\t\t\tusedNums.push(slurNum);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (p = 0; p < el.pitches.length; p++) {\n\t\t\t\t\t\t\tif (el.pitches[p].startSlur) {\n\t\t\t\t\t\t\t\tx = el.pitches[p].startSlur;\n\t\t\t\t\t\t\t\taddStartSlur(el.pitches[p], x, p+1, usedNums);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Correct for the weird gracenote case where ({g}a) should match.\n\t\t\t\t\t\t// The end slur was already assigned to the note, and needs to be moved to the first note of the graces.\n\t\t\t\t\t\tif (el.gracenotes && el.pitches[0].endSlur && el.pitches[0].endSlur[0] === 100 && el.pitches[0].startSlur) {\n\t\t\t\t\t\t\tif (el.gracenotes[0].endSlur)\n\t\t\t\t\t\t\t\tel.gracenotes[0].endSlur.push(el.pitches[0].startSlur[0].label);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tel.gracenotes[0].endSlur = [el.pitches[0].startSlur[0].label];\n\t\t\t\t\t\t\tif (el.pitches[0].endSlur.length === 1)\n\t\t\t\t\t\t\t\tdelete el.pitches[0].endSlur;\n\t\t\t\t\t\t\telse if (el.pitches[0].endSlur[0] === 100)\n\t\t\t\t\t\t\t\tel.pitches[0].endSlur.shift();\n\t\t\t\t\t\t\telse if (el.pitches[0].endSlur[el.pitches[0].endSlur.length-1] === 100)\n\t\t\t\t\t\t\t\tel.pitches[0].endSlur.pop();\n\t\t\t\t\t\t\tif (currSlur[1].length === 1)\n\t\t\t\t\t\t\t\tdelete currSlur[1];\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcurrSlur[1].pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO-PER: This could be done faster as we go instead of as the last step.\n\t\tfunction fixClefPlacement(el) {\n\t\t\tparseKeyVoice.fixClef(el);\n\t\t\t//if (el.el_type === 'clef') {\n//\t\t\t\tvar min = -2;\n//\t\t\t\tvar max = 5;\n//\t\t\t\tswitch(el.type) {\n//\t\t\t\t\tcase 'treble+8':\n//\t\t\t\t\tcase 'treble-8':\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\tcase 'bass':\n//\t\t\t\t\tcase 'bass+8':\n//\t\t\t\t\tcase 'bass-8':\n//\t\t\t\t\t\tel.verticalPos = 20 + el.verticalPos; min += 6; max += 6;\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\tcase 'tenor':\n//\t\t\t\t\tcase 'tenor+8':\n//\t\t\t\t\tcase 'tenor-8':\n//\t\t\t\t\t\tel.verticalPos = - el.verticalPos; min = -40; max = 40;\n////\t\t\t\t\t\tel.verticalPos+=2; min += 6; max += 6;\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\tcase 'alto':\n//\t\t\t\t\tcase 'alto+8':\n//\t\t\t\t\tcase 'alto-8':\n//\t\t\t\t\t\tel.verticalPos = - el.verticalPos; min = -40; max = 40;\n////\t\t\t\t\t\tel.verticalPos-=2; min += 4; max += 4;\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t\tif (el.verticalPos < min) {\n//\t\t\t\t\twhile (el.verticalPos < min)\n//\t\t\t\t\t\tel.verticalPos += 7;\n//\t\t\t\t} else if (el.verticalPos > max) {\n//\t\t\t\t\twhile (el.verticalPos > max)\n//\t\t\t\t\t\tel.verticalPos -= 7;\n//\t\t\t\t}\n\t\t\t//}\n\t\t}\n\n\t\tfunction getNextMusicLine(lines, currentLine) {\n\t\t\tcurrentLine++;\n\t\t\twhile (lines.length > currentLine) {\n\t\t\t\tif (lines[currentLine].staff)\n\t\t\t\t\treturn lines[currentLine];\n\t\t\t\tcurrentLine++;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfor (this.lineNum = 0; this.lineNum < this.lines.length; this.lineNum++) {\n\t\t\tvar staff = this.lines[this.lineNum].staff;\n\t\t\tif (staff) {\n\t\t\t\tfor (this.staffNum = 0; this.staffNum < staff.length; this.staffNum++) {\n\t\t\t\t\tif (staff[this.staffNum].clef)\n\t\t\t\t\t\tfixClefPlacement(staff[this.staffNum].clef);\n\t\t\t\t\tfor (this.voiceNum = 0; this.voiceNum < staff[this.staffNum].voices.length; this.voiceNum++) {\n\t\t\t\t\t\tvar voice = staff[this.staffNum].voices[this.voiceNum];\n\t\t\t\t\t\tcleanUpSlursInLine(voice);\n\t\t\t\t\t\tfor (var j = 0; j < voice.length; j++) {\n\t\t\t\t\t\t\tif (voice[j].el_type === 'clef')\n\t\t\t\t\t\t\t\tfixClefPlacement(voice[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (voice.length > 0 && voice[voice.length-1].barNumber) {\n\t\t\t\t\t\t\t// Don't hang a bar number on the last bar line: it should go on the next line.\n\t\t\t\t\t\t\tvar nextLine = getNextMusicLine(this.lines, this.lineNum);\n\t\t\t\t\t\t\tif (nextLine)\n\t\t\t\t\t\t\t\tnextLine.staff[0].barNumber = voice[voice.length-1].barNumber;\n\t\t\t\t\t\t\tdelete voice[voice.length-1].barNumber;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!this.formatting.pagewidth)\n\t\t\tthis.formatting.pagewidth = defWidth;\n\t\tif (!this.formatting.pageheight)\n\t\t\tthis.formatting.pageheight = defLength;\n\n\t\t// Remove temporary variables that the outside doesn't need to know about\n\t\tdelete this.staffNum;\n\t\tdelete this.voiceNum;\n\t\tdelete this.lineNum;\n\t\tdelete this.potentialStartBeam;\n\t\tdelete this.potentialEndBeam;\n\t\tdelete this.vskipPending;\n\n\t\treturn currSlur;\n\t};\n\n\tthis.reset();\n\n\tthis.getLastNote = function() {\n\t\tif (this.lines[this.lineNum] && this.lines[this.lineNum].staff && this.lines[this.lineNum].staff[this.staffNum] &&\n\t\t\tthis.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum]) {\n\t\t\tfor (var i = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum].length-1; i >= 0; i--) {\n\t\t\t\tvar el = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum][i];\n\t\t\t\tif (el.el_type === 'note') {\n\t\t\t\t\treturn el;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\tthis.addTieToLastNote = function() {\n\t\t// TODO-PER: if this is a chord, which note?\n\t\tvar el = this.getLastNote();\n\t\tif (el && el.pitches && el.pitches.length > 0) {\n\t\t\tel.pitches[0].startTie = {};\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tthis.getDuration = function(el) {\n\t\tif (el.duration) return el.duration;\n\t\t//if (el.pitches && el.pitches.length > 0) return el.pitches[0].duration;\n\t\treturn 0;\n\t};\n\n\tthis.closeLine = function() {\n\t\tif (this.potentialStartBeam && this.potentialEndBeam) {\n\t\t\tthis.potentialStartBeam.startBeam = true;\n\t\t\tthis.potentialEndBeam.endBeam = true;\n\t\t}\n\t\tdelete this.potentialStartBeam;\n\t\tdelete this.potentialEndBeam;\n\t};\n\n\tthis.appendElement = function(type, startChar, endChar, hashParams)\n\t{\n\t\tvar This = this;\n\t\tvar pushNote = function(hp) {\n\t\t\tif (hp.pitches !== undefined) {\n\t\t\t\tvar mid = This.lines[This.lineNum].staff[This.staffNum].workingClef.verticalPos;\n\t\t\t\tparseCommon.each(hp.pitches, function(p) { p.verticalPos = p.pitch - mid; });\n\t\t\t}\n\t\t\tif (hp.gracenotes !== undefined) {\n\t\t\t\tvar mid2 = This.lines[This.lineNum].staff[This.staffNum].workingClef.verticalPos;\n\t\t\t\tparseCommon.each(hp.gracenotes, function(p) { p.verticalPos = p.pitch - mid2; });\n\t\t\t}\n\t\t\tThis.lines[This.lineNum].staff[This.staffNum].voices[This.voiceNum].push(hp);\n\t\t};\n\t\thashParams.el_type = type;\n\t\tif (startChar !== null)\n\t\t\thashParams.startChar = startChar;\n\t\tif (endChar !== null)\n\t\t\thashParams.endChar = endChar;\n\t\tvar endBeamHere = function() {\n\t\t\tThis.potentialStartBeam.startBeam = true;\n\t\t\thashParams.endBeam = true;\n\t\t\tdelete This.potentialStartBeam;\n\t\t\tdelete This.potentialEndBeam;\n\t\t};\n\t\tvar endBeamLast = function() {\n\t\t\tif (This.potentialStartBeam !== undefined && This.potentialEndBeam !== undefined) {\t// Do we have a set of notes to beam?\n\t\t\t\tThis.potentialStartBeam.startBeam = true;\n\t\t\t\tThis.potentialEndBeam.endBeam = true;\n\t\t\t}\n\t\t\tdelete This.potentialStartBeam;\n\t\t\tdelete This.potentialEndBeam;\n\t\t};\n\t\tif (type === 'note') { // && (hashParams.rest !== undefined || hashParams.end_beam === undefined)) {\n\t\t\t// Now, add the startBeam and endBeam where it is needed.\n\t\t\t// end_beam is already set on the places where there is a forced end_beam. We'll remove that here after using that info.\n\t\t\t// this.potentialStartBeam either points to null or the start beam.\n\t\t\t// this.potentialEndBeam either points to null or the start beam.\n\t\t\t// If we have a beam break (note is longer than a quarter, or an end_beam is on this element), then set the beam if we have one.\n\t\t\t// reset the variables for the next notes.\n\t\t\tvar dur = This.getDuration(hashParams);\n\t\t\tif (dur >= 0.25) {\t// The beam ends on the note before this.\n\t\t\t\tendBeamLast();\n\t\t\t} else if (hashParams.force_end_beam_last && This.potentialStartBeam !== undefined) {\n\t\t\t\tendBeamLast();\n\t\t\t} else if (hashParams.end_beam && This.potentialStartBeam !== undefined) {\t// the beam is forced to end on this note, probably because of a space in the ABC\n\t\t\t\tif (hashParams.rest === undefined)\n\t\t\t\t\tendBeamHere();\n\t\t\t\telse\n\t\t\t\t\tendBeamLast();\n\t\t\t} else if (hashParams.rest === undefined) {\t// this a short note and we aren't about to end the beam\n\t\t\t\tif (This.potentialStartBeam === undefined) {\t// We aren't collecting notes for a beam, so start here.\n\t\t\t\t\tif (!hashParams.end_beam) {\n\t\t\t\t\t\tThis.potentialStartBeam = hashParams;\n\t\t\t\t\t\tdelete This.potentialEndBeam;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tThis.potentialEndBeam = hashParams;\t// Continue the beaming, look for the end next note.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//  end_beam goes on rests and notes which precede rests _except_ when a rest (or set of adjacent rests) has normal notes on both sides (no spaces)\n//\t\t\tif (hashParams.rest !== undefined)\n//\t\t\t{\n//\t\t\t\thashParams.end_beam = true;\n//\t\t\t\tvar el2 = this.getLastNote();\n//\t\t\t\tif (el2) el2.end_beam = true;\n//\t\t\t\t// TODO-PER: implement exception mentioned in the comment.\n//\t\t\t}\n\t\t} else {\t// It's not a note, so there definitely isn't beaming after it.\n\t\t\tendBeamLast();\n\t\t}\n\t\tdelete hashParams.end_beam;\t// We don't want this temporary variable hanging around.\n\t\tdelete hashParams.force_end_beam_last;\t// We don't want this temporary variable hanging around.\n\t\tpushNote(hashParams);\n\t};\n\n\tthis.appendStartingElement = function(type, startChar, endChar, hashParams2)\n\t{\n\t\t// If we're in the middle of beaming, then end the beam.\n\t\tthis.closeLine();\n\n\t\t// We only ever want implied naturals the first time.\n\t\tvar impliedNaturals;\n\t\tif (type === 'key') {\n\t\t\timpliedNaturals = hashParams2.impliedNaturals;\n\t\t\tdelete hashParams2.impliedNaturals;\n\t\t\tdelete hashParams2.explicitAccidentals;\n\t\t}\n\n\t\t// Clone the object because it will be sticking around for the next line and we don't want the extra fields in it.\n\t\tvar hashParams = parseCommon.clone(hashParams2);\n\n\t\tif (this.lines[this.lineNum].staff) { // be sure that we are on a music type line before doing the following.\n\t\t\t// If this is a clef type, then we replace the working clef on the line. This is kept separate from\n\t\t\t// the clef in case there is an inline clef field. We need to know what the current position for\n\t\t\t// the note is.\n\t\t\tif (type === 'clef')\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].workingClef = hashParams;\n\n\t\t\t// If this is the first item in this staff, then we might have to initialize the staff, first.\n\t\t\tif (this.lines[this.lineNum].staff.length <= this.staffNum) {\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum] = {};\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].clef = parseCommon.clone(this.lines[this.lineNum].staff[0].clef);\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].key = parseCommon.clone(this.lines[this.lineNum].staff[0].key);\n\t\t\t\tif (this.lines[this.lineNum].staff[0].meter)\n\t\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].meter = parseCommon.clone(this.lines[this.lineNum].staff[0].meter);\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].workingClef = parseCommon.clone(this.lines[this.lineNum].staff[0].workingClef);\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].voices = [[]];\n\t\t\t}\n\n\t\t\t// These elements should not be added twice, so if the element exists on this line without a note or bar before it, just replace the staff version.\n\t\t\tvar voice = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];\n\t\t\tfor (var i = 0; i < voice.length; i++) {\n\t\t\t\tif (voice[i].el_type === 'note' || voice[i].el_type === 'bar') {\n\t\t\t\t\thashParams.el_type = type;\n\t\t\t\t\thashParams.startChar = startChar;\n\t\t\t\t\thashParams.endChar = endChar;\n\t\t\t\t\tif (impliedNaturals)\n\t\t\t\t\t\thashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);\n\t\t\t\t\tvoice.push(hashParams);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (voice[i].el_type === type) {\n\t\t\t\t\thashParams.el_type = type;\n\t\t\t\t\thashParams.startChar = startChar;\n\t\t\t\t\thashParams.endChar = endChar;\n\t\t\t\t\tif (impliedNaturals)\n\t\t\t\t\t\thashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);\n\t\t\t\t\tvoice[i] = hashParams;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// We didn't see either that type or a note, so replace the element to the staff.\n\t\t\tthis.lines[this.lineNum].staff[this.staffNum][type] = hashParams2;\n\t\t}\n\t};\n\n\tthis.getNumLines = function() {\n\t\treturn this.lines.length;\n\t};\n\n\tthis.pushLine = function(hash) {\n\t\tif (this.vskipPending) {\n\t\t\thash.vskip = this.vskipPending;\n\t\t\tdelete this.vskipPending;\n\t\t}\n\t\tthis.lines.push(hash);\n\t};\n\n\tthis.addSubtitle = function(str) {\n\t\tthis.pushLine({subtitle: str});\n\t};\n\n\tthis.addSpacing = function(num) {\n\t\tthis.vskipPending = num;\n\t};\n\n\tthis.addNewPage = function(num) {\n\t\tthis.pushLine({newpage: num});\n\t};\n\n\tthis.addSeparator = function(spaceAbove, spaceBelow, lineLength) {\n\t\tthis.pushLine({separator: {spaceAbove: spaceAbove, spaceBelow: spaceBelow, lineLength: lineLength}});\n\t};\n\n\tthis.addText = function(str) {\n\t\tthis.pushLine({text: str});\n\t};\n\n\tthis.addCentered = function(str) {\n\t\tthis.pushLine({text: [{text: str, center: true }]});\n\t};\n\n\tthis.containsNotes = function(voice) {\n\t\tfor (var i = 0; i < voice.length; i++) {\n\t\t\tif (voice[i].el_type === 'note' || voice[i].el_type === 'bar')\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tthis.containsNotesStrict = function(voice) {\n\t\tfor (var i = 0; i < voice.length; i++) {\n\t\t\tif (voice[i].el_type === 'note' && voice[i].rest === undefined)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n//\tanyVoiceContainsNotes: function(line) {\n//\t\tfor (var i = 0; i < line.staff.voices.length; i++) {\n//\t\t\tif (this.containsNotes(line.staff.voices[i]))\n//\t\t\t\treturn true;\n//\t\t}\n//\t\treturn false;\n//\t},\n\n\tthis.startNewLine = function(params) {\n\t\t// If the pointed to line doesn't exist, just create that. If the line does exist, but doesn't have any music on it, just use it.\n\t\t// If it does exist and has music, then increment the line number. If the new element doesn't exist, create it.\n\t\tvar This = this;\n\t\tthis.closeLine();\t// Close the previous line.\n\t\tvar createVoice = function(params) {\n\t\t\tThis.lines[This.lineNum].staff[This.staffNum].voices[This.voiceNum] = [];\n\t\t\tif (This.isFirstLine(This.lineNum)) {\n\t\t\t\tif (params.name) {if (!This.lines[This.lineNum].staff[This.staffNum].title) This.lines[This.lineNum].staff[This.staffNum].title = [];This.lines[This.lineNum].staff[This.staffNum].title[This.voiceNum] = params.name;}\n\t\t\t} else {\n\t\t\t\tif (params.subname) {if (!This.lines[This.lineNum].staff[This.staffNum].title) This.lines[This.lineNum].staff[This.staffNum].title = [];This.lines[This.lineNum].staff[This.staffNum].title[This.voiceNum] = params.subname;}\n\t\t\t}\n\t\t\tif (params.style)\n\t\t\t\tThis.appendElement('style', null, null, {head: params.style});\n\t\t\tif (params.stem)\n\t\t\t\tThis.appendElement('stem', null, null, {direction: params.stem});\n\t\t\telse if (This.voiceNum > 0) {\n\t\t\t\tif (This.lines[This.lineNum].staff[This.staffNum].voices[0]!== undefined) {\n\t\t\t\t\tvar found = false;\n\t\t\t\t\tfor (var i = 0; i < This.lines[This.lineNum].staff[This.staffNum].voices[0].length; i++) {\n\t\t\t\t\t\tif (This.lines[This.lineNum].staff[This.staffNum].voices[0].el_type === 'stem')\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\tvar stem = { el_type: 'stem', direction: 'up' };\n\t\t\t\t\t\tThis.lines[This.lineNum].staff[This.staffNum].voices[0].splice(0,0,stem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tThis.appendElement('stem', null, null, {direction: 'down'});\n\t\t\t}\n\t\t\tif (params.scale)\n\t\t\t\tThis.appendElement('scale', null, null, { size: params.scale} );\n\t\t};\n\t\tvar createStaff = function(params) {\n\t\t\tif (params.key && params.key.impliedNaturals) {\n\t\t\t\tparams.key.accidentals = params.key.accidentals.concat(params.key.impliedNaturals);\n\t\t\t\tdelete params.key.impliedNaturals;\n\t\t\t}\n\n\t\t\tThis.lines[This.lineNum].staff[This.staffNum] = {voices: [ ], clef: params.clef, key: params.key, workingClef: params.clef };\n\t\t\tif (params.stafflines !== undefined) {\n\t\t\t\tThis.lines[This.lineNum].staff[This.staffNum].clef.stafflines = params.stafflines;\n\t\t\t\tThis.lines[This.lineNum].staff[This.staffNum].workingClef.stafflines = params.stafflines;\n\t\t\t}\n\t\t\tif (params.staffscale) {\n\t\t\t\tThis.lines[This.lineNum].staff[This.staffNum].staffscale = params.staffscale;\n\t\t\t}\n\t\t\tif (params.vocalfont) This.lines[This.lineNum].staff[This.staffNum].vocalfont = params.vocalfont;\n\t\t\tif (params.bracket) This.lines[This.lineNum].staff[This.staffNum].bracket = params.bracket;\n\t\t\tif (params.brace) This.lines[This.lineNum].staff[This.staffNum].brace = params.brace;\n\t\t\tif (params.connectBarLines) This.lines[This.lineNum].staff[This.staffNum].connectBarLines = params.connectBarLines;\n\t\t\tif (params.barNumber) This.lines[This.lineNum].staff[This.staffNum].barNumber = params.barNumber;\n\t\t\tcreateVoice(params);\n\t\t\t// Some stuff just happens for the first voice\n\t\t\tif (params.part)\n\t\t\t\tThis.appendElement('part', params.startChar, params.endChar, {title: params.part});\n\t\t\tif (params.meter !== undefined) This.lines[This.lineNum].staff[This.staffNum].meter = params.meter;\n\t\t};\n\t\tvar createLine = function(params) {\n\t\t\tThis.lines[This.lineNum] = {staff: []};\n\t\t\tcreateStaff(params);\n\t\t};\n\t\tif (this.lines[this.lineNum] === undefined) createLine(params);\n\t\telse if (this.lines[this.lineNum].staff === undefined) {\n\t\t\tthis.lineNum++;\n\t\t\tthis.startNewLine(params);\n\t\t} else if (this.lines[this.lineNum].staff[this.staffNum] === undefined) createStaff(params);\n\t\telse if (this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] === undefined) createVoice(params);\n\t\telse if (!this.containsNotes(this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum])) return;\n\t\telse {\n\t\t\tthis.lineNum++;\n\t\t\tthis.startNewLine(params);\n\t\t}\n\t};\n\n\tthis.hasBeginMusic = function() {\n\t\t// return true if there exists at least one line that contains \"staff\"\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tthis.isFirstLine = function(index) {\n\t\tfor (var i = index-1; i >= 0; i--) {\n\t\t\tif (this.lines[i].staff !== undefined) return false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tthis.getMeter = function() {\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tvar line = this.lines[i];\n\t\t\tif (line.staff) {\n\t\t\t\tfor (var j = 0; j < line.staff.length; j++) {\n\t\t\t\t\tvar meter = line.staff[j].meter;\n\t\t\t\t\tif (meter) {\n\t\t\t\t\t\treturn meter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { type: \"common_time\", };\n\t};\n\n\tthis.getCurrentVoice = function() {\n\t\tif (this.lines[this.lineNum] !== undefined && this.lines[this.lineNum].staff[this.staffNum] !== undefined && this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] !== undefined)\n\t\t\treturn this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];\n\t\telse return null;\n\t};\n\n\tthis.setCurrentVoice = function(staffNum, voiceNum) {\n\t\tthis.staffNum = staffNum;\n\t\tthis.voiceNum = voiceNum;\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff) {\n\t\t\t\tif (this.lines[i].staff[staffNum] === undefined || this.lines[i].staff[staffNum].voices[voiceNum] === undefined ||\n\t\t\t\t\t!this.containsNotes(this.lines[i].staff[staffNum].voices[voiceNum] )) {\n\t\t\t\t\tthis.lineNum =  i;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.lineNum =  i;\n\t};\n\n\tthis.addMetaText = function(key, value) {\n\t\tif (this.metaText[key] === undefined)\n\t\t\tthis.metaText[key] = value;\n\t\telse\n\t\t\tthis.metaText[key] += \"\\n\" + value;\n\t};\n\n\tthis.addMetaTextArray = function(key, value) {\n\t\tif (this.metaText[key] === undefined)\n\t\t\tthis.metaText[key] = [value];\n\t\telse\n\t\t\tthis.metaText[key].push(value);\n\t};\n\tthis.addMetaTextObj = function(key, value) {\n\t\tthis.metaText[key] = value;\n\t};\n\n\tfunction addVerticalInfo(timingEvents) {\n\t\t// Add vertical info to the bar events: put the next event's top, and the event after the next measure's top.\n\t\tvar lastBarTop;\n\t\tvar lastBarBottom;\n\t\tvar lastEventTop;\n\t\tvar lastEventBottom;\n\t\tfor (var e = timingEvents.length - 1; e >= 0; e--) {\n\t\t\tvar ev = timingEvents[e];\n\t\t\tif (ev.type === 'bar') {\n\t\t\t\tev.top = lastEventTop;\n\t\t\t\tev.nextTop = lastBarTop;\n\t\t\t\tlastBarTop = lastEventTop;\n\n\t\t\t\tev.bottom = lastEventBottom;\n\t\t\t\tev.nextBottom = lastBarBottom;\n\t\t\t\tlastBarBottom = lastEventBottom;\n\t\t\t} else if (ev.type === 'event') {\n\t\t\t\tlastEventTop = ev.top;\n\t\t\t\tlastEventBottom = ev.top + ev.height;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction makeSortedArray(hash) {\n\t\tvar arr = [];\n\t\tfor (var k in hash) {\n\t\t\tif (hash.hasOwnProperty(k))\n\t\t\t\tarr.push(hash[k]);\n\t\t}\n\t\tarr = arr.sort(function (a, b) {\n\t\t\tvar diff = a.milliseconds - b.milliseconds;\n\t\t\t// if the events have the same time, make sure a bar comes before a note\n\t\t\tif (diff !== 0) {\n\t\t\t\treturn diff;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn a.type === \"bar\" ? -1 : 1;\n\t\t\t}\n\t\t});\n\t\treturn arr;\n\t}\n\n\tthis.addElementToEvents = function(eventHash, element, voiceTimeMilliseconds, top, height, timeDivider, isTiedState) {\n\t\tif (element.hint)\n\t\t\treturn { isTiedState: undefined, duration: 0 };\n\t\tvar realDuration = element.durationClass ? element.durationClass : element.duration;\n\t\tif (element.abcelem.rest && element.abcelem.rest.type === \"spacer\")\n\t\t\trealDuration = 0;\n\t\tif (realDuration > 0) {\n\t\t\tvar isTiedToNext = element.startTie;\n\t\t\tif (isTiedState !== undefined) {\n\t\t\t\teventHash[\"event\" + isTiedState].elements.push(element.elemset); // Add the tied note to the first note that it is tied to\n\t\t\t\tif (!isTiedToNext)\n\t\t\t\t\tisTiedState = undefined;\n\t\t\t} else {\n\t\t\t\t// the last note wasn't tied.\n\t\t\t\tif (!eventHash[\"event\" + voiceTimeMilliseconds])\n\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds] = {\n\t\t\t\t\t\ttype: \"event\",\n\t\t\t\t\t\tmilliseconds: voiceTimeMilliseconds,\n\t\t\t\t\t\ttop: top,\n\t\t\t\t\t\theight: height,\n\t\t\t\t\t\tleft: element.x,\n\t\t\t\t\t\twidth: element.w,\n\t\t\t\t\t\telements: [element.elemset],\n\t\t\t\t\t\tstartChar: element.abcelem.startChar,\n\t\t\t\t\t\tendChar: element.abcelem.endChar,\n\t\t\t\t\t};\n\t\t\t\telse {\n\t\t\t\t\t// If there is more than one voice then two notes can fall at the same time. Usually they would be lined up in the same place, but if it is a whole rest, then it is placed funny. In any case, the left most element wins.\n\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].left = Math.min(eventHash[\"event\" + voiceTimeMilliseconds].left, element.x);\n\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].elements.push(element.elemset);\n\t\t\t\t}\n\t\t\t\tif (isTiedToNext)\n\t\t\t\t\tisTiedState = voiceTimeMilliseconds;\n\t\t\t}\n\t\t}\n\t\treturn { isTiedState: isTiedState, duration: realDuration / timeDivider };\n\t};\n\n\tthis.makeVoicesArray = function() {\n\t\t// First make a new array that is arranged by voice so that the repeats that span different lines are handled correctly.\n\t\tvar voicesArr = [];\n\t\tfor (var line = 0; line < this.engraver.staffgroups.length; line++) {\n\t\t\tvar group = this.engraver.staffgroups[line];\n\t\t\tvar firstStaff = group.staffs[0];\n\t\t\tvar middleC = firstStaff.absoluteY;\n\t\t\tvar top = middleC - firstStaff.top * spacing.STEP;\n\t\t\tvar lastStaff = group.staffs[group.staffs.length - 1];\n\t\t\tmiddleC = lastStaff.absoluteY;\n\t\t\tvar bottom = middleC - lastStaff.bottom * spacing.STEP;\n\t\t\tvar height = bottom - top;\n\n\t\t\tvar voices = group.voices;\n\t\t\tfor (var v = 0; v < voices.length; v++) {\n\t\t\t\tif (!voicesArr[v])\n\t\t\t\t\tvoicesArr[v] = [];\n\t\t\t\tvar elements = voices[v].children;\n\t\t\t\tfor (var elem = 0; elem < elements.length; elem++) {\n\t\t\t\t\tvoicesArr[v].push({top: top, height: height, elem: elements[elem]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn voicesArr;\n\t};\n\n\tthis.setupEvents = function(startingDelay, timeDivider) {\n\t\tvar timingEvents = [];\n\n\t\tvar eventHash = {};\n\t\t// The time is the number of seconds from the beginning of the piece.\n\t\t// The units we are scanning are in notation units (i.e. 0.25 is a quarter note)\n\t\tvar time = startingDelay;\n\t\tvar isTiedState;\n\t\tvar voices = this.makeVoicesArray();\n\t\tfor (var v = 0; v < voices.length; v++) {\n\t\t\tvar voiceTime = time;\n\t\t\tvar voiceTimeMilliseconds = Math.round(voiceTime * 1000);\n\t\t\tvar startingRepeatElem = 0;\n\t\t\tvar endingRepeatElem = -1;\n\t\t\tvar elements = voices[v];\n\t\t\tfor (var elem = 0; elem < elements.length; elem++) {\n\t\t\t\tvar element = elements[elem].elem;\n\t\t\t\tif (element.abcelem.el_type === \"tempo\") {\n\t\t\t\t\tvar bpm = this.getBpm(element.abcelem);\n\t\t\t\t\tvar beatLength = this.getBeatLength();\n\t\t\t\t\tvar beatsPerSecond = bpm / 60;\n\t\t\t\t\ttimeDivider = beatLength * beatsPerSecond;\n\t\t\t\t}\n\t\t\t\tvar ret = this.addElementToEvents(eventHash, element, voiceTimeMilliseconds, elements[elem].top, elements[elem].height, timeDivider, isTiedState);\n\t\t\t\tisTiedState = ret.isTiedState;\n\t\t\t\tvoiceTime += ret.duration;\n\t\t\t\tvoiceTimeMilliseconds = Math.round(voiceTime * 1000);\n\t\t\t\tif (element.type === 'bar') {\n\t\t\t\t\tvar barType = element.abcelem.type;\n\t\t\t\t\tvar endRepeat = (barType === \"bar_right_repeat\" || barType === \"bar_dbl_repeat\");\n\t\t\t\t\tvar startEnding = (element.abcelem.startEnding === '1');\n\t\t\t\t\tvar startRepeat = (barType === \"bar_left_repeat\" || barType === \"bar_dbl_repeat\" || barType === \"bar_right_repeat\");\n\t\t\t\t\tif (endRepeat) {\n\t\t\t\t\t\tif (endingRepeatElem === -1)\n\t\t\t\t\t\t\tendingRepeatElem = elem;\n\t\t\t\t\t\tfor (var el2 = startingRepeatElem; el2 < endingRepeatElem; el2++) {\n\t\t\t\t\t\t\telement = elements[el2].elem;\n\t\t\t\t\t\t\tret = this.addElementToEvents(eventHash, element, voiceTimeMilliseconds, elements[elem].top, elements[elem].height, timeDivider, isTiedState);\n\t\t\t\t\t\t\tisTiedState = ret.isTiedState;\n\t\t\t\t\t\t\tvoiceTime += ret.duration;\n\t\t\t\t\t\t\tvoiceTimeMilliseconds = Math.round(voiceTime * 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tendingRepeatElem = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (startEnding)\n\t\t\t\t\t\tendingRepeatElem = elem;\n\t\t\t\t\tif (startRepeat)\n\t\t\t\t\t\tstartingRepeatElem = elem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// now we have all the events, but if there are multiple voices then there may be events out of order or duplicated, so normalize it.\n\t\ttimingEvents = makeSortedArray(eventHash);\n\t\taddVerticalInfo(timingEvents);\n\t\treturn timingEvents;\n\t};\n\n\tfunction getVertical(group) {\n\t\tvar voices = group.voices;\n\t\tvar firstStaff = group.staffs[0];\n\t\tvar middleC = firstStaff.absoluteY;\n\t\tvar top = middleC - firstStaff.top*spacing.STEP;\n\t\tvar lastStaff = group.staffs[group.staffs.length-1];\n\t\tmiddleC = lastStaff.absoluteY;\n\t\tvar bottom = middleC - lastStaff.bottom*spacing.STEP;\n\t\tvar height = bottom - top;\n\t\treturn { top: top, height: height };\n\t}\n\n\tthis.getBpm = function(tempo) {\n\t\tvar bpm;\n\t\tif (tempo) {\n\t\t\tbpm = tempo.bpm;\n\t\t\tvar beatLength = this.getBeatLength();\n\t\t\tvar statedBeatLength = tempo.duration && tempo.duration.length > 0 ? tempo.duration[0] : beatLength;\n\t\t\tbpm = bpm * statedBeatLength / beatLength;\n\t\t}\n\t\tif (!bpm)\n\t\t\tbpm = 180;\n\n\t\treturn bpm;\n\t};\n\n\tthis.setTiming = function (bpm, measuresOfDelay) {\n\t\tvar tempo = this.metaText ? this.metaText.tempo : null;\n\t\tif (!bpm)\n\t\t\tbpm = this.getBpm(tempo);\n\n\t\tvar beatLength = this.getBeatLength();\n\t\tvar beatsPerSecond = bpm / 60;\n\n\t\tvar measureLength = this.getBarLength();\n\n\t\tvar startingDelay = measureLength / beatLength * measuresOfDelay / beatsPerSecond;\n\t\tif (startingDelay)\n\t\t\tstartingDelay -= this.getPickupLength() / beatLength / beatsPerSecond;\n\t\tvar timeDivider = beatLength * beatsPerSecond;\n\n\t\tthis.noteTimings = this.setupEvents(startingDelay, timeDivider);\n\t};\n};\n\nmodule.exports = Tune;\n"]},"metadata":{},"sourceType":"script"}